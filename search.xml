<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[StringUtils.split()和string.split()的区别]]></title>
    <url>%2Fposts%2F44d23f55.html</url>
    <content type="text"><![CDATA[场景出于业务考虑，将多个字符串拼接起来时，使用的分隔符是;,;。如果要将这样一个拼接来的字符串分割成原本的多个字符串时，就需要使用到jdk自带的split()方法。不过因为公司的编程规范，改为使用了Apache工具类的StringUtils.split()。之后就发现，当被拼接的字符串里含有;或,时，就会出现分割不正确的问题。具体例子下面的代码，使用了上述的两种split方法，猜猜结果是什么。12345678910111213141516171819public class Test &#123; public static void main(final String[] args) &#123; final String str = "老肥,老肥;是个,逗比"; final String seperator = ";,;"; //Apache工具类的split方法 final String[] result1 = StringUtils.split(str, seperator); for (final String string : result1) &#123; System.out.println(string); &#125; System.out.println("############分割线###########"); //jdk的split方法 final String[] result2 = str.split(seperator); for (final String string : result2) &#123; System.out.println(string); &#125; &#125;&#125;分割的结果如下：123456老肥老肥是个逗比############分割线###########老肥,老肥;是个,逗比StringUtils.split()和string.split()的区别StringUtils.split()是把分隔符拆成一个个单独的字符，再用这些字符去把字符串进行分割的。只要匹配到了分隔符中的任意一个字符，就会进行分割。而string.split()是把分隔符作为一个整体来对字符串进行分割。比如分隔符是;,;，那么在用StringUtils.split()时，只要被分割的字符串里遇到;或,，就会被分割。而在用string.split()时，必须被分割的字符串里遇到;,;时才会被分割。另外string.split()的分隔符参数其实是正则表达式，而StringUtils.split()的分隔符参数就只是个普通的字符串。此外，StringUtils.split()是null-safe的，已经帮你判空了，这也是公司规范要我们使用Apache工具类的原因。不过由于这里的业务要求，最终还是选择使用string.split()。最后附上StringUtils.split()的部分底层实现：12345678910111213141516171819//standard casewhile (i &lt; len) &#123; if (separatorChars.indexOf(str.charAt(i)) &gt;= 0) &#123; if (match || preserveAllTokens) &#123; lastMatch = true; if (sizePlus1++ == max) &#123; i = len; lastMatch = false; &#125; list.add(str.substring(start, i)); match = false; &#125; start = ++i; continue; &#125; lastMatch = false; match = true; i++;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>split</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的标识符可以有多长]]></title>
    <url>%2Fposts%2Fd68d7e3a.html</url>
    <content type="text"><![CDATA[前言今天在查看项目代码时发现有这样一个逻辑：在查询数据库时通过代码去拼接一个SQL，这个SQL的某个字段的别名是由多个变量名拼接而成的，于是在拼接该别名时特地限制了其长度为30，如果超过30就只截取前30个字符来作为列别名。一时间很好奇为什么要限制列别名的长度，查阅过资料才明白，原来数据库的名字、表名、表别名、列名、列别名和函数名等，这些都属于标识符，不同数据库对于标识符会限定各种的长度最大值。关键字和标识符关键字：Key Words，就是那些在 SQL 语言里有固定含义的单词。比如很常用的select、update、delete等。标识符：Identifiers，就是一个用于标识的名字，比如数据库名、表名、表别名、列名、列别名和函数名等。SQL 标识符和关键字必须以一个字母开头 （a-z 以及带可区别标记的字母以及非拉丁字母 ）或下划线开头 （_）开头。标识符和关键字里随后的字符可以是字母，数字（0-9）， 或者下划线，但 SQL 标准不会定义包含数字或者以下划线开头或结尾的关键字。不同数据库的标识符的最大长度数据库类型表名字段名PostgreSQL63个字符63个字符SQL SERVER128个字符，临时表116个字符128个字符Oracle30个字符30个字符MySQL64个字符64个字符Access64个字符64个字符DB2128个字符128个字符PostgreSQL中的标识符PostgreSQL比较特殊，唯独它的标识符最大长度是63个字符，官方文档中是这样描述的：The system uses no more than NAMEDATALEN-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, NAMEDATALEN is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the NAMEDATALEN constant in src/include/pg_config_manual.h.Key words and unquoted identifiers are case insensitive.简单来说，PostgreSQL使用NAMEDATALEN - 1的值来限定标识符的最大长度，NAMEDATALEN默认是64，可以在PosrgreSQL的安装目录下的include/pg_config_manual.h去修改其值，在该shell文件中其注释如下：12345678/* * Maximum length for identifiers (e.g. table names, column names, * function names). Names actually are limited to one less byte than this, * because the length must include a trailing zero byte. * * Changing this requires an initdb. */#define NAMEDATALEN 64PostgreSQL关于标识符简单的例子如果我们把标识符命名超过了最大长度，那么会被自动截取掉超出的部分，只留下最大长度的标识符。1alter table tb_student add "哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈" varchar(400);如上SQL，由于数据库使用的是UTF-8编码，一个中文对应3个字符，也就是说，标识符最多只能有21个中文。上述SQL执行成功后，tb_student多出来一个新的字段哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，正好只有21个字符，多出来的字符被丢弃了。另外，标识符是不区分大小写的，但是如果用双引号把标识符包括起来，这时候就会区分大小写。参考链接PostgreSQL官方文档PostgreSQL中文文档各个数据库表名和字段名长度限制]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 模糊查询]]></title>
    <url>%2Fposts%2F8fd6368.html</url>
    <content type="text"><![CDATA[前言like、not like在SQL中用于模糊查询，%表示任意个字符，_表示单个任意字符，如果需要在模糊查询中查询这两个通配符，需要用ESCAPE进行转义，如下：1select * from table where name like '张/_小%' escape '/';这里表明/作为转义符，所以就可以在模糊查询中将通配符作为普通字符来搜索。另外，因为左模糊查询效率低下，一般不推荐在应用中去使用。除了以上通用的like和not like，在PostgreSQL中还有特殊的操作符用于模糊查询。ilike和not ilikeilike表示在模糊匹配字符串时不区分大小写，i即是ignore的意思。not ilike表示不模糊匹配字符串且不区分大小写。~和~*，!~和!~*~表示匹配正则表达式，且区分大小写。~*表示匹配正则表达式，且不区分大小写。可以通过这两个操作符来实现like和ilike一样的效果，如下：12345671.匹配以“张”开头的字符串select * from table where name ~ '^张';2.匹配以“小”结尾的字符串select * from table where name ~ '小$';其实这里的^和$就是正则表达式里的用法。!~是~的否定用法，表示不匹配正则表达式，且区分大小写。!~*是~*的否定用法，表示不匹配正则表达式，且不区分大小写。~~和~~*，!~~和!~~*~~等效于like，~~*等效于ilike。!~~等效于not like，!~~*等效于not ilike。参考链接postgresql数据库中~和like和ilike的区别postgreSQL sql语句中的~~符号是什么意思]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速删除node_modules文件夹]]></title>
    <url>%2Fposts%2Fe873a12.html</url>
    <content type="text"><![CDATA[前言当安装了较多模块后，node_modules目录下的文件会很多，直接删除整个目录会很慢，下面介绍些快速删除node_modules目录的方法。方法一：使用rimraf模块的命令在全局安装rimraf模块，然后通过其命令来快速删除node_modules目录：12npm install rimraf -grimraf node_modules方法二：使用命令来删除目录Windows下使用rmdir命令首先在cmd窗口中进入到node_modules文件夹所在的路径，接着执行命令：1rmdir /s/q node_modulesLinux下使用rm命令1rm -f /node_modules参考链接删除node_modules文件夹]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node_modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下完全卸载node.js并安装node.js的多版本管理工具nvm-windows]]></title>
    <url>%2Fposts%2F1908545a.html</url>
    <content type="text"><![CDATA[前言由于高版本的node.js导致gulp执行build命令失败，我需要在Windows下卸载掉已有的node.js并安装一个多版本管理工具nvm-windows，方便切换不同版本的node.js。nvm是Linux下常用的一个node.js多版本管理工具，但是nvm不能在Windows下使用，在GitHub上有个项目叫nvm-windows，可以让我们在Windows下对node.js进行多版本管理。nvm-windows的下载地址：https://github.com/coreybutler/nvm-windows/releases根据官方说明：123It comes with an installer (and uninstaller), because getting it should be easy. Please note, you need to uninstall any existing versions of node.js before installing NVM for Windows. Also delete any existing nodejs installation directories (e.g., &quot;C:\Program Files\nodejs&quot;) that might remain. NVM&apos;s generated symlink will not overwrite an existing (even empty) installation directory.You should also delete the existing npm install location (e.g. &quot;C:\Users&lt;user&gt;\AppData\Roaming\npm&quot;) so that the nvm install location will be correctly used instead. After install, reinstalling global utilities (e.g. gulp) will have to be done for each installed version of node:在安装nvm-windows前，如果以前安装过node，需要先卸载，并且要把目录清理干净。在Windows下完全卸载已安装的node.js从卸载程序卸载程序和功能，也可以直接右键node.js的安装包并选择卸载。重新启动（或者重新启动任务管理器杀死所有与节点相关的进程）。从下列的目录中找到相关的内容并删除掉：C:\Program Files (x86)\nodejsC:\Program Files\nodejsC:\Users\{User}\AppData\Roaming\npm（或%appdata%\npm）C:\Users\{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache）检查%PATH%环境变量以确保没有引用Nodejs或npm存在。重新启动电脑。安装nvm-windows并使用到GitHub的项目下载地址，选择下载nvm-setup.zip，解压后双击使用安装程序即可。查看已安装的nodejs版本1nvm list如果是第一次安装，使用该命令结果如下：123C:\Users\Lewis&gt;nvm listNo installations recognized.查看可安装的nodejs版本1nvm list available输入该命令结果如下：1234567891011121314151617181920212223242526C:\Users\Lewis&gt;nvm list available| CURRENT | LTS | OLD STABLE | OLD UNSTABLE ||--------------|--------------|--------------|--------------|| 11.10.0 | 10.15.1 | 0.12.18 | 0.11.16 || 11.9.0 | 10.15.0 | 0.12.17 | 0.11.15 || 11.8.0 | 10.14.2 | 0.12.16 | 0.11.14 || 11.7.0 | 10.14.1 | 0.12.15 | 0.11.13 || 11.6.0 | 10.14.0 | 0.12.14 | 0.11.12 || 11.5.0 | 10.13.0 | 0.12.13 | 0.11.11 || 11.4.0 | 8.15.0 | 0.12.12 | 0.11.10 || 11.3.0 | 8.14.1 | 0.12.11 | 0.11.9 || 11.2.0 | 8.14.0 | 0.12.10 | 0.11.8 || 11.1.0 | 8.13.0 | 0.12.9 | 0.11.7 || 11.0.0 | 8.12.0 | 0.12.8 | 0.11.6 || 10.12.0 | 8.11.4 | 0.12.7 | 0.11.5 || 10.11.0 | 8.11.3 | 0.12.6 | 0.11.4 || 10.10.0 | 8.11.2 | 0.12.5 | 0.11.3 || 10.9.0 | 8.11.1 | 0.12.4 | 0.11.2 || 10.8.0 | 8.11.0 | 0.12.3 | 0.11.1 || 10.7.0 | 8.10.0 | 0.12.2 | 0.11.0 || 10.6.0 | 8.9.4 | 0.12.1 | 0.9.12 || 10.5.0 | 8.9.3 | 0.12.0 | 0.9.11 || 10.4.1 | 8.9.2 | 0.10.48 | 0.9.10 |This is a partial list. For a complete list, visit https://nodejs.org/download/release安装指定版本的nodejs1nvm install 8.11.2 64-bit安装成功后可以查询看看已安装的nodejs版本：123C:\Users\Lewis&gt;nvm list 8.11.2有需要的话，可以继续安装其他版本的nodejs。使用指定版本的nodejs1nvm use 8.11.2安装成功后可以验证下版本：123456C:\Users\Lewis&gt;nvm list * 8.11.2 (Currently using 64-bit executable)C:\Users\Lewis&gt;node -vv8.11.2删除指定版本的nodejs1nvm uninstall 8.11.2参考链接Window下完全卸载删除NodejsWindows上node.js的多版本管理工具]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行gulp build报错]]></title>
    <url>%2Fposts%2F9af9bb6b.html</url>
    <content type="text"><![CDATA[问题与分析在执行gulp build报错如下：123456D:\coding\Resume\Resumes&gt;gulp buildgulp build[5628]: src\node_contextify.cc:628: Assertion `args[1]-&gt;IsString()&apos; failed.D:\coding\Resume\Resumes&gt;gulp -v[22:00:13] CLI version 2.0.1[22:00:13] Local version 3.9.1网上有很多人也遇到这个问题，到GitHub上的nodejs项目的issue里也可以找到该问题，地址在这。根据查阅的资料来看，这个问题是由于node升级到10.0.0后出现的，回退版本即可，按照GitHub上的答案选择使用8.11.2版本的node。解决方法不要使用改成10.0.0及以上版本的node，可以选择使用8.11.2版本的node。如果确实有需要去使用高版本的node，可以选择nodejs的多版本管理工具，方便切换不停版本的node。参考链接gulp 报错Github issue #20325]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 怎么设置在启动时提示选择工作空间]]></title>
    <url>%2Fposts%2F3671826f.html</url>
    <content type="text"><![CDATA[方法Window -&gt; Preferences -&gt; General -&gt; Startup and Shutdown -&gt; Workspaces勾选Prompt for workspace on startup参考链接怎样设置Eclipse在启动时提示选择工作空间]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 安装了jd-eclipse插件后依然无法反编译类文件]]></title>
    <url>%2Fposts%2F89d8e317.html</url>
    <content type="text"><![CDATA[问题Eclipse在安装了jd-eclipse插件后依然无法反编译类文件，这个问题是因为没有修改默认的类文件查看器。解决方法修改默认的类文件查看器为jd-eclipseWindow -&gt; Preference -&gt; General -&gt; Editors -&gt; File Associations选中*.class，将Class File Editor设置为默认(Default)选中*.class without source，将Class File Editor设置为默认(Default)；如果这一步操作只有Class File Viewer，则需要点击Add把Class File Editor添加进来并设置为默认(Default)接着重启Eclipse后就可以正常地反编译类文件了，如果缺少上述的第三步操作，会有比较大的可能依然无法反编译类文件。参考链接安装jadClipse插件后,还是不能反编译.class]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven - settings.xml简易配置Demo]]></title>
    <url>%2Fposts%2F1433f1c.html</url>
    <content type="text"><![CDATA[前言这里贴一下settings.xml的一个简易配置demo，就是简单配置了：本地的仓库地址、阿里云镜像、指定使用jdk1.8进行编译。这里使用的Maven是3.5.0版本的。配置文件demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the"License"); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they're all using the same Maven | installation). It's normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\repository\maven&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like "mvn prefix:goal". Maven will automatically add the group identifiers | "org.apache.maven.plugins" and "org.codehaus.mojo" if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the 'id' attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of '1.4' might activate a profile when the build is executed on a JDK version of '1.4.2_07'. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as 'env-dev', 'env-test', 'env-production', 'user-jdcasey', 'user-brett', etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id's for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- | Here is another profile, activated by the system property 'target-env' with a value of 'dev', | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set 'target-env' to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt;]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Access restriction: The type 'JPEGCodec' is not API]]></title>
    <url>%2Fposts%2F5f77a7c4.html</url>
    <content type="text"><![CDATA[问题今天导入项目时Eclipse报错如下：1Access restriction: The type &apos;JPEGCodec&apos; is not API (restriction on required library &apos;C:\Program Files\Java\jdk1.8.0_191\jre\lib\rt.jar&apos;)第一次遇到这种错误，百度了下，原来是因为Eclipse默认把访问受限的API设置成了Error级别，所以才会编译报错。解决方法方法一（推荐）直接将项目的JRE给remove掉，然后再重新将JRE添加到项目中，操作如下：右键项目，选择Properties -&gt; Java Build Path -&gt; Libraries -&gt; 选中JRE System Library [jdkxxxx] -&gt; 选择Remove接着选择Add Librariy...，重新加入JRE方法二修改Eclipse中关于访问受限的API的编译级别：Window -&gt; Preferences -&gt; Java -&gt; Compiler -&gt; Errors/Warnings，选择Deprecated and restricted API，将其中的Forbidden reference(access rules)的级别选为Warning。参考链接解决办法：Access restriction: The type JPEGImageEncoder is not accessible due to restriction]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下MySQL8.0.13解压版安装教程]]></title>
    <url>%2Fposts%2Fa28e251d.html</url>
    <content type="text"><![CDATA[下载MySQL8.0.13-64位下载地址在下载页面的底部，有三种安装包，第一种是MySQL的安装程序，下载完点击安装即可。第二种是普通的压缩版，体积较小。第三种是自带debug和测试的压缩版，体积较大。这种压缩包在网上暂时没有找到对应的安装文档说明，所以建议下载第二种压缩包，也就是普通版本的MySQL压缩包。配置环境变量新建环境变量如下：变量名：MYSQL_HOME变量值：D:\software\mysql-8.0.13-winx64（这里填写MySQL的安装路径）在path变量的变量值末尾加上：;%MYSQL_HOME%\bin如果是win10那种将一个变量的变量值分成一行行来填写的，则不需要加上英文分号。生成data文件打开cmd窗口，切换到%MYSQL_HOME%/bin下，输入命令：1mysqld --initialize-insecure --user=mysql接着等待命令执行完毕。这里需要注意的是，如果不是下载的普通版本的压缩包(体积较小那个)，会提示你找不到mysqld命令。启动MySQL服务输入命令：1net start mysql如果执行报错如下：1234D:\software\mysql-8.0.13-winx64&gt;net start mysql服务名无效。请键入 NET HELPMSG 2185 以获得更多的帮助。需要先执行以下命令：1mysqld -install此时得到执行结果如下：12D:\software\mysql-8.0.13-winx64&gt;mysqld -installService successfully installed.接着再次启动MySQL服务，得以成功：123D:\software\mysql-8.0.13-winx64&gt;net start mysqlMySQL 服务正在启动 ....MySQL 服务已经启动成功。登录MySQL执行命令：1mysql -u root -p此时会提示输入密码，由于初次登录MySQL，无需输入密码，所以直接回车即可，登录成功结果如下：123456789101112131415D:\software\mysql-8.0.13-winx64&gt;mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt;查询用户密码执行命令如下：1select host,user,authentication_string from mysql.user;结果如下：123456789101112mysql&gt; select host,user,authentication_string from mysql.user;+-----------+------------------+------------------------------------------------------------------------+| host | user | authentication_string |+-----------+------------------+------------------------------------------------------------------------+| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.session | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.sys | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | root | |+-----------+------------------+------------------------------------------------------------------------+4 rows in set (0.00 sec)mysql&gt;可以看到，root用户的密码是空的。修改root用户的密码执行命令：1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';这里的密码就随意填写，不建议使用过于简单的123456、root、admin之类的密码。该命令执行完毕会得到结果：12mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';Query OK, 0 rows affected (0.11 sec)接着需要继续执行命令：1flush privileges;该命令作用是刷新MySQL的系统权限相关表，这样才能使刚刚的密码修改成功。每次MySQL新设置用户或更改密码后都需要用flush privileges;来刷新MySQL的系统权限相关表，否则会出现拒绝访问。还有一种方法，就是重新启动MySQL服务，来使新设置生效。退出登录输入命令：1quit结果如下：1234mysql&gt; quitByeD:\software\mysql-8.0.13-winx64&gt;参考链接WINDOWS下安装MYSQL8.0.13解压版—图文详解flush privileges 什么意思]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE工具、文本编辑器的列块编辑模式]]></title>
    <url>%2Fposts%2Ff0ce18c5.html</url>
    <content type="text"><![CDATA[前言有时候需要对若干列进行一样的操作，比如在前一百行数据的最前边加上一样的字符，这时候可以通过列块编辑模式来快捷地实现这个效果。在列块编辑模式下，被选定的区域内的所有字符会被替换成你之后输入的字符。EclipseAlt + Shift + A启用列块编辑模式按住鼠标左键选定区域Alt + Shift + A关闭列块编辑模式IntelliJ IDEA按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。Notepad++两种方法：按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。按住Alt + Shift，然后用键盘的上下左右箭头进行选定区域。UltraEditUltraEdit的列块编辑模式快捷键是Alt + C，也可以直接在Column菜单里选择Column Mode，或者直接在工具栏里点击其图标按钮。使用方法有两种：先选定要同时编辑的区域，再启动列块编辑模式。先启动列块编辑模式，再选定要同时编辑的区域。EditPlus两种方法：菜单：编辑 -&gt; 选择 -&gt; 列选择使用快捷键Alt + C，接着移动鼠标或键盘上下左右键选定区域。注意：在自动换行的模式下是不行的，改为不自动换行就行了。可以参考设置自动换行的方法：EditPlus 3：设置自动换行EmEditor按住Alt + C不放，然后用鼠标选定区域。LiteEdit按住Alt不放，然后用鼠标进行列块选择。点击菜单上的“列块选择”后用鼠标进行列块选择。参考链接notepad++如何使用列块编辑模式？eclipse、EditPlus等编辑器选中列(块)的方法]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>常用软件</tag>
        <tag>列块编辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git - .gitignore怎么忽略已经被版本控制的文件]]></title>
    <url>%2Fposts%2Fa7180574.html</url>
    <content type="text"><![CDATA[问题如果某个文件已经存在于远程仓库了，也就是说某个文件已经被版本控制了，如果将该文件添加到.gitignore中，是无法生效的。因为.gitignore是用来控制尚未被纳入版本控制的文件，如果文件已经存在于远程库中，自然也就无法生效了。于是就此衍生了一个问题：.gitignore怎么忽略已经被版本控制的文件？解决方法方法一直接在远程库里将想要忽略的文件删除掉，再将该文件写入.gitignore中即可。这种做法的前提是，你确定该文件是允许从远程库删除掉的，然而有些时候，这种做法是不可能的。要么没权限去远程库删掉该文件，要么该文件是必须的。方法二使用命令git rm --cached filename，然后将该文件写入.gitignore中即可。该命令表示从git仓库中将文件移除，不再进行版本控制，但保留工作区的该文件。需要注意的是，该命令其实和方法一差不多。git rm表示移除某个文件，--cached表示从暂存区中移除，如果不加该参数就是直接从工作区移除了。工作区就是指的Working Tree，暂存区就是指的Stage。工作区就是我们的磁盘，被版本控制的文件都存放于工作区。如果改动了某个文件，首先要将该文件添加到暂存区(Stage)，然后再提交(commit)到本地仓库，最后才推送(push)到远程库。git rm --cached filename并不会从物理上删除文件，只是从暂存区中将文件删除。由于该文件原本已经被版本控制了，使用了该命令后，虽然保留了工作区的该文件，但是却会在暂存区中生成一个删除了该文件的记录，如果此时进行commit，就会把版本库里的该文件给删掉了，如果push到远程库，也会被删掉。最终还是走的方法一的路子。关于git rm --cached filename的补充看到有篇文章举例很详细，如下：新建文件1.txt，未被跟踪(Untracked files)，提交到暂存区(Changed to be committed)，未提交到版本库。 使用git rm —cached 1.txt：把文件恢复到未被跟踪的状态，即删除暂存区中的1.txt；文件1.txt，已经提交到版本库，工作区，暂存区都是干净的。使用git rm —cached 1.txt：把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。不影响工作区中的文件。文件1.txt, 已经提交到版本库，修改1.txt，并且提交到了暂存区。使用git rm —cached 1.txt：把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files。暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。不影响工作区中的文件。还是修改后的1.txt文件1.txt, 已经提交到版本库，修改1.txt，提交到暂存区，继续修改1.txt。使用git rm —cached 1.txt 会报错，不能执行操作。参考链接.gitignore无效，不能过滤某些文件git rm - - cached filenamegit忽略已经被提交的文件]]></content>
      <categories>
        <category>版本控制工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git - .gitignore文件的用法]]></title>
    <url>%2Fposts%2Fb6b49845.html</url>
    <content type="text"><![CDATA[.gitignore文件的作用.gitignore文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被git跟踪到的，换句话说，被忽略的文件是不会被放入到远程仓库里的。也就是说，如果文件已经存在于远程仓库中，是无法通过.gitignore文件来忽略的。.gitignore文件存放于git仓库的根目录下。.gitignore文件的语法注释#表示注释，如下：1# Here is comment.忽略文件/文件夹直接写入文件或文件夹名即可，指定文件夹里的所有文件也会一起被忽略，如下：12345678# ignore target foldertarget/# ignore Eclipse files.settings/build/.classpath.project不忽略文件/文件夹!表示不忽略指定的文件，如下：12# don&apos;t ignore src folder!src/在指定文件夹里不忽略指定的文件通过!可以实现更加有意思的用法，如下：123# ignore scaffolds folder, but don&apos;t ignore draft.md under scaffolds folder.scaffolds/*!scaffolds/draft.md注意：这里必须在文件夹后面加上/*，否则是无法实现想要的效果的。使用通配符及其他符号可以使用通配符及其他符号来指定复杂条件的文件，如下：1234*.logday_1?.txthello[0-9].txthi[^0-9].txt*表示匹配任意字符；?表示匹配一个字符；[]表示匹配中括号内的单个字符：可以使用-来表示连贯的字符，比如0-9，a-z，A-Z等，[0-9]表示匹配从0到9的单个字符。可以使用^来表示除外，比如[^0-9]表示除0到9之外的单个字符。参考链接.gitignore 规则写法 - 在已忽略文件夹中不忽略指定文件、文件夹【注意项】]]></content>
      <categories>
        <category>版本控制工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制工具</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j2 - 动态生成Appender]]></title>
    <url>%2Fposts%2F8dc44b45.html</url>
    <content type="text"><![CDATA[功能需求项目里将User分成了各个区域(domain)，这些domain有个标志domainId，现在要求在打印日志的时候，不仅将所有User的日志都打印到日志文件logs/CNTCore.log中，还需要另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log。比如User A的domainId是RD2，那么除了logs/CNTCore.log外，还需要将该User A的日志额外打印到logs/RD2/CNTCore.log中。实现思路将所有User的日志都打印到日志文件logs/CNTCore.log中，这个可以直接使用配置文件log4j2.xml来解决，一个简单的配置如下：123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration monitorInterval="30"&gt; &lt;Appenders&gt; &lt;Console name="stdout" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%-5p %m%n" /&gt; &lt;ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY" /&gt; &lt;/Console&gt; &lt;RollingFile name="cntCorelog" immediateFlush="true" fileName="logs/CNTCore.log" filePattern="logs/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz" append="true"&gt; &lt;PatternLayout&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;:%p %t %X&#123;TracingMsg&#125; %c - %m%n&lt;/pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1" /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name="com.lewis" level="debug" additivity="true"&gt; &lt;AppenderRef ref="cntCorelog" /&gt; &lt;/Logger&gt; &lt;Root level="error"&gt; &lt;AppenderRef ref="stdout" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/configuration&gt;在上边的配置中，配置了cntCorelog这个appender来生成对应的回滚日志文件，具体由com.lewis这个logger来使用该appender进行拼接日志信息。至于另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log，这个可以通过代码来动态生成各个domain的appender，并交由com.lewis这个logger来进行拼接日志。代码的具体实现项目的Log4j2依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt;&lt;/dependency&gt;动态生成appender123456789101112131415161718192021222324252627282930public static void createDomainAppender(final String domainId)&#123; final LoggerContext ctx = (LoggerContext) LogManager.getContext(false); final org.apache.logging.log4j.core.config.Configuration config = ctx.getConfiguration(); if (config.getAppender(domainId + "DomainCntCoreLog") != null) &#123; return; &#125; final PatternLayout layout = PatternLayout.newBuilder() .withCharset(Charset.forName("UTF-8")) .withConfiguration(config) .withPattern("%d %t %p %X&#123;TracingMsg&#125; %c - %m%n") .build(); final TriggeringPolicy policy = TimeBasedTriggeringPolicy.newBuilder() .withModulate(true) .withInterval(1) .build(); final Appender appender = RollingFileAppender.newBuilder() .withName(domainId + "DomainCntCoreLog") .withImmediateFlush(true) .withFileName("logs/" + domainId + "/CNTCore.log") .withFilePattern("logs/" + domainId + "/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz") .withLayout(layout) .withPolicy(policy) .build(); appender.start(); config.addAppender(appender); final KeyValuePair[] pairs = &#123;KeyValuePair.newBuilder().setKey("domainId").setValue(domainId).build()&#125;; final Filter filter = ThreadContextMapFilter.createFilter(pairs, null, Result.ACCEPT, Result.DENY); config.getLoggerConfig("com.lewis").addAppender(appender, Level.DEBUG, filter); ctx.updateLoggers(config);&#125;这段代码动态生成一个名为omainCntCoreLog的RollingFileAppender，该appender交由com.lewis这个logger来使用，并将日志信息输入到logs/{domainId}/CNTCore.log。该logger在使用omainCntCoreLog这个RollingFileAppender时还设置了一个过滤器ThreadContextMapFilter，这个Filter用来控制logger只能对指定了domainId的进行打印日志。ThreadContext是Log4j2用来存放线程信息的，相当于Log4j 1.X中的MDC和NDC，MDC是map，NDC是stack。当每个User登录时，就将该User的domainId存放到ThreadContext中，当退出登录时就将该domainId从ThreadContext中移除。假如有10个User登录了，一个User对应一个线程，每个线程都存放了User对应的domainId。在用户登录时，调用上边的方法来动态生成domain appender；假如有10个domainId，就会生成10个domain appender。由于这10个domain appender都被add到同一个logger里了，如果不通过ThreadContextMapFilter来控制，就会造成每个User的日志信息都会被输入到所有domain appender里去。在加载配置文件后拼接domain appender需要注意的是，必须在读取配置文件后才能去动态生成appender或者其他的日志对象，否则会被原本的配置文件覆盖掉。12345678910111213public static void main(final String[] args) &#123; ThreadContext.put("domainId", "RD2"); final String domainId = "RD2"; final LoggerContext context1 = (org.apache.logging.log4j.core.LoggerContext) LogManager.getContext(false); try &#123; context1.setConfigLocation(Loader.getResource("log4j2.xml", null).toURI()); createDomainAppender(domainId); &#125; catch (final Exception e) &#123; LogManager.getRootLogger().error("load log4j2 configuration error", e); ThreadContext.remove("domainId"); &#125;&#125;上边的代码简单地动态生成了RD2 domain的appender，需要注意的是，如果启用了Log4j2的动态加载配置文件功能，那么当配置文件被改动后并被重新加载时，会导致原本动态生成的domain appender无效。因为重新加载配置文件会生成新的LoggerContext对象，这时候可能会丢失一部分日志信息到对应的domain日志文件里。对于这个暂时没找到很好的解决方法，目前只能是在每个User登录时去创建domain appender对象，如果已存在就不创建。对ThreadContextMapFilter的补充上边通过代码动态生成了RollingFileAppender和ThreadContextMapFilter，下边记录下配置文件里的写法：12345678910&lt;RollingFile name="domainCntCoreLog" immediateFlush="true" fileName="logs/RD2/CNTCore.log" filePattern="logs/RD2/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz" append="true"&gt; &lt;ThreadContextMapFilter onMatch="ACCEPT" onMismatch="DENY"&gt; &lt;KeyValuePair key="domainId" value="RD2" /&gt; &lt;/ThreadContextMapFilter&gt; &lt;PatternLayout pattern="%d %t %p %X&#123;TracingMsg&#125; %c - %m%n" /&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1" /&gt; &lt;/Policies&gt;&lt;/RollingFile&gt;从上边的配置就可以看出来短板了，只能配置死某个domainId的RollingFileAppender以及ThreadContextMapFilter，假如有10个domainId，就要手动配置十个对应的appender和Filter，很是繁琐。就算通过占位符${ctx:domainId}的写法来避免写死，也只能生成某个domainId的appender：12345678910&lt;RollingFile name="domainCntCoreLog" immediateFlush="true" fileName="logs/$&#123;ctx:domainId&#125;/CNTCore.log" filePattern="logs/$&#123;ctx:domainId&#125;/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz" append="true"&gt; &lt;ThreadContextMapFilter onMatch="ACCEPT" onMismatch="DENY"&gt; &lt;KeyValuePair key="domainId" value="$&#123;ctx:domainId&#125;" /&gt; &lt;/ThreadContextMapFilter&gt; &lt;PatternLayout pattern="%d %t %p %X&#123;TracingMsg&#125; %c - %m%n" /&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1" /&gt; &lt;/Policies&gt;&lt;/RollingFile&gt;这种方法只能生成一个domain appender，此外如果启用了动态加载配置文件的功能，在扫描配置文件是否改动时，还会报错，原因是在RollingFileAppender的FileName和filePattern里使用了占位符。在另起线程扫描配置文件时，该占位符时取不到值的，于是就会报错。参考链接运行时添加log4j2的appenderlog4j2如何动态的创建logger和appenderlog4j2 不使用配置文件，动态生成logger对象log4j2的MDC应用配置]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Log4j2</tag>
        <tag>动态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j2 - Unable to invoke factory method in class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile]]></title>
    <url>%2Fposts%2Fd8320ac8.html</url>
    <content type="text"><![CDATA[问题与分析在使用Log4j2时，虽然可以正确读取配置文件并生成log文件，但偶然发现控制台打印了异常信息如下：123456789101112132018-12-31 17:28:14,282 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to invoke factory method in class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.findFactoryMethod(PluginBuilder.java:235) at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:135) at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:959) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:899) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:891) at org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:514) at org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:238) at org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:250) at org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:547) at org.apache.logging.log4j.core.LoggerContext.onChange(LoggerContext.java:670) at org.apache.logging.log4j.core.config.ConfiguratonFileWatcher$ReconfigurationRunnable.run(ConfiguratonFileWatcher.java:68) at java.lang.Thread.run(Thread.java:748)将控制台的所有信息都复制出来，仔细查找，又发现了相关的异常信息：1234567891011122018-12-31 17:28:14,241 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to create file logs/$&#123;ctx:domainId&#125;/CNTCore.log java.io.IOException: The filename, directory name, or volume label syntax is incorrect at java.io.WinNTFileSystem.canonicalize0(Native Method) at java.io.WinNTFileSystem.canonicalize(WinNTFileSystem.java:428) at java.io.File.getCanonicalPath(File.java:618) at ....2018-12-31 17:28:14,280 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Could not create plugin of type class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/$&#123;ctx:domainId&#125;/CNTCore.log] with data [...] java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/$&#123;ctx:domainId&#125;/CNTCore.log] with data [...] at org.apache.logging.log4j.core.appender.AbstractManager.getManager(AbstractManager.java:115) at org.apache.logging.log4j.core.appender.OutputStreamManager.getManager(OutputStreamManager.java:114) at org.apache.logging.log4j.core.appender.rolling.RollingFileManager.getFileManager(RollingFileManager.java:188) at ....看起来是因为配置文件里的RollingFile使用到了${ctx:domainId}导致了这个问题。百度了下，发现了log4j2的jira issue：Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile该问题和我遇到的一样，而在jira里有comment如下：1Question: Does system property logfile have a value?结合项目的配置文件log4j2.xml:123456789&lt;RollingFile name="logfile" immediateFlush="true" fileName="logs/$&#123;ctx:domainId&#125;/CNTCore.log" filePattern="logs/$&#123;ctx:domainId&#125;/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz" append="true"&gt; &lt;PatternLayout&gt; &lt;pattern&gt;%d %t %p %X&#123;TracingMsg&#125; %c - %m%n&lt;/pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1" /&gt; &lt;/Policies&gt;&lt;/RollingFile&gt;可以看出，这个异常是由于RollingFile使用到了${ctx:domainId}，而该变量值是null，导致无法创建对应的RollingFile文件到磁盘。但是这个domainId是通过ThreadContext把值put进去的，不可能是null，从最终的效果来看，这个变量其实也是拿到了值的，因为对应的日志文件以及存在于磁盘上了。既然如此，为什么还会出现这个异常呢？通过观察控制台可以发现，每过一段时间就会出现一次该异常。从异常中可以看到ConfiguratonFileWatcher，好像有些明白为什么了。ConfiguratonFileWatcher是用来扫描配置文件是否被改动过的，在配置文件中设置的扫描间隔是30s：123&lt;configuration monitorInterval="30"&gt; ....&lt;/configuration&gt;由于扫描文件时另外起一个线程去扫描的，而${ctx:domainId}的值是存放于ThreadContext中的，ThreadContext是线程安全的，同一个key对应的value在不同线程中是不一定相同的。而对于新启动的线程来说，并没有将domainId的值存放进去，于是新线程在扫描配置文件的RollingFile时，自然是无法获取到${ctx:domainId}的值，故而每隔一段时间就会报上边的异常。解决方法方案一既然问题是因为扫描配置文件是否改动造成的，那么只要将动态加载的功能关闭就行了，如下：123&lt;configuration monitorInterval="0"&gt; ....&lt;/configuration&gt;方案二如果希望不关闭动态加载配置文件的功能，可以将domainId的值存放到System.properties里：1System.setProperty("domainId", "xxx");然后通过${sys:xxx}的方式来获取该properties的值：123456789&lt;RollingFile name="logfile" immediateFlush="true" fileName="logs/$&#123;sys:domainId&#125;/CNTCore.log" filePattern="logs/$&#123;sys:domainId&#125;/CNTCore.log.%d&#123;yyyy-MM-dd-a&#125;.gz" append="true"&gt; &lt;PatternLayout&gt; &lt;pattern&gt;%d %t %p %X&#123;TracingMsg&#125; %c - %m%n&lt;/pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1" /&gt; &lt;/Policies&gt;&lt;/RollingFile&gt;在log4j2中关于这些变量取值有以下这些种类：|Prefix|Context||:–|:–||bundle|Resource bundle. The format is ${bundle:BundleName:BundleKey}. The bundle name follows package naming conventions, for example: ${bundle:com.domain.Messages:MyKey}.||ctx|Thread Context Map (MDC)||date|Inserts the current date and/or time using the specified format||env|System environment variables. The formats are ${env:ENV_NAME} and ${env:ENV_NAME:-default_value}.||jndi|A value set in the default JNDI Context.||jvmrunargs|A JVM input argument accessed through JMX, but not a main argument; see RuntimeMXBean.getInputArguments(). Not available on Android.||log4j| Log4j configuration properties. The expressions ${log4j:configLocation} and ${log4j:configParentLocation} respectively provide the absolute path to the log4j configuration file and its parent folder.||main|A value set with MapLookup.setMainArguments(String[])||map|A value from a MapMessage||sd|A value from a StructuredDataMessage. The key “id” will return the name of the StructuredDataId without the enterprise number. The key “type” will return the message type. Other keys will retrieve individual elements from the Map.||sys|System properties. The formats are ${sys:some.property} and ${sys:some.property:-default_value}.|参考链接Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFileProperty Substitution]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j2 - java.lang.NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor]]></title>
    <url>%2Fposts%2Fa5cad454.html</url>
    <content type="text"><![CDATA[问题项目使用了log4j2，由于使用了全局异步打印日志的方式，还需要引入disruptor的依赖，最后使用的log4j2和disruptor的版本依赖如下：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j2 AsyncLogger need disruptor--&gt;&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;在项目最开始的地方(第一次使用到log4j2的logger之前)，通过代码来启用全局异步打印日志：12// use asyncLogger for log4j2 frameworkSystem.setProperty("Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector");然而在启动项目后报错如下：1234java.lang.NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor.&lt;init&gt;(Lcom/lmax/disruptor/EventFactory;ILjava/util/concurrent/ThreadFactory;Lcom/lmax/disruptor/dsl/ProducerType;Lcom/lmax/disruptor/WaitStrategy;)V at org.apache.logging.log4j.core.async.AsyncLoggerDisruptor.start(AsyncLoggerDisruptor.java:97) at org.apache.logging.log4j.core.async.AsyncLoggerContext.start(AsyncLoggerContext.java:75) at .......解决方法该问题是因为Disruptor的版本较低导致，将版本改用较新版本的即可：12345&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级log4j到log4j2报错：cannot access org.apache.http.annotation.NotThreadSafe]]></title>
    <url>%2Fposts%2F55fa957a.html</url>
    <content type="text"><![CDATA[问题与分析今天把项目的log4j的依赖改成了log4j2的依赖后，发现使用Maven打包时报错如下：123[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project cbx-core: Compilation failure[ERROR] cannot access org.apache.http.annotation.NotThreadSafe[ERROR] class file for org.apache.http.annotation.NotThreadSafe not found意思很清楚，找不到类NotThreadSafe。当我把log4j2改回来log4j后重新打包就不再报错，很明显，和log4j2有关。纳闷的是，我先前独自写了个测试类是没问题的，怎么一到项目里使用就报错了呢？Eclipse里也没有报错，看了下pom的依赖层级，也没发现有什么jar包冲突。百度了下，发现了问题原因。该问题是因为httpclient和httpcore两个jar包版本不匹配造成的。由于项目里使用了ElasticSearch，需要httpclient等相关的依赖，其中有两个依赖如下：12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.5&lt;/version&gt;&lt;/dependency&gt;原本在使用log4j的时候，项目可以正常打包，但当改成log4j2的时候，需要使用到httpcore包中的某个注解，但由于在4.4.5版本的httpcore中舍弃了一些注解，于是就报错说找不到NotThreadSafe。根据Apache的jira issue：HDFS-12527来看，里边的comment提到了：1The problem is that the httpclient and httpcore versions are incompatible.根据comment来看，httpcore是httpclient的依赖，比较合适的版本应该是4.5.2的httpclient和4.4.4的httpcore。而从pom的依赖层次看，4.5.2的httpclient本身就是依赖了4.4.4版本的httpcore；但由于项目里偏偏引入更高版本的httpcore，平时固然没问题，但一旦导入某些jar包譬如log4j2，就会编译报错。解决方法将httpcore的版本改成4.4.4(低于4.4.5即可)，重新进行Maven打包操作，结果编译成功，顺利打包。参考链接Error:java: 无法访问org.apache.http.annotation.ThreadSafe 找不到org.apache.http.annotation.ThreadSafe的类文件javadoc: error - class file for org.apache.http.annotation.ThreadSafe not found]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>log4j2</tag>
        <tag>工作记录</tag>
        <tag>NotThreadSafe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j和log4j2怎么动态加载配置文件]]></title>
    <url>%2Fposts%2F2c65baa3.html</url>
    <content type="text"><![CDATA[应用场景与问题当项目在运行时，我们如果需要修改log4j 1.X或者log4j2的配置文件，一般来说我们是不能直接将项目停止运行再来修改文件重新部署的。于是就有这样一个问题：如何在不停止当前项目的运行的情况下，让系统能够自动地监控配置文件的修改状况，从而实现动态加载配置文件的功能？而log4j 1.X和log4j2的差别略大，各自应该怎么实现这个功能？log4j 1.X动态加载配置文件log4j 1.X提供了动态加载配置文件的方法：12DOMConfigurator.configureAndWatch()PropertyConfigurator.onfigureAndWatch()DOMConfigurator对应的是xml配置文件，PropertyConfigurator对应的是properties配置文件。这两个类都有configureAndWatch这个方法，该方法有个重载方法，如下：12configureAndWatch(String configFilename)configureAndWatch(String configFilename, long delay)configureAndWatch方法用来监控配置文件是否被改动，监控的时间间隔是delay参数来决定，如果不传入该参数则使用默认的时间间隔1分钟(60000L)。configureAndWatch(String configFilename)实际上还是调用的configureAndWatch(String configFilename, long delay)。log4j2动态加载配置文件和log4j 1.X比起来，log4j2的动态加载配置很简单就能实现，不需要另外在代码中调用api，方法如下：123&lt;configuration monitorInterval="30"&gt; ...&lt;/configuration&gt;在log4j2.xml配置文件中的configuration节点添加monitorInterval的值，单位是秒，如果配置的值大于0，则会按照时间间隔来自动扫描配置文件是否被修改，并在修改后重新加载最新的配置文件。如果不配置该值，默认为0，即不扫描配置文件是否被修改。Log4j 1.X动态加载配置文件的底层实现原理DOMConfigurator#configureAndWatch源码解析org.apache.log4j.xml.DOMConfigurator#configureAndWatch源码如下：12345static public void configureAndWatch(String configFilename, long delay) &#123; XMLWatchdog xdog = new XMLWatchdog(configFilename); xdog.setDelay(delay); xdog.start();&#125;这里new了一个XMLWatchdog对象，接着设置了delay参数，最后调用了start()方法。watchdog是看门狗、检查者的意思，XMLWatchdog继承了FileWatchdog这个类，在XMLWatchdog中仅仅重写了doOnChange方法：123public void doOnChange() &#123; new DOMConfigurator().doConfigure(filename, LogManager.getLoggerRepository());&#125;从方法名就可以看出来，如果XMLWatchdog监控到配置文件被改动了，就会调用这个doOnChange方法，用来重新加载配置文件。那么它又是怎么知道配置文件被改动过了呢？接着看其父类FileWatchdog的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public abstract class FileWatchdog extends Thread &#123; /** The default delay between every file modification check, set to 60 seconds. */ static final public long DEFAULT_DELAY = 60000; /** The name of the file to observe for changes. */ protected String filename; /** The delay to observe between every check. By default set &#123;@link #DEFAULT_DELAY&#125;. */ protected long delay = DEFAULT_DELAY; File file; long lastModif = 0; boolean warnedAlready = false; boolean interrupted = false; protected FileWatchdog(String filename) &#123; super("FileWatchdog"); this.filename = filename; file = new File(filename); setDaemon(true); checkAndConfigure(); &#125; /** Set the delay to observe between each check of the file changes. */ public void setDelay(long delay) &#123; this.delay = delay; &#125; abstract protected void doOnChange(); protected void checkAndConfigure() &#123; boolean fileExists; try &#123; fileExists = file.exists(); &#125; catch(SecurityException e) &#123; LogLog.warn("Was not allowed to read check file existance, file:["+ filename+"]."); interrupted = true; // there is no point in continuing return; &#125; if(fileExists) &#123; long l = file.lastModified(); // this can also throw a SecurityException if(l &gt; lastModif) &#123; // however, if we reached this point this lastModif = l; // is very unlikely. doOnChange(); warnedAlready = false; &#125; &#125; else &#123; if(!warnedAlready) &#123; LogLog.debug("["+filename+"] does not exist."); warnedAlready = true; &#125; &#125; &#125; public void run() &#123; while(!interrupted) &#123; try &#123; Thread.sleep(delay); &#125; catch(InterruptedException e) &#123; // no interruption expected &#125; checkAndConfigure(); &#125; &#125;&#125;可以看到，FileWatchdog继承了Thread类，类里定义了几个成员变量，比如默认的监控时间间隔等。而在该类的构造方法中可以看到，首先该线程类将名字设定成FileWatchdog，接着根据传入的配置文件的路径new了一个File对象，然后该线程类又设置成了守护线程(daemon thread)，最后调用了checkAndConfigure()。在checkAndConfigure()中，则是对new出来的配置文件File对象进行检查是否存在该文件，若不存在该文件则会设置成员变量的值，这样就不会去监控不存在的配置文件了。如果该配置文件存在，则通过lastModified()来获取文件的最后更新时间，和上次的更新时间作对比，如果比上次更新时间大则会调用doOnChange()来重新加载配置文件。而在FileWatchdog的run方法中，则是在无限循环中先让线程睡眠设置好的监控时间间隔，然后调用checkAndConfigure()。总结可以看出，在log4j 1.X的DOMConfigurator中，是通过创建一个守护线程来不停地扫描配置文件的最后更新时间，并和上次的更新时间进行对比，如果最后更新时间大于上次更新时间则会重新加载配置文件。PropertyConfigurator#configureAndWatch源码解析PropertyConfigurator的configureAndWatch()其实和DOMConfigurator差不多，区别是PropertyConfigurator在方法里new了一个PropertyWatchdog对象，PropertyWatchdog和XMLWatchdog一样继承了FileWatchdog，一样重写了doOnChange()方法。只是PropertyWatchdog是通过new PropertyConfigurator().doConfigure()来加载配置文件的。从源码实现来看，无论是使用xml配置文件，还是使用properties配置文件，其动态加载配置文件的底层实现是基本一样的。可以通过解析配置文件的文件后缀来判断是xml还是properties文件，然后调用对应的方法即可，大概的思路如下：1234567891011121314151617boolean flag = true;boolean isXml = StringUtils.equalsIgnoreCase("xml", StringUtils.substringAfterLast(filepath, "."));ling delay = 30000;if (isXml) &#123; if (flag) &#123; DOMConfigurator.configureAndWatch(filepath, delay); &#125; else &#123; DOMConfigurator.configure(filepath); &#125;&#125; else &#123; if (flag) &#123; PropertyConfigurator.configureAndWatch(filepath, delay); &#125; else &#123; PropertyConfigurator.configure(filepath); &#125;&#125;log4j2底层实现动态加载配置文件的简单解析虽然log4j2的动态加载配置很简单，但其底层实现比起log4j 1.X却要复杂很多，使用到了很多并发包下的类，具体也不是很了解，这里简单解释下流程。对于log4j2.xml文件，对应的是org.apache.logging.log4j.core.config.xml.XmlConfiguration这个类。如果在log4j2.xml里配置了monitorInterval，在构建XmlConfiguration时会根据该值来走一段特定的逻辑：12345678910111213141516171819202122232425262728293031323334for (final Map.Entry&lt;String, String&gt; entry : attrs.entrySet()) &#123; final String key = entry.getKey(); final String value = getStrSubstitutor().replace(entry.getValue()); if ("status".equalsIgnoreCase(key)) &#123; statusConfig.withStatus(value); &#125; else if ("dest".equalsIgnoreCase(key)) &#123; statusConfig.withDestination(value); &#125; else if ("shutdownHook".equalsIgnoreCase(key)) &#123; isShutdownHookEnabled = !"disable".equalsIgnoreCase(value); &#125; else if ("shutdownTimeout".equalsIgnoreCase(key)) &#123; shutdownTimeoutMillis = Long.parseLong(value); &#125; else if ("verbose".equalsIgnoreCase(key)) &#123; statusConfig.withVerbosity(value); &#125; else if ("packages".equalsIgnoreCase(key)) &#123; pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR))); &#125; else if ("name".equalsIgnoreCase(key)) &#123; setName(value); &#125; else if ("strict".equalsIgnoreCase(key)) &#123; strict = Boolean.parseBoolean(value); &#125; else if ("schema".equalsIgnoreCase(key)) &#123; schemaResource = value; &#125; else if ("monitorInterval".equalsIgnoreCase(key)) &#123; final int intervalSeconds = Integer.parseInt(value); if (intervalSeconds &gt; 0) &#123; getWatchManager().setIntervalSeconds(intervalSeconds); if (configFile != null) &#123; final FileWatcher watcher = new ConfiguratonFileWatcher(this, listeners); getWatchManager().watchFile(configFile, watcher); &#125; &#125; &#125; else if ("advertiser".equalsIgnoreCase(key)) &#123; createAdvertiser(value, configSource, buffer, "text/xml"); &#125;&#125;可以看到，如果monitorInterval的值大于0，则会拿到WatchManager并设置扫描配置文件的时间间隔，如果配置文件存在，则会new一个ConfiguratonFileWatcher对象，并将配置文件和该对象一起传递给WatchManager的watchFile方法。这两个方法的底层实现很绕，比起log4j 1.X要复杂得多，不容易看懂。不过最终实现的效果还是一样的，依然会开启一个守护线程来监控配置文件是否被改动。区别在于，log4j2使用线程池来启动线程，在WatchManager#start()里实现的：12345678@Overridepublic void start() &#123; super.start(); if (intervalSeconds &gt; 0) &#123; future = scheduler.scheduleWithFixedDelay(new WatchRunnable(), intervalSeconds, intervalSeconds, TimeUnit.SECONDS); &#125;&#125;而该方法则是在启动配置文件时被调用的，AbstractConfiguration#start()：12345678910111213141516/** * Start the configuration. */@Overridepublic void start() &#123; // Preserve the prior behavior of initializing during start if not initialized. if (getState().equals(State.INITIALIZING)) &#123; initialize(); &#125; LOGGER.debug("Starting configuration &#123;&#125;", this); this.setStarting(); if (watchManager.getIntervalSeconds() &gt; 0) &#123; watchManager.start(); &#125; ...&#125;这里只是简单解析了下主要的流程，具体的实现细节目前还看不太懂，有兴趣的可以自己去看看log4j2的源码。另外我在官方文档里看到说monitorInterval的最小值是5，但是在源码里也没看到这个，我觉得只要配置值大于0应该就是可以的。有不对之处，欢迎指出。这是官方原文：###Automatic ReconfigurationWhen configured from a File, Log4j has the ability to automatically detect changes to the configuration file and reconfigure itself. If the monitorInterval attribute is specified on the configuration element and is set to a non-zero value then the file will be checked the next time a log event is evaluated and/or logged and the monitorInterval has elapsed since the last check. The example below shows how to configure the attribute so that the configuration file will be checked for changes only after at least 30 seconds have elapsed. The minimum interval is 5 seconds.参考链接Log4j 2.0 的新特性Log4j – Configuring Log4j 2 - Apache Log4j 2]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>log4j</tag>
        <tag>log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j2中LevelRangeFilter的注意点]]></title>
    <url>%2Fposts%2Ff53d27da.html</url>
    <content type="text"><![CDATA[LevelRangeFilter的注意点在log4j2中，LevelRangeFilter的minLevel，maxLevel的配置是和log4j 1.x相反的；minLevel需要配置的是高级别，maxLevel配置的是低级别，如下：1&lt;LevelRangeFilter minLevel="fatal" maxLevel="info" onMatch="ACCEPT" onMismatch="DENY"/&gt;如上边的配置，是打印info到fatal级别的log，如果配置反过来，则不会输出任何log。如果不配置minLevel、maxLevel、onMatch和onMismatch的值，则会为其设置默认值，在LevelRangeFilter中的源码实现如下：1234567891011121314@PluginFactorypublic static LevelRangeFilter createFilter( // @formatter:off @PluginAttribute("minLevel") final Level minLevel, @PluginAttribute("maxLevel") final Level maxLevel, @PluginAttribute("onMatch") final Result match, @PluginAttribute("onMismatch") final Result mismatch) &#123; // @formatter:on final Level actualMinLevel = minLevel == null ? Level.ERROR : minLevel; final Level actualMaxLevel = maxLevel == null ? Level.ERROR : maxLevel; final Result onMatch = match == null ? Result.NEUTRAL : match; final Result onMismatch = mismatch == null ? Result.DENY : mismatch; return new LevelRangeFilter(actualMinLevel, actualMaxLevel, onMatch, onMismatch);&#125;至于为什么把最大最小level的值配置反了就会无法输出，是因为在LevelRangeFilter中的源码实现如下：123private Result filter(final Level level) &#123; return level.isInRange(this.minLevel, this.maxLevel) ? onMatch : onMismatch;&#125;可以看到，在调用filter方法进行过滤时，是调用了level#isInRange()来判断是否匹配该filter的。而在该方法中，实现如下：123public boolean isInRange(final Level minLevel, final Level maxLevel) &#123; return this.intLevel &gt;= minLevel.intLevel &amp;&amp; this.intLevel &lt;= maxLevel.intLevel;&#125;这里通过对比Level对象的intLevel值(int)来判断是否匹配，而这些Level对象也在Level这个类里进行里实例化：12345678910static &#123; OFF = new Level("OFF", StandardLevel.OFF.intLevel()); FATAL = new Level("FATAL", StandardLevel.FATAL.intLevel()); ERROR = new Level("ERROR", StandardLevel.ERROR.intLevel()); WARN = new Level("WARN", StandardLevel.WARN.intLevel()); INFO = new Level("INFO", StandardLevel.INFO.intLevel()); DEBUG = new Level("DEBUG", StandardLevel.DEBUG.intLevel()); TRACE = new Level("TRACE", StandardLevel.TRACE.intLevel()); ALL = new Level("ALL", StandardLevel.ALL.intLevel());&#125;可以看到，这些Level对象的intLevel值是由另一个枚举类StandardLevel来提供的：123456789101112131415161718192021222324252627282930313233343536373839/*** No events will be logged.*/OFF(0),/*** A severe error that will prevent the application from continuing.*/FATAL(100),/*** An error in the application, possibly recoverable.*/ERROR(200),/*** An event that might possible lead to an error.*/WARN(300),/*** An event for informational purposes.*/INFO(400),/*** A general debugging event.*/DEBUG(500),/*** A fine-grained debug message, typically capturing the flow through the application.*/TRACE(600),/*** All events should be logged.*/ALL(Integer.MAX_VALUE);可以看到，Level级别越高，其对应的intLevel值越小，可以这样理解：级别越高，能打印出来的日志信息就越少，所以其intLevel值就越小。如果我们把LevelRangeFilter的minLevel、maxLevel配置反了，会导致level#isInRange()返回false，最终也就没有任何日志得以输出了。]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>log4j2</tag>
        <tag>LevelRangeFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不占用任何额外空间的情况下交换两个数的值]]></title>
    <url>%2Fposts%2F9136af.html</url>
    <content type="text"><![CDATA[题目假如有x、y两个数，如何在不占用任何额外空间的情况下交换两个数的值？思路平时我们在交换两个数的值时，往往会用一个中间数temp来实现效果，现在需要不占用任何额外空间，自然就不能使用这种寻常的方法了；这里可以有两种方法来实现。方法一12345int x = 5;int y = 10;x = x + y;y = x - y;x = x - y;先将两个数之和附给x，接着x-y自然就是原本x的值，这时候赋值给y，y就拿到了x原本的值。此时x依然是两个数之和，再进行x-y自然就是原本x的值。这种方法比较直观，也好理解，但是可能存在溢出的情况。方法二12345int x = 5;int y = 10;x = x ^ y;y = x ^ y;x = x ^ y;第二种方法利用了异或运算的性质：相同的两个数异或结果为0任何数与0异或结果还是其自身异或运算满足交换律和结合律于是将x^y的结果赋予x，接着再将x与y异或，此时y的值就是x^y^y = x^(y^y) = x，也就是说y拿到了x原本的值。此时x依然是两数异或的结果，而y是x原本的值，接着进行x^y就等同于x^y^x = y， 于是x就拿到了y原本的值。这种方法很巧妙，也不太好理解，但是不存在溢出的情况。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j.xml中Filter的用法]]></title>
    <url>%2Fposts%2Fec168d9b.html</url>
    <content type="text"><![CDATA[前言log4j中常用的Filter分为四种：DenyAllFilter、LevelMatchFilter、LevelRangeFilter、StringMatchFilter。当appender匹配了某个Filter的时候，就不会继续匹配下一个filter，所以当需要配置多个filter时需要注意先后顺序，这样才能实现需要的效果。这些filter有个共同的属性AcceptOnMatch，用来控制匹配到的appender是否打印日志。只打印指定level的日志假如现在只希望打印INFO和ERROR级别的日志，可以这样配置：123456789101112&lt;appender name="cntCorelog" class="org.apache.log4j.rolling.RollingFileAppender"&gt; ...... &lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="INFO" /&gt; &lt;param name="AcceptOnMatch" value="true"/&gt; &lt;/filter&gt; &lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="true"/&gt; &lt;/filter&gt; &lt;filter class="org.apache.log4j.varia.DenyAllFilter" /&gt;&lt;/appender&gt;这里如果不配置最后一个filter，则会放行所有日志输出。不打印指定level的日志假如不希望打印DEBUG级别的日志，可以这样配置：1234&lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="false" /&gt;&lt;/filter&gt;AcceptOnMatch表示是否输出日志，这里需要注意的是，一旦匹配了某个filter，就无法再匹配后续的filter了，如下：12345678&lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="false" /&gt;&lt;/filter&gt;&lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="true" /&gt;&lt;/filter&gt;对于上面的配置，ERROR级别的日志匹配了第一个filter后，结果是被过滤掉不被输出，于是第二个filter就不生效了。如果将上边的配置颠倒过来，如下：12345678&lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="true" /&gt;&lt;/filter&gt;&lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR" /&gt; &lt;param name="AcceptOnMatch" value="false" /&gt;&lt;/filter&gt;这时候ERROR级别的日志就依然能正常被打印出来。只打印从level A到B之间的所有日志假如现在只想要打印INFO到ERROR级别之间的日志，可以这样配置：12345&lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt; &lt;param name="LevelMin" value="INFO"/&gt; &lt;param name="LevelMax" value="ERROR"/&gt; &lt;param name="AcceptOnMatch" value="true" /&gt;&lt;/filter&gt;需要注意的是，对于LevelRangeFilter，会匹配所有的appender，如果将该filter置于其他filter的前面，则会导致后续的filter无效。只打印包含某些字符串的日志假如只希望打印某些字符串的日志，可以这样配置：1234&lt;filter class="org.apache.log4j.varia.StringMatchFilter"&gt; &lt;param name="StringToMatch" value="test" /&gt; &lt;param name="AcceptOnMatch" value="true" /&gt;&lt;/filter&gt;如上配置，如果日志里包含了test这个字符串就会被输出到日志了，如果是包含某些字符串就不打印出来，直接将AcceptOnMatch设成false就行。如果不配置StringToMatch的value，该filter无效；如果将其value配置为&quot;&quot;空字符串，该filter则会匹配所有日志。在StringMatchFilter的源码实现里，是通过indexOf()来判断是否包含指定字符串的。]]></content>
      <categories>
        <category>Java</category>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>log4j</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - CNAME文件在每次部署后就没了]]></title>
    <url>%2Fposts%2F39e3ca60.html</url>
    <content type="text"><![CDATA[问题一般我们会将Hexo博客搭建到Github上，如果在Github上为其配置一个自定义的域名时，会自动在项目仓库根目录下新添加一个CNAME文件。但是这里有个问题，如果将Hexo博客重新部署一遍后，Github仓库里的这个CNAME文件就会消失掉，又需要重新配置一遍。解决方法其实这里有个技巧，我们可以将需要上传部署到Github的文件都放在source文件夹里，例如CNAME文件、favicon.ico、或者其他的图片等等，这样在执行hexo d这个命令之后，这些文件就不会被删除了。Hexo在执行命令时是不会删除掉source目录下的文件的，我们可以在该目录下随意增加其他文件或者文件夹，建议在该目录下添加子文件夹，然后在子文件夹里添加文件，这样便于文件分档归类。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>CNAME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面的背景音乐加载很慢]]></title>
    <url>%2Fposts%2Feee6409f.html</url>
    <content type="text"><![CDATA[问题由于我在页面中使用了&lt;audio&gt;标签来播放一首背景音乐，该音频是一首大小为2.7MB的MP3文件。在第一次加载该页面时，需要花费相当长的一段时间去加载音频。解决方法百度了下才知道，原来超过2MB的背景音乐其实是一个很巨大的文件了，如果网速稍微慢一些用户体验就会很差了。大概有几种解决的办法：把音乐加到FLASH里使用rm或wma格式的背景音乐降低MP3文件的音质第一个就不说了，FLASH已经声名狼藉，注定凉凉了。第二个出于不同浏览器的兼容性以及&lt;audio&gt;标签的兼容性，还是决定使用MP3文件。最后就只能使用第三种方法了，通过MP3压缩软件，最后将该MP3音频压缩到了400KB左右，总算是马马虎虎实现了想要的效果。参考链接网页中背景音乐加在太慢]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 怎么将时间转换成秒]]></title>
    <url>%2Fposts%2F8470760a.html</url>
    <content type="text"><![CDATA[保留原来的毫秒值1select extract(epoch from '03:21:06.678'::time);这个extract(epoch from )函数得到的是时间是秒单位，如果需要毫秒值就直接乘以1000：1select extract(epoch from now())*1000;去掉原来的毫秒值向下取整函数floor()1select floor(extract(epoch from '03:21:06.678'::time));向上取整函数ceil()或ceiling()，这两个一样的12select ceil(extract(epoch from '03:21:06.678'::time));select ceiling(extract(epoch from '03:21:06.678'::time));四舍五入函数round()1select round(extract(epoch from '03:21:06.678'::time));将两个日期间的时间转换为秒值1234select extract(epoch from(('2018-12-18 00:00:10'::timestamp - '2018-12-18 00:00:00')));select extract(epoch from(('2018-12-18 00:00:10' - '2018-12-18 00:00:00'::timestamp)));select extract(epoch from(('2018-12-18 00:00:10' - timestamp'2018-12-18 00:00:00')));select extract(epoch from((timestamp'2018-12-18 00:00:10' - '2018-12-18 00:00:00')));上边四种写法都可以。epoch新纪元时间新纪元时间 Epoch 是以1970-01-01 00:00:00 UTC为标准的时间，将目标时间与1970-01-01 00:00:00时间的差值以秒来计算 ，单位是秒，可以是负值; 有些应用会将时间存储成epoch 时间形式，以提高读取效率。参考链接postgresql获取系统当前时间毫秒数的sql，以及秒级时间戳PostgreSQL: epoch 新纪元时间的使用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 怎么转换数据类型]]></title>
    <url>%2Fposts%2Ff20deee6.html</url>
    <content type="text"><![CDATA[前言对于select 233;这个sql，得到的结果是int4类型，如果我们希望将结果转换成其他的数据类型，有以下方法(下边的{数据类型}表示占位符，要替换成数据库中的某一种数据类型)：方法一：使用::{数据类型}1select 233::text;上边的sql通过::text将结果转换成了text类型。方法二：使用{数据类型}&#39;&#39;12select text '233';select text'233';上边的sql通过text&#39;&#39;将结果转换成了text类型。这里的两种写法是一样的，加不加空格没有影响。另外提一句，对于select N&#39;233&#39;;这个句子中的N&#39;&#39;，会将结果转换成bpchar类型。方法三：使用cast()函数这个函数不是PostgreSQL独有的，其他数据库也有类似的用法，在PostgreSQL中用法如下：1select cast(233 as numeric);cast其实就是转型的意思，该sql将233转换成numeric类型并输出到结果集。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 用psql 运行SQL文件]]></title>
    <url>%2Fposts%2F108d47a0.html</url>
    <content type="text"><![CDATA[对于预先写好的SQL文件，比如/home/user1/updateMyData.sql， 可以有两种方式来运行这个SQL文件。方式一：连接db后执行SQL文件首先通过psql连接到对应的db：1psql -d db1 -U userA接着输入密码，进入数据库后，输入：1\i /pathA/xxx.sql这里有个问题，如果你把SQL文件的路径里的路径分隔符写成了\，会报错说Permission denied。这里的文件路径必须使用Linux平台下的路径分隔符/，否则会报错。方式二：直接通过psql命令执行SQL文件这种方式无需先登录数据库，直接用一个命令就可以了：1psql -d db1 -U userA -f /pathA/xxx.sql接着输入密码即可执行SQL文件到对应的db里。参考链接psql执行文件时出现Permission denied]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JIRA中的标记语言的语法参考]]></title>
    <url>%2Fposts%2F3c228edd.html</url>
    <content type="text"><![CDATA[前言看到网上有的文章说JIRA是使用Textile这门标记语言，有些语法和Wikitext和Markdown相像。JIRA在2017年进行了一次大更新，某些语法可能和以前不大一样，这里纪录一下常用的一些语法。标题h1.一级标题h2.二级标题h3.三级标题h4.四级标题h5.五级标题用法示例：1h1.ddd一共有h1到h5这五种大小的标题，但是h6也是有效果的，不过h6起到的作用是将小写字母变成大写字母，示例如下：1h6.ddd以上会得到DDD的输出。字体用法效果*黑体*黑体_斜体_黑体-删除线-删除线+下划线+下划线~下标~下标^上标^上标注意在使用上边这些字体效果的时候，~等字符需要和其他文本相隔一个空格，否则没有效果，如下：1H ~2~ O换行123第一行\\第二行通过\\来进行换行。引用1bq. 这是引用，可以使用字体效果并进行换行。通过bq.来引用一段文字或图片等，可以在引用段里使用字体效果并进行换行。不过这个bq.用来比较麻烦，用另一种引用的语法{quote}更好，而且还可以使用其他更多的效果，如下：1234567&#123;quote&#125;Perhaps the simplest way to convert to using Log4j 2 is to replace the log4j 1.x jar file with Log4j 2&apos;s log4j-1.2-api.jar. However, to use this successfully applications must meet the following requirements: # They must not access methods and classes internal to the Log4j 1.x implementation such as Appenders, LoggerRepository or Category&apos;s callAppenders method. # They must not programmatically configure Log4j. # They must not configure by calling the classes DOMConfigurator or PropertyConfigurator.&#123;quote&#125;附件附件有两种方式：123[^xxxx.mp4]或者!xxxx.mp4![^xxxx.mp4]这种形式类似于超链，!xxxx.mp4!这种形式则可以将图片显示出来，或者将视频播放出来。如果附件是图片，还可以使用以下写法：12345显示图片的缩略图!xxxx.jpg|thumbnail!指定图片的大小!xxxx.jpg|width=300,height=400!如果附件是视频 ，还可以使用以下写法：12指定视频播放器的大小!xxxx.mp4|width=300,height=400!列表第一种无序列表，会在每行最前边显示一个圆点1234* 1* 2** 2.1* 3第二种无序列表，会在每行最前边显示一个方块1234- 1- 2-- 2.1- 3有序列表1234# 1# 2## 2.1# 3有序列表和无序列表可以混合使用，如下：1234# 1# 2#* 2.1# 3表格123456789表头加粗写法：||heading 1||heading 2||heading 3|||col A1|col A2|col A3||col B1|col B2|col B3|表头不加粗写法：|heading 1|heading 2|heading 3|||col A1|col A2|col A3||col B1|col B2|col B3|超链12345直接贴上一个超链：[https://lewky.cn]给超链起一个别名：[233|https://lewky.cn]此外，可以直接输入JIRA的issue id，会自动转换成特定的超链。转义字符有些特殊字符在JIRA中具有特殊效果，如果需要输入这些字符，需要进行转义。JIRA使用的转义字符是\，用法如下：1\&#123;表情符号JIRA支持通过输入一些特定的组合字符来显示成对应的表情符号，比如：123:) :( :P :D ;) (y) (n) (i) (/) (x) (!)(+) (-) (?) (on) (off) (*) (*r) (*g) (*b) (*y) (flag)(flagoff)高级文本格式可以通过{panel}来显示一个模板块，如下：123&#123;panel&#125;Some text&#123;panel&#125;可以给这个panel起标题：123&#123;panel:title=My Title&#125;Some text with a title&#123;panel&#125;还可以给这个panel设置css属性：1234&#123;panel:title=My Title|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE&#125;a block of text surrounded with a *panel*yet _another_ line&#123;panel&#125;代码块代码块通过{code}来使用：12345&#123;code:xml&#125;&lt;test&gt;&lt;another tag=&quot;attribute&quot;/&gt;&lt;/test&gt;&#123;code&#125;建议给代码块设置对应的语言，譬如上边的xml，这样写的好处是代码块可以自动使用对应语言的代码高亮，并且当代码过长时会自动生成滚动条，不至于让代码块占据页面的一大块地方。同样可以给代码块设置标题和css属性：1234567&#123;code:title=Bar.java|borderStyle=solid&#125;// Some comments herepublic String getFoo()&#123;return foo;&#125;&#123;code&#125;参考链接JIRA issue 中的标记语言（Textile）Text Formatting Notation Help]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown - 如何给文本加下划线]]></title>
    <url>%2Fposts%2F80fa1555.html</url>
    <content type="text"><![CDATA[解决方法Markdown可以和HTML的语法兼容，可以通过HTML的标签来实现效果：写法效果&lt;u&gt;下划线&lt;/u&gt;下划线这里解释下，u指的是underline下划线。附注尽量不要给文本加下划线，因为这会和超链的表现形式混淆，会被误以为是个超链。参考链接HTML 标签]]></content>
      <categories>
        <category>前端</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux - 查看并修改当前的系统时间]]></title>
    <url>%2Fposts%2Fbbc6dab6.html</url>
    <content type="text"><![CDATA[转载自Linux系统查看当前时间的命令查看和修改Linux的时区查看当前时区命令 ： date -R修改设置Linux服务器时区方法 A命令 ： tzselect方法 B 仅限于RedHat Linux 和 CentOS命令 ： timeconfig方法 C 适用于Debian命令 ： dpkg-reconfigure tzdata复制相应的时区文件，替换系统时区文件；或者创建链接文件cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime例如：在设置中国时区使用亚洲/上海(+8)cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime查看和修改Linux的时间查看时间和日期命令 ： date设置时间和日期例如：将系统日期设定成2009年11月3日的命令命令 ： date -s 11/03/2009将系统时间设定成下午5点55分55秒的命令命令 ：date -s 17:55:55将当前时间和日期写入BIOS，避免重启后失效命令 ：hwclock -w附注date不加参数可以直接看到当前日期时间cal不加参数可以直接看到本月月历]]></content>
      <categories>
        <category>计算机</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown - 如何使用上标、下标]]></title>
    <url>%2Fposts%2Fff65a37e.html</url>
    <content type="text"><![CDATA[解决方法Markdown可以和HTML的语法兼容，可以通过HTML的上标和下标标签来实现效果：标签写法效果上标2&lt;sup&gt;10&lt;/sup&gt;210下标H&lt;sub&gt;2&lt;/sub&gt;OH2O这里解释下，sup指的是superscript上标，sub指的是subscript下标。参考链接在markdown中如何加入上标、下标？]]></content>
      <categories>
        <category>前端</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Tomcat自带的日志实现tomcat-juli.jar]]></title>
    <url>%2Fposts%2F7e9025c2.html</url>
    <content type="text"><![CDATA[前言Tomcat自带的日志实现是tomcat-juli.jar，它是对默认的JDK日志java.util.logging进行一定的封装，和标准JDK日志支持相同的配置，但是和log4j等常用的日志框架比起来功能要较为简陋。但是tomcat-juli可以针对不同的classloader来使用不同的配置文件，使得tomcat下不同的Web应用程序可以使用各自独立的日志文件。如果我们想在代码中使用Tomcat自带的日志实现，也很简单，首先拿到tomcat-juli.jar。该jar包存在于Tomcat安装目录下的lib下，或者你可以直接在Maven仓库里选择你想要的版本去下载。接着新建一个java项目，导入该jar包，然后在根目录下新建一个配置文件logging.properties。配置文件logging.propertiestomcat-juli使用的配置文件是logging.properties，一个简单的配置如下：123456handlers= java.util.logging.ConsoleHandler.level= INFOjava.util.logging.ConsoleHandler.level = INFOjava.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormattercom.lewis.test.TestLewis.level = SEVERE这里简单解释下，第一行表示使用ConsoleHandler来处理打印日志，用来将信息打印到控制台。第二行表示输出的日志级别是INFO，可以在level前加上任意类名或者完整的包名，用于精准控制类/包的日志级别，譬如第三行。第四行表示输出的日志信息日期格式。更多具体的配置可以去看看Tomcat的conf目录下的logging.properties，里边有很多配置和注释。另外提一下，tomcat-juli的日志级别和log4j等是不一样的，其级别如下：1SEVERE (highest value) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (lowest value)测试类测试类的代码如下：12345678910111213141516171819202122232425262728293031package com.lewis.test;import java.io.NotSerializableException;import java.util.logging.Level;import java.util.logging.Logger;public class TestLewis &#123;private static Logger LOGGER;static &#123;System.setProperty("java.util.logging.config.file","D:\\lewis\\workspace\\test\\src\\main\\resources\\logging.properties");//must initialize loggers after setting above propertyLOGGER = Logger.getLogger(TestLewis.class.getName());&#125;public static void main(final String[] args) &#123;System.out.println("----System.out----");System.err.println("----System.err----");LOGGER.info("an info msg");LOGGER.warning("a warning msg");LOGGER.severe("a severe msg");LOGGER.log(Level.INFO, "test1: a info msg", new NotSerializableException());LOGGER.log(Level.WARNING, "test1: a warning msg", new NotSerializableException());LOGGER.log(Level.SEVERE, "test1: a severe msg", new NotSerializableException());&#125;这里需要注意的是，tomcat-juli的打印语句也是不太一样的，如果需要打印出具体的堆栈信息就必须自己指定日志级别，如果使用自带的日志级别打印语句诸如.info()等，只能打印出字符串，不能打印出堆栈信息。还有就是必须在代码的一开始就指定加载配置文件，通过System.setProperty(&quot;java.util.logging.config.file&quot;, &quot;配置文件的路径&quot;);。如果没有这一步，你会发现你的配置文件根本没有效果。如果你去Tomcat的bin目录下的catalina.bat可以发现，里边也是配置了这个参数：1set LOGGING_CONFIG=-Djava.util.logging.config.file="%CATALINA_BASE%\conf\logging.properties"输出结果控制台输出如下：12345678----System.out--------System.err----Dec 07, 2018 5:56:04 PM com.lewis.test.TestLewis mainSEVERE: a severe msgDec 07, 2018 5:56:05 PM com.lewis.test.TestLewis mainSEVERE: test1: a severe msgjava.io.NotSerializableException at com.lewis.test.TestLewis.main(TestLewis.java:75)参考链接Java Util Logging - Loading logging.propertiesTomcat日志系统详解]]></content>
      <categories>
        <category>中间件</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>中间件</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat - 怎么控制某个类或者包下的日志打印级别]]></title>
    <url>%2Fposts%2Fe6575e68.html</url>
    <content type="text"><![CDATA[问题与分析Tomcat是使用自己的日志实现tomcat-juli.jar来打印日志信息的，日志会被打印到catalina.out里，除去你在项目里自己使用的日志框架外，由System.out，System.err或者printStackTrace()打印出来的信息则是会被输入到catalina.out里，如果引用的jar包里也有这些语句也会一起输入到catalina.out里。比如现在catalina.out里有大量的NotSerializableException，这个exception是由第三方jar包打印出来的，log日志如下：1230-Oct-2018 17:53:58.368 WARNING [msm-storage-thread-1] de.javakaffee.web.msm.JavaSerializationTranscoder.writeAttributes Cannot serialize session attribute [javax.zkoss.zk.ui.Session] for session [EB56FE915F0611E8195FF5F95C96A9E2.app2]java.io.NotSerializableException: org.zkoss.bind.tracker.impl.BindUiLifeCycle可以看到，这个异常是由Memcached在共享session时由于存在对象没有序列化而打印出来的。现在我们不希望在catalina.out里看到这个异常，可以通过配置logging.properties来隐藏掉。解决方法在Tomcat的安装目录下，找到conf\logging.properties文件，找到如下注释(一般在最末尾)：123# For example, set the org.apache.catalina.util.LifecycleBase logger to log# each component that extends LifecycleBase changing state:#org.apache.catalina.util.LifecycleBase.level = FINE在这里的末尾加上一行：1de.javakaffee.web.msm.JavaSerializationTranscoder.level = SEVERE因为这个未序列化异常是在这个类中被打印出来的，而且log级别是warning；对于Tomcat来说，日志级别如下所示：1SEVERE (highest value) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (lowest value)我们需要将level设置成SEVERE，才可以不让其打印NotSerializableException出来。你甚至可以将范围进行扩大，变成如下配置：1de.javakaffee.web.msm.level = SEVERE指定de.javakaffee.web.msm包下的类只打印SEVERE级别的日志信息。补充如果希望不打印日志信息，可以将level设置为OFF。如果希望打印全部的日志信息，可以将level设置为ALL。参考链接Tomcat日志设定tomcat 日志级别]]></content>
      <categories>
        <category>中间件</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>中间件</tag>
        <tag>Tomcat</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iReport - 无法正常启动的解决方法]]></title>
    <url>%2Fposts%2F1d2503d5.html</url>
    <content type="text"><![CDATA[问题与分析最近需要用到iReport报表工具，但是在启动客户端时却发现只出现了启动界面，很快就界面消失没反应了。反复打开了好几次客户端，都无法正常打开。问了下同事，说是因为jdk升级的原因，以前项目使用的是jdk1.7就可以正常使用，后来升级到1.8就无法打开iReport客户端了。百度了下，确实如此。目前官网最新的版本是5.6.0，据说有外国大神说是下个版本将会支持jdk 1.8。不过现在我就需要使用到iReport，也不可能等到下个版本出来再使用，项目已经使用了jdk 1.8，也不可能将版本降下来。一番百度后，解决办法就是单独为iReport指定低于1.8版本的jdk，这样就可以正常启动了。解决方法找到iReport的安装目录，然后将etc/ireport.conf打开，可以看到有一行被注释的配置如下：1#jdkhome=&quot;path/to/jdk&quot;在这行注释下边加上一句：1jdkhome=&quot;C:\Program Files\Java\jdk1.7.0_25&quot;具体路径以本地安装的jdk目录为准，保存修改后重新启动iReport客户端即可。另外补充一句，这个etc目录其实作用和Linux下的etc目录差不多，就是专门用来存放程序所需的整个文件系统的配置文件。etc不是什么缩写，是and so on的意思，来源于法语的et cetera，翻译成中文就是等等的意思。参考链接关于iReport5.6.0无法正常启动或者闪退或者JDK8不兼容的解决方案linux下的etc是什么意思]]></content>
      <categories>
        <category>其他</category>
        <category>报表工具</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>iReport</tag>
        <tag>报表工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis逆向工程中domainObjectRenamingRule报错或无效]]></title>
    <url>%2Fposts%2F3f71ea8b.html</url>
    <content type="text"><![CDATA[使用domainObjectRenamingRule报错在使用MyBatis逆向工程时报错如下：123456org.mybatis.generator.exception.XMLParserException: XML Parser Error on line 43: 必须声明元素类型 &quot;domainObjectRenamingRule&quot;。 at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:121) at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:82) at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:74) at GeneratorSqlmap.generator(GeneratorSqlmap.java:22) at GeneratorSqlmap.main(GeneratorSqlmap.java:32)domainObjectRenamingRule该功能项是在MBG 1.3.6中新增加的功能，用于定义实体的重命名规则，常见的用途是取消表前缀。类似于columnRenamingRule，前者是重命名生成的模型对象的名称，后者是重命名表字段的名称。如果在低于该版本的MBG中使用该功能，会出现如下错误XML Parser Error on line 59: 必须声明元素类型 “domainObjectRenamingRule”。使用domainObjectRenamingRule无效配置好了domainObjectRenamingRule后，运行逆向工程却无效果，原因是searchString的值配置不对。根据表名来生成的类名是按照驼峰命名法，生成的类名首字母是大写的。而searchString是区分大小写的，并且它的值是Java里的正则表达式。举个例子，现在有个表叫tb_vq，我希望生成的类名是Vq，而不是TbVq，可以通过domainObjectRenamingRule来实现这个功能，配置如下：12345&lt;table tableName="tb_vq" schema="" enableCountByExample="false"enableDeleteByExample="false" enableUpdateByExample="false"enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;domainObjectRenamingRule searchString="^Tb" replaceString="" /&gt;&lt;/table&gt;需要注意的是，这里的searchString必须填^Tb，这是个Java正则表达式，这里不能写成^tb，必须首字母大写，否则匹配不上，另外为了避免匹配出错，这里使用了^Tb而不是Tb。参考链接mybatis.generator 1.3.6中添加的domainObjectRenamingRule说明]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven聚合工程怎么变回普通的Maven工程]]></title>
    <url>%2Fposts%2F29066504.html</url>
    <content type="text"><![CDATA[问题Maven聚合工程的父工程的packaging是pom，如果我们将其改为jar，会立刻报错：1Project build error: &apos;packaging&apos; with value &apos;jar&apos; is invalid. Aggregator projects require &apos;pom&apos; as packaging.对于聚合工程来说，所有的子工程会被放置到父工程的目录下，然后在父工程的pom文件里会有如下的节点：123&lt;modules&gt; &lt;module&gt;test-child&lt;/module&gt;&lt;/modules&gt;这些modules节点正是引用了父工程pom文件的子工程。解决方法将父工程的modules节点全部去掉，注释掉也行，再将packaging的值从pom改成jar或者war，接着保存，修改成功。虽然修改成功了，但是去父工程的目录下 ，你会发现那些子工程依然存在着。不过这些工程已经很父工程没有关系了，因为父工程已经不再是聚合工程了，可以将这些子工程移除掉。]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反编译工具JD-GUI以及Eclipse的反编译插件]]></title>
    <url>%2Fposts%2Fadd9b646.html</url>
    <content type="text"><![CDATA[什么是反编译高级语言源程序经过编译变成可执行文件，反编译就是逆过程。但是通常不能把可执行文件变成高级语言源代码，只能转换成汇编程序。反编译是一个复杂的过程,所以越是高级语言,就越难于反编译,但目前还是有许许多多的反编译软件:通过对他人软件的目标程序（可执行程序）进行“逆向分析、研究”工作，以推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素，作为自己开发软件时的参考，或者直接用于自己的软件产品中。所以现在大家写的东西就想办法保护，不被侵权！总之，有时候我们想要阅读代码，但是只有jar包却没有源码，就需要用到反编译工具了。Java反编译工具JD-GUIGithub上的官方下载地址：https://github.com/java-decompiler/jd-gui/releases有多种平台的安装版本，可以自己选择下载安装，也可以直接下载JAR包，然后用java -jar进行运行，如下：1java -jar jd-gui-1.4.0.jar安装Eclipse的反编译插件jd-eclipsejd-gui在Eclipse上也有对应的反编译插件jd-eclipse，安装方式如下：打开Eclipse -&gt; Help -&gt; Install New Software… -&gt; Add…在弹出的窗口中输入Name和Location，Name可以随意取，Location要填写反编译插件的下载地址：http://jd.benow.ca/jd-eclipse/update填写完毕后会加载该插件的相关信息，勾选该插件，一路Next安装下去即可。重启Eclipse该插件即可生效。不过安装插件后Eclipse可能继续使用着默认的class查看器，我们可以把它改成我们新安装的jd查看器：Window -&gt; Preference -&gt; General -&gt; Editors -&gt; File Associations选中*.class文件 -&gt; 将Class File Editor设置为默认(Default)最后确定修改，无需重启Eclipse即可生效。Enhanced Class Decompiler 3.0.0上边的反编译插件jd-eclipse可能在安装并修改了class查看器后依然无效，可能是由于Eclipse版本不兼容或者其他的原因，这时候可以安装另一个反编译插件，安装步骤如下：打开Eclipse -&gt; Help -&gt; Eclipse Marketplace…在弹窗的搜索框中输入Decompiler，选择安装Enhanced Class Decompiler 3.0.0安装工程中有Next选Next，中间需要选择接受安装协议，最后点击Finish安装结束后重启Eclipse生效参考链接反编译是什么意思Java反编译工具-JD-GUIjd-eclipse反编译插件的在线安装和使用关于Eclipse安装了反编译插件,无法查看源码问题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - update语句怎么关联多个表]]></title>
    <url>%2Fposts%2F8423a9d4.html</url>
    <content type="text"><![CDATA[问题对于select语句，我们可以通过join/outer join来关联多个表；但是对于update语句，是不能直接通过join/outer join来关联多表数据的，这里仅针对PostgreSQL。或者说，在PostgreSQL中，就算使用update+join不会报错，但join的那部分其实是没任何效果的，如下所示：12345678update aset value = 'test'from ajoin b on a.b_id = b.idjoin c on b.c_id = c.idwherea.key = 'test'and c.value = 'test';按照上边的sql，本意是a、b、c三表关联，当c的value是’test’且a的key也是’test’的时候，就将a的value也改为’test’。但实际上这个sql有大问题，这里的join和where条件并没有意义，一旦update成功，你会发现，a表内的所有数据的value都被改成了’test’！！要么update 0条数据，要么全部update！至于是哪种结果，这要看where的条件，目前还不清楚为什么会这样。因为这种写法本身就是不对的！PostgreSQL中正确的多表关联update写法在update语句中不应该通过join来进行多表关联，而是要通过from来多表关联，如下：12345678update aset value = 'test'from b,cwherea.b_id = b.idand b.c_id = c.idand a.key = 'test'and c.value = 'test';通过from来多表关联，而关联条件则是放到了where中，这样就可以达到我们想要的效果了。另外补充一句，对于set xxx = &#39;xxx&#39;这个update的部分，是不可以在column字段前加上表前缀的，比如下边的写法就是有语法错误的：12update aset a.value = 'test';参考链接How to do an update + join in PostgreSQL?]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL - 执行sql报错USING BTREE]]></title>
    <url>%2Fposts%2Fa6b9a623.html</url>
    <content type="text"><![CDATA[问题与分析在执行sql文件时发现报错如下：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘USING BTREE....该错误导致有一个表创建失败，一时间很诧异。因为我所执行的sql语句是由SQLyog导出来的，怎么会有语法错误呢？因为报错里的中文字符变成了乱码，一开始以为是sql语句里的中文字符存在着编码问题，重新修改了好几遍，最后把中文字符去掉了也还是会报同样的错误。最后百度后才知道，原来这是MySQL的一个bug：MySQL 5.1和MySQL 5.0在处理到索引语句时有所区别，我所执行的sql语句是从高版本的MySQL里导出来的。当存在UNIQUE KEY的表导出来时，其sql如下：1UNIQUE KEY `idx_name` (`column_name`) USING BTREE对于该语句，低版本的MySQL是不能识别的，所以就报错了。解决方法将高版本MySQL导出来的sql语句里的column_name调整到USING BTREE后边就行了，如下：1UNIQUE KEY `idx_name` USING BTREE (`column_name`)参考链接mysql导入数据时提示 USING BTREE 错误解决办法]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么快速对DB里的所有email进行校验]]></title>
    <url>%2Fposts%2F4a555132.html</url>
    <content type="text"><![CDATA[问题由于业务上的需求，重新改写了校验email的正则表达式，同时DB里又迁移了其他数据库的数据，现在需要重新对DB里的所有email再校验一次，以排除掉不合法的email。DB里的数据很多，手动去一个个校验的做法显然是不靠谱的，这种机械的重复性操作，自然是要用程序来解决才是最简易的。做法拼接字符串首先是将DB里所有的email都拼接成一个字符串，由于用的是PostgreSQL，所以直接使用现有的字符串拼接函数string_agg()。具体用法如下：1select string_agg(email, ';') from cnt_user where is_latest;大意就是拿到所有的最新版本的用户的email，以’;’作为间隔符，将这些email拼接起来，得到的结果就是：`test1@qq.com;test2@qq.com…`在程序中进行校验自己写一个测试类，把刚刚db查询到的字符串复制进来，通过String类的split()将其进行切割成一个String数组，然后遍历该数组，通过正则表达式去一个个校验，将那些校验不通过的email给打印出来。注意：这种方法不适用于email数量特别多的情况，如果String数组的大小超过3亿多，会报内存溢出OutOfMemoryError的错误。大概的思路如下：123456789101112131415/** Regex for single EmailValidator */public static final String SINGLE_EMAIL_REGEX = "(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~]|(?:\\\\[\\x00-\\xFF]?)|"+ "(?:\"[\\x00-\\xFF]*\"))+(?:\\.(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~])|(?:\\\\[\\x00-\\xFF]?)|"+ "(?:\"[\\x00-\\xFF]*\"))+)*)@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.)+"+ "(?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))";public static final Pattern SINGLE_EMAIL_REGEX_PATTERN = Pattern.compile(SINGLE_EMAIL_REGEX);...final String emailString = "******"; //DB里通过函数拼接起来的email字符串final String[] emails = emailString.split(";");for (final String email : emails) &#123; final Matcher matcher = SINGLE_EMAIL_REGEX_PATTERN.matcher(email); if (!matcher.matches()) &#123; System.out.println("The email is invalid: " + email); &#125;&#125;如果不合法的email有很多的话，还可以通过poi将这些email输出到一个文档中。]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
        <tag>正则表达式</tag>
        <tag>PostgreSQL</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - pgAdmin4远程连接数据库]]></title>
    <url>%2Fposts%2F9f87c20d.html</url>
    <content type="text"><![CDATA[前言PostgreSQL在安装的时候自带的pgAdmin这个可视化工具，自从将PostgreSQL9升级到了10版本后，自带的pgAdmin也从3升级到了4版本。pgAdmin4的变化非常巨大，刚接触时一脸懵逼，这里记录下怎么用pgAdmin4进行远程连接数据库并执行SQL语句。操作步骤选中Browser窗口里的Servers -&gt; 点击上方工具栏里的Object -&gt; Create -&gt; Server…在弹窗的General tab里填写Name，可以随意命名接着选择第二个tab：Connection，填写Host的ip地址、端口号、数据库名、用户名、密码，点击save保存执行SQL语句在配置好上边的server后，连接该server，接着连接server下的某个Database，连接成功后可以通过以下方式来执行SQL：点击上方工具栏里的Tools -&gt; Query Tool输入SQL选定某条SQL语句，点击Query Tool里的闪电标志的按钮，就可以执行改SQL语句PS:虽然pgAdmin4比起3的ui好看了很多，在restore db的时候也变成了后台异步restore，不至于在restore比较大的db时阻塞住进程。但个人还是更喜欢另一款可视化工具DBeaver，不仅支持市面上各大常见的数据库，还有很多好用的功能和快捷键，真的非常好用！！强烈推荐！！参考链接pgadmin4远程连接 postgresql服务]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读ping -n 4 127.1 >nul 2>nul]]></title>
    <url>%2Fposts%2Fcf676a21.html</url>
    <content type="text"><![CDATA[命令解读ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式是ping空格ip地址，可以附带参数，可以直接在cmd中输入ping然后回车来得到具体的帮助信息。127.1是127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常的。-n 4表示ping几次，ping一次大概一秒钟，如果不加这个参数去使用ping命令，默认会ping4次。&gt;nul表示不显示ping的结果，但是不能隐藏错误信息。2&gt;null表示隐藏错误信息。于是最后这句命令就变成了延迟命令，表示等待4秒钟，你会看到光标闪烁了四下，一般用来延迟后面的代码的执行，或者说，用来让程序等待N秒钟(取决于-n后面的数值)。补充这里的&gt;是重定向符，表示将输出重定向到指定的文件。如果该指定文件原本已存在，也会被覆盖掉。如果不希望覆盖掉原本的文件，可以用&gt;&gt;重定向符。我们输入的命令默认会重定向到控制台，也就是cmd窗口。比如你在命令提示符窗口键入dir会在控制台打印出目录文件，这时候其实运行的是dir &gt;con，con就是指的console控制台。&gt;nul表示将输出重定向到空设备nul，也就是不显示输出。至于2&gt;nul的2，指的是stderr标准错误输出流，是用来输出错误信息的，这里就表示不输出错误信息。对应的，还有0&gt;nul,1&gt;nul。0表示stdin标准输入流，就是在控制台键入的信息。1表示stdout标准输出流，也就是正常输出的信息。1&gt;nul其实就是&gt;nul。参考链接ping （网络诊断工具）本地回环地址ping -n 10 127.1&gt;nul是什么意思批处理 ping命令 ping -n 4 127.1 &gt;nul 2&gt;nul exit 什么意思啊？谢谢批处理：其中的&gt;NUL作用是什么？bat语句中“1&gt;&amp;2”是什么意思？]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd,bat和dos的区别]]></title>
    <url>%2Fposts%2F97f9f429.html</url>
    <content type="text"><![CDATA[区别dos是磁盘操作系统(Disk Operating System)，是个人计算机上的一类操作系统。bat是DOS命令，在任何dos环境下都可以使用。bat文件是dos下的批处理文件，批处理文件是无格式的文本文件，它包含一条或多条命令，后缀为.cmd或.bat，在Windows NT系统中，两者没有任何区别。cmd是cmd.exe，是Win32命令，只能在32位系统中的命令行窗口中使用，仅仅是基于windows环境下的假DOS。cmd文件的描述是“windows nt命令脚本”，bat文件的描述是“ms dos批处理文件”；两者所使用的命令行代码是共用的，只是cmd文件中允许使用的命令要比bat文件多。cmd文件只有在windows2000以上的系统中才能运行，而bat文件则没有这个限制。在Windows NT系统中，这两种批处理文件由cmd.exe解释执行。在cmd命令提示符窗口键入批处理文件名，或者直接双击批处理文件，即可执行，系统会去调用cmd.exe按照该文件中各个命令出现的顺序来逐个运行。参考链接cmd文件和bat文件有什么区别bat和cmd文件是什么，dos又是什么东西关于CMD和BAT]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>cmd</tag>
        <tag>bat</tag>
        <tag>dos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi/vim打开文件提示Found a swap file by the name]]></title>
    <url>%2Fposts%2Fc3c6b3d8.html</url>
    <content type="text"><![CDATA[问题分析有一次在远程连接主机时，用vi打开文件my.ini却提示：Found a swap file by the name &quot;.my.ini.swp&quot;。百度了下才知道，原来在使用vi或vim命令打开一个文件后，就会产生一个.(filename).swp的文件。如果编辑完成之后，正常退出，那么这个swp文件就会被自动删除。而之前我在使用vi操作该文件时发生了异常中断(非正常退出)，于是就在当前目录下生成了一个.my.ini.swp文件。在Linux中，以.开头的文件都是隐藏文件，可以通过使用ll -a或者ls -a来查看。这种swp文件是隐藏文件，有两个作用：避免用多个程序编辑同一个文件时，产生两个不同的版本。非常规退出时，文件恢复。解决方法删除swp文件只要将swp文件删除，就不会再出现这个提示。可以通过rm命令来删除该文件。禁止生成swp文件如果想要禁止生成swp文件，可以通过修改vim的配置文件来实现。新建一个~/.vimrc文件，在文件中添加一行代码：1set noswapfile这样该配置就只会对当前用户生效，你也可以直接修改/etc/vimrc文件，效果是一样的。通过swp文件来恢复文件swp文件可以用来恢复文件，假如你有一个swp文件.my.ini.swp，可以通过以下命令来恢复：1vi -r my.ini恢复文件之后可以把swp文件删除，不然每次打开my.ini文件时都会提示。参考链接linux下vi操作Found a swap file by the name非正常关闭vi编辑器时会生成一个.swp文件]]></content>
      <categories>
        <category>计算机</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取更多关于序列化异常的堆栈信息]]></title>
    <url>%2Fposts%2Fa206131b.html</url>
    <content type="text"><![CDATA[问题与解决方法有时候我们的系统会报java.io.NotSerializableException，根据堆栈信息又无法得出有用的信息，无法找到具体是因为哪些类或者变量造成的，可以使用一个java参数-Dsun.io.serialization.extendedDebugInfo=true来得到更加具体的序列化信息。从jdk6开始就可以使用该参数，可以在启动java程序时启用该参数，也可以在项目的一开始通过代码来启用：1System.setProperty("sun.io.serialization.extendedDebugInfo", "true");下边是stackoverflow上找到的两个回答：回答其一From JDK6 you should be able to get extra information by setting the sun.io.serialization.extendedDebugInfo system property:-Dsun.io.serialization.extendedDebugInfo=true回答其二Set the system property sun.io.serialization.extendedDebugInfo to true, either by adding-Dsun.io.serialization.extendedDebugInfo=trueto the command line, or add the line System.setProperty(&quot;sun.io.serialization.extendedDebugInfo&quot;, &quot;true&quot;); at the start of your program.If something isn’t serializable, this will cause a trace of the path through the data structure that leads from the “root” object (the one passed to ObjectOutputStream.writeObject()) to the object that’s not serializable. At least, it’ll tell you the class names of the instances and the fields that lead to the non-serializable object.参考链接Locating Serialization Issue in Complex Beancannot find source of NotSerializableException]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为GitHub项目添加协议]]></title>
    <url>%2Fposts%2F7eb15a2d.html</url>
    <content type="text"><![CDATA[解决方法如果一开始在GitHub上创建仓库时没有添加协议，可以用以下方式来重新添加相关的协议：打开GitHub上的某个仓库，点击Create new file；在新建文件的页面上，输入文件名LICENSE，这时候你会发现在标题的右边多出来一个按钮Choose a license template，点击该按钮；在新页面上选择一个你想要的协议，接着在最右边输入Year和Full name，你会发现中间板块的年份和名称会发生变化，这是协议的预览界面，确认无误后点击最右边的Review and submit；最后填写commit信息，点击Commit changes即可。参考链接如何为github已有仓库添加协议。]]></content>
      <categories>
        <category>其他</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10无法写入删改c盘文件的解决方法]]></title>
    <url>%2Fposts%2F1d8592b7.html</url>
    <content type="text"><![CDATA[前言最近使用了win10系统，结果发现对c盘的文件进行写入删改，在网上到处搜集资料，终于找到了解决方法，这里总结一下。首先，本文针对的是win10家庭版，家庭版默认是不提供组策略功能，而我们需要给家庭版添加组策略功能来获取修改c盘文件的权限。在win10家庭版添加组策略功能在win10家庭版通过win+R打开运行，输入gpedit.msc，回车确定，会提示说windows找不到文件&#39;gpedit.msc&#39;。我们可以自己添加组策略功能：首先新建一个txt文本，填入以下内容：123456@echo offpushd &quot;%~dp0&quot;dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txtdir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txtfor /f %%i in (&apos;findstr /i . gp.txt 2^&gt;nul&apos;) do dism /online /norestart /add-package:&quot;%systemroot%\servicing\Packages\%%i&quot;pause将该txt文件保存后，修改文件后缀为.bat或者.cmd都行；或者直接将txt文件另存为所有文件类型，文件名随意，然后扩展名为.bat或者.cmd都可以。这里为了方便日后查找，可以将文件命名为gpedit.bat。接着右键以管理员身份运行这个文件，等待程序安装完毕，你会发现在该文件的目录下多出来一个gp.txt文件。这时候你再一次在cmd窗口中输入gpedit.msc，回车确定，你会发现亲爱的组策略编辑器又回来了。这时候你可以将gpedit.bat和gp.txt文件都删了，或者保留起来也行，它们已经完成使命，可以功成身退了。在组策略中禁用管理员批准模式在cmd窗口中输入gpedit.msc，接着回车，进入组策略编辑器界面。在计算机配置 -&gt; Windows设置 -&gt; 安全设置 -&gt; 本地策略 -&gt; 安全选项的目录中，找到用户帐户控制: 以管理员批准模式运行所有管理员这个策略，将安全设置更改为已禁用，重启电脑后便可以随意写入删改c盘文件。下面附上大佬对于该选项的解释：用户帐户控制: 启用管理审批模式。此策略设置控制计算机的所有用户帐户控制(UAC)策略设置行为。如果更改此策略设置，则必须重新启动计算机。选项为:启用: (默认设置)启用管理审批模式。必须启用该策略并且相关的 UAC 策略设置还必须设置正确以允许内置管理员帐户以及是管理员组成员的所有其他用户在管理审批模式下运行。禁用: 禁用管理审批模式以及所有相关 UAC 策略设置。注意: 如果禁用此策略设置，则安全中心将通知你操作系统的总体安全性已降低。说白了就是uac关闭了，没有内置管理审批（管理），就可以随意操作电脑参考链接封印解除：如何在Win10家庭版中启用组策略Win10家庭版找不到组策略gpedit.msc怎么办【平凡666】win 10 C盘无法写入或者删除没有权限解决办法]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>win10家庭版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml中一个filter配置多个url-pattern]]></title>
    <url>%2Fposts%2F61154519.html</url>
    <content type="text"><![CDATA[需要在filter标签后添加多个filter-mapping标签，一个url-pattern就对应一个filter-mapping标签，不能直接把多个url-pattern配置到同一个filter-mapping标签里，也不能直接把多个url直接配置到一个url-pattern标签里。正确地配置方式如下所示：123456789101112&lt;filter&gt; &lt;filter-name&gt;test&lt;/filter-name&gt; &lt;filter-class&gt;com.test.TestFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;test&lt;/filter-name&gt; &lt;url-pattern&gt;/test/a/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;test&lt;/filter-name&gt; &lt;url-pattern&gt;/test/b/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel - 使用公式将秒转换为分+秒]]></title>
    <url>%2Fposts%2F5be6b2f2.html</url>
    <content type="text"><![CDATA[场景现在有个需求：将Excel里的时间转换为分+秒的格式，如下：time(second)time(min+second)482.712XXmin,XXs480.737XXmin,XXs对于这种场景，可以通过Excel的公式来实现。解决方法假设现在的time(second)是单元格的A1位置，我们需要对A2、A3等等这一列转换到B这一列。先在B1单元格输入以下公式：1=INT(A2/60)&amp;&quot;min,&quot;&amp;ROUND(MOD(A2,60),0)&amp;&quot;s&quot;输入之后，你会发现该单元格的内容就变成了8min,3s。这里的INT(a)表示将数值a向下取整为最接近的整数，ROUND(a, b)表示按照b的位数来将a四舍五入，MOD(a, b)表示a除以b的余数，&amp;表示拼接字符串。现在可以对一个单元格进行公式求值了，接着按住该单元格的右下角，鼠标会变成一个+号，按住不放向其它方向拖动，可以将对应的单元格自动填充该公式。如果希望在单元格内进行换行，在需要换行的地方按下Alt + Enter组合键即可。]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>常用软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows类标识符及其妙用]]></title>
    <url>%2Fposts%2Fa7d10acb.html</url>
    <content type="text"><![CDATA[Windows类标识符百度百科这样解释：Windows的类标识符class identifier也称为CLASSID或CLSID，是与某一个类对象相联系的唯一标记(UUID)。一个准备创建多个对象的类对象应将其CLSID注册到系统注册数据库的任务表中，以使客户能够定位并装载与该对象有关的可执行代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051回收站.&#123;645ff040-5081-101b-9f08-00aa002f954e&#125;回收站(满).&#123;5ef4af3a-f726-11d0-b8a2-00c04fc309a4&#125;拨号网络.&#123;992CFFA0-F557-101A-88EC-00DD010CCC48&#125;打印机.&#123;2227a280-3aea-1069-a2de-08002b30309d&#125;控制面板.&#123;21ec2020-3aea-1069-a2dd-08002b30309d&#125;网上邻居.&#123;208D2C60-3AEA-1069-A2D7-08002B30309D&#125;图标clsid=windowsmedia 文件名.&#123;00020c01-0000-0000-c000-000000000046&#125;无关联文件 文件名.&#123;00021401-0000-0000-c000-000000000046&#125;BMP文件 文件名.&#123;d3e34b21-9d75-101a-8c3d-00aa001a1652&#125;HTML文件 文件名.&#123;25336920-03f9-11cf-8fd0-00aa00686f13&#125;媒体剪辑文件 文件名.&#123;00022601-0000-0000-c000-000000000046&#125;计划任务 文件名.&#123;D6277990-4c6a-11cf-8d87-00aa0060f5bf&#125;Web文件夹 文件名.&#123;Bdeadf00-C265-11d0-Bced-00a0c90ab50f&#125;历史记录 文件名.&#123;Ff393560-C2a7-11cf-Bff4-444553540000&#125;收藏夹 文件名.&#123;1a9ba3a0-143a-11cf-8350-444553540000&#125;预订文件夹 文件名.&#123;F5175861-2688-11d0-9c5e-00aa00a45957&#125;ActiveX高速缓存文件夹文件名.&#123;88c6c381-2e85-11d0-94de-444553540000&#125;excel.&#123;00020810-0000-0000-C000-000000000046&#125;word.&#123;00020900-0000-0000-C000-000000000046&#125;media.&#123;00022603-0000-0000-C000-000000000046&#125;CAB.&#123;0CD7A5C0-9F37-11CE-AE65-08002B2E1262&#125;搜索-计算机.&#123;1f4de370-d627-11d1-ba4f-00a0c91eedba&#125;mht.&#123;3050F3D9-98B5-11CF-BB82-00AA00BDCE0B&#125;mshta.&#123;3050f4d8-98B5-11CF-BB82-00AA00BDCE0B&#125;我的文档.&#123;450D8FBA-AD25-11D0-98A8-0800361B1103&#125;XML.&#123;48123bc4-99d9-11d1-a6b3-00c04fd91555&#125;ftp_folder.&#123;63da6ec0-2e98-11cf-8d82-444553540000&#125;网络和拨号连接.&#123;7007ACC7-3202-11D1-AAD2-00805FC1270E&#125;写字板文档.&#123;73FDDC80-AEA9-101A-98A7-00AA00374959&#125;Temporary Offline Files Cleaner.&#123;750fdf0f-2a26-11d1-a3ea-080036587f03&#125;用户和密码.&#123;7A9D77BD-5403-11d2-8785-2E0420524153&#125;Internet 临时文件.&#123;7BD29E00-76C1-11CF-9DD0-00A0C9034933&#125;已下载的程序文件的清除程序.&#123;8369AB20-56C9-11D0-94E8-00AA0059CE02&#125;公文包.&#123;85BBD920-42A0-1069-A2E4-08002B30309D&#125;mail.&#123;9E56BE60-C50F-11CF-9A2C-00A0C90A90CE&#125;目录.&#123;fe1290f0-cfbd-11cf-a330-00aa00c16e65&#125;Internet Explorer.&#123;FBF23B42-E3F0-101B-8488-00AA003E56F8&#125;Snapshot File.&#123;FACB5ED2-7F99-11D0-ADE2-00A0C90DC8D9&#125;MyDocs Drop Target.&#123;ECF03A32-103D-11d2-854D-006008059367&#125;Policy Package.&#123;ecabaebd-7f19-11d2-978E-0000f8757e2a&#125;搜索结果.&#123;e17d4fc0-5564-11d1-83f2-00a0c90dc849&#125;添加网上邻居.&#123;D4480A50-BA28-11d1-8E75-00C04FA31A86&#125;Paint.&#123;D3E34B21-9D75-101A-8C3D-00AA001A1652&#125;管理工具.&#123;D20EA4E1-3957-11d2-A40B-0C5020524153&#125;字体.&#123;D20EA4E1-3957-11d2-A40B-0C5020524152&#125;Web Folders.&#123;BDEADF00-C265-11d0-BCED-00A0C90AB50F&#125;DocFind Command.&#123;B005E690-678D-11d1-B758-00A0C90564FE&#125;脱机文件夹.&#123;AFDB1F70-2A4C-11d2-9039-00C04F8EEB3E&#125;Internet Explorer.&#123;871C5380-42A0-1069-A2EA-08002B30309D&#125;上帝模式/完全控制面板.&#123;ED7BA470-8E54-465E-825C-99712043E01C&#125;使用用法虽然上边的说明和内容会让人一脸懵逼，但还是有几种很简单的使用方法。RM皮肤Rainmeter Skin在RM的皮肤中有些插件会使用到这些类标识符来打开对应的应用，比如经典的蜂窝桌面，就可以通过使用上边的类标识符，就和快捷方式差不多。123456789101112131415161718192021[Button.10]Meter=BUTTONX=352Y=#DockY#W=70H=30ButtonImage=Dock.pngButtonCommand=!execute [&quot; ::&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125; &quot;][10.p]Meter=STRINGX=35rY=5rW=70H=22StringStyle=BOLDFontColor=#FontColor.W#FontSize=#FontHeight#FontFace=#FontName#AntiAlias=#AntiAlias#stringAlign=#dAligen#Text=&quot;我的电脑&quot;需要注意的是，在Rainmeter中使用这些类标识符的时候，需要在前边加上两个英文的冒号。上帝模式/完全控制面板电脑的“上帝模式”即“God Mode”，从Windows Vista开始，微软在Windows系统中隐藏了一个集成了系统所有设置项的“上帝模式(God Mode)”。到了Win10系统，这个神秘而强大的“上帝模式(God Mode)”仍然保留着。上帝模式就是全部功能展示模式，因为功能太强大，所以被戏称为“上帝模式”。它还有一个通俗的名称叫“完全控制面板”，因为它包含了几乎所有Windows系统的设置。有两种打开方式，一种是Win+R组合建打开运行框，输入shell:::{ED7BA470-8E54-465E-825C-99712043E01C}，回车确定后就会打开完全控制面板。除了可以用运行框来打开上帝模式，也可以自己修改成其他的类标识符来打开对应的系统应用。另一种方式和下边说的伪装文件夹的使用方法一样。改头换面，伪装文件夹新建一个文件夹，将文件夹命名为xxx.{645ff040-5081-101b-9f08-00aa002f954e}这种格式的名字。这样前边的xxx会变成文件夹的名字，后边的.{xxxx}则会被自动隐藏。此时该文件夹会变成类标识符对应的Windows系统应用图标，双击打开该文件夹也会打开对应的系统应用。这样就起到了伪装并隐藏原本文件夹的作用，效果类似于以前的图种(就是利用一张图片来隐藏实际的文件，比如神秘链接什么的)。以前的一些恶意广告插件就是通过这种方法进行IE劫持，在桌面新建一个Internet Explorer.{871C5380-42A0-1069-A2EA-08002B30309D}名字的文件夹，这样该文件夹就会变成IE浏览器的应用。怎么破解伪装的文件夹不同电脑在使用上边的方法去伪装文件夹的时候，有的类标识符可能没有效果，不过一般使用垃圾桶、网上邻居之类的类标识符是没问题的。那么对于这种伪装了的文件夹，要怎么破解呢？有两种方法，这两种方法都需要安装WinRAR之类的的解压缩软件才可以使用。方法一直接右键点击伪装的文件夹，选择打开，这样就可以直接看到被隐藏起来的文件夹内的文件。这实际上是解压缩软件把该文件夹当成压缩文件来打开了。但是并不是所有被伪装的文件夹都可以使用这种方法，比如伪装成了网上邻居的文件夹，就无法用这种方法。方法二打开任意一个压缩包，在当前的压缩包查看界面将地址栏的目录改成被伪装的文件夹的父目录，这样你就会发现伪装的文件夹的名字变成了包含类标识符的全名。选定该被伪装的文件夹，按F2改名字，将类标识符去掉，改成普通的文件夹名字。这时候再重新查看这个被伪装的文件夹，已经变回了正常的文件夹。参考链接Windows类标识符百度百科妙用Windows神秘的类标识符【技术交流】妙用Windows神秘的类标识符厉害了，win 10居然有上帝模式？]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>类标识符</tag>
        <tag>CLSID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在接口的实现类里使用@Override注解报错]]></title>
    <url>%2Fposts%2Ff3ccdaa7.html</url>
    <content type="text"><![CDATA[问题分析@Override注解用来检测子类对父类或接口的方法的重写是否正确，但有一次我在Eclipse里对接口的实现类里使用@Override注解却报错，不过在父类的子类里使用该注解却是正常的。百度了下才知道原来这是jdk1.5时的一个bug，在1.6时已经被修复；那么问题来了，我使用的jdk是1.8，为什么会报这个错误？明明之前也在接口的实现类里用过该注解，却没问题。由于Eclipse经常抽风，我怀疑是Eclipse的问题，经过排查确实如此，该项目使用的jdk版本不知道为什么变成了jdk1.5，导致出现了注解报错的问题。解决方法右键该项目，选择Properties，将Java Compiler和Java Facets里的jdk版本从1.5改为更高的版本，再刷新下项目重新编译就没问题了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 查询表结构和索引信息]]></title>
    <url>%2Fposts%2F42ffcbd5.html</url>
    <content type="text"><![CDATA[前言PostgreSQL的表一般都是建立在public这个schema下的，假如现在有个数据表t_student，可以用以下几种方式来查询表结构和索引信息。使用\d元命令查看表字段信息和索引信息在cmd界面使用psql连接db后，输入\d加上表名即可：1\d t_student通过系统数据字典查询表结构123456789101112131415161718192021selectcol.table_schema,col.table_name,col.ordinal_position,col.column_name,col.data_type,col.character_maximum_length,col.numeric_precision,col.numeric_scale,col.is_nullable,col.column_default,des.descriptionfrominformation_schema.columns col left join pg_description des oncol.table_name::regclass = des.objoidand col.ordinal_position = des.objsubidwheretable_schema = 'public'and table_name = 't_student'order byordinal_position;或者简单点：12select * from information_schema.columnswhere table_schema='public' and table_name='t_student';通过系统数据字典查询索引信息1234567891011121314151617181920212223242526selectA.SCHEMANAME,A.TABLENAME,A.INDEXNAME,A.TABLESPACE,A.INDEXDEF,B.AMNAME,C.INDEXRELID,C.INDNATTS,C.INDISUNIQUE,C.INDISPRIMARY,C.INDISCLUSTERED,D.DESCRIPTIONfromPG_AM B left join PG_CLASS F onB.OID = F.RELAM left join PG_STAT_ALL_INDEXES E onF.OID = E.INDEXRELID left join PG_INDEX C onE.INDEXRELID = C.INDEXRELID left outer join PG_DESCRIPTION D onC.INDEXRELID = D.OBJOID,PG_INDEXES AwhereA.SCHEMANAME = E.SCHEMANAMEand A.TABLENAME = E.RELNAMEand A.INDEXNAME = E.INDEXRELNAMEand E.SCHEMANAME = 'public'and E.RELNAME = 't_student';查询所有的表名123456789101112selectn.nspname,relnamefrompg_class c,pg_namespace nwherec.relnamespace = n.oidand nspname = 'public'and relkind = 'r'order byrelname;可视化工具DBeaver对于上述的sql语句只需要修改要查询的table name，可以根据需要自行修改想要查询的column。如果是通过DBeaver来连接数据库，还可以直接在当前的数据库实例下打开schema里的public选项，接着选中table，选中你想查看的表，可以很直观地看到该表的各种信息：column、index等等。参考链接PostgreSQL：如何查询表的字段信息？]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad - win10环境下无法渲染HTML问题]]></title>
    <url>%2Fposts%2F511045a6.html</url>
    <content type="text"><![CDATA[问题在win10平台安装了MarkdownPad 2之后，发现在渲染md文件时报错，在预览页面无法正常渲染HTML：安装报错提示前往官网，可以看到如下的解决方法：LivePreview is not working - it displays an error message stating This view has crashed!This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.To fix this issue, please try installing the Awesomium 1.6.6 SDK.If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010).解决方法请尝试安装Awesomium 1.6.6 SDK在安装之后依然有这个问题，请安装Microsoft’s DirectX End-User Runtimes (June 2010)参考链接Frequently Asked Questions升级win10后 MarkdownPad 2 无法实时渲染HTML页面问题]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>常用软件</tag>
        <tag>MarkdownPad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 怎么通过环境变量来切换jdk版本]]></title>
    <url>%2Fposts%2F754cf0ad.html</url>
    <content type="text"><![CDATA[问题与分析我在本地安装了1.7和1.8两个版本的jdk，此时我的JAVA_HOME环境变量配置的是jdk1.8，在cmd窗口输入java -version发现报错如下：12345C:\Users\Lewis&gt;java -versionError: Registry key &apos;Software\JavaSoft\Java Runtime Environment&apos;\CurrentVersion&apos;has value &apos;1.8&apos;, but &apos;1.7&apos; is required.Error: could not find java.dllError: Could not find Java SE Runtime Environment.接着输入javac -version则是正常：12C:\Users\Lewis&gt;javac -versionjavac 1.8.0_191javac命令能正常执行， 说明我配置的CLASSPATH变量和JAVA_HOME变量正确。而java命令报错，则说明PATH变量有问题。cmd窗口在执行命令时会去PATH变量的值里寻找路径，当找到对应的路径后就不会再继续查找下去。所以我们应该把java相关的路径放到PATH变量值的最前面，需要注意的是，如果你安装了Oracle，你会发现Oracle的环境变量会直接排到最前面，也就是说，这时候会优先去Oracle指定的目录下寻找java的命令。但只是将java路径放置到最前面还是不够的，因为WINDOW本身系统SYSTEM32里面的环境变量加载等级要优先于用户设置的环境变量，所以我们还需要将C:\Windows\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名才行。解决方案将PATH环境变量的变量值里的java路径放置到最前面；将C:\Windows\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名。接下来进行测试，会发现java -version得到了正确的结果：1234C:\Users\Lewis&gt;java -versionjava version &quot;1.8.0_191&quot;Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)接着将JAVA_HOME改为jdk1.7的目录，再一次测试java和javac命令，都能得到正确的结果。参考链接切换JDK版本时修改JAVA_HOME环境变量不生效]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 安装jdk并设置环境变量]]></title>
    <url>%2Fposts%2F4c4c677.html</url>
    <content type="text"><![CDATA[前言双十一买了台新的笔记本，需要重新安装下Java，这里记录下安装的过程，毕竟万事开头难，就算是老手也不一定能一次就把Java安装成功。安装jdk作为一名Java开发，当然是要安装jdk了，如果只是需要Java的运行环境，那么安装jre就足够了。另外说下，jdk里以及包含了jre了。首先去官网下载Java，由于Sun被Oracle收购了，现在去官网下载Java需要先注册一个Oracle账号，虽然麻烦了点，但是没办法，谁叫Oracle牛逼呢。由于页面是全英文的，部分同学可能会懵逼，其实没什么，随便找一个版本下载就行。唯一需要注意的是，下载文件之前要先点击一下文件上方的同意协议，否则会提示你还没有同意协议。接着把下载好的文件启动，一路按照默认配置安装即可。当安装好jdk后，接下来的步骤就是配置环境变量了。不夸张的说，99%的同学都曾经倒在了环境变量的配置上，甚至直接就放弃安装Java了。配置环境变量环境变量其实就是定义给系统使用的变量，当使用到这些变量时，会自动替换成对应的路径名，以便找到程序或者命令。而环境变量分为用户变量和系统变量，顾名思义，用户变量是给当前的电脑用户使用的，系统变量是所有用户公用的。我们只要配置成用户变量就行，如果你想定义成系统变量也没问题。配置Java的环境变量其实很简单，一共就三个环境变量：JAVA_HOMEPATHCLASSPATH注意，所有环境变量的变量值都是使用的英文符号！！别写成中文的分号、冒号等符号了！！JAVA_HOME这个变量名指的是Java的安装路径，其实很多程序在安装的时候，都会自动给你新建一个对应的环境变量XXX_HOME。不过Java并没有自动给我们新建该变量，所以需要我们自己来创建。另外很多程序，比如Eclipse、Maven、Tomcat等等，都会使用到这个变量。新建一个环境变量JAVA_HOME，然后在变量值里输入你的jdk安装路径，比如我的是C:\Program Files\Java\jdk1.7.0_80。PATH这个变量是系统本身就有的，当你在cmd窗口里执行命令的时候就会去这个PATH变量里找到对应的路径，如果找不到就会报错。这一步我们需要在PATH的变量值里加上%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin，最好是将这段变量值加在最前面，如果是加在最前面，还需要在末尾加上英文的分号。CLASSPATH这个变量需要我们新建，变量名是CLASSPATH，变量值是.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar，请别在变量值的末尾画蛇添足加上分号。该变量的作用是用来寻找类文件的路径，如果该变量值不对，就会导致javac命令找不到的错误。测试jdk和环境变量java -versionwin+R打开运行程序，输入cmd接着回车，在cmd窗口里输入java -version，正常的情况是能得到类似如下的信息：1234C:\Users\Lewis&gt;java -versionjava version &quot;1.7.0_80&quot;Java(TM) SE Runtime Environment (build 1.7.0_80-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)javac -version在cmd窗口里输入javac -version，正常的情况是能得到类似如下的信息：12C:\Users\Lewis&gt;javac -versionjavac 1.7.0_80这两个命令的区别是，前者是用来执行java程序或者命令的，后者是用来编译java文件的。javac就是指的java compiler。win10下的环境变量问题如果是win10，在配置环境变量时，一般是弹出表格，然后一行一行地输入变量值，而不是像上边那样需要使用英文分号来分隔开。有可能会发生配置好环境变量后，在输入java -version能得到正常的结果，而在输入javac -version后却是显示的：123C:\Users\Lewis&gt;javac -version&apos;javac&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。解决办法很简单，先检查你的JAVA_HOME是否路径正确，是否使用了错误的中文符号等；接着检查另外两个变量是否书写正确。因为win10第一次配置环境变量时是一行一行地在表格里输入的，后面重新打开的时候就变回了win7/8那种格式，你会发现CLASSPATH变量的变量值莫名被加上了双引号(我本人就是属于这种情况)，把双引号去掉后重新保存环境变量；接着关闭原本的cmd窗口，重新打开cmd窗口进行测试，测试成功。如果依然是一行一行输入变量值的表格形式，需要把分号去掉，然后分成多行各自输入，且末尾不能有英文分号，另外最好把变量值上移到顶端。注意，如果改变了环境变量，必须要把原本的cmd窗口关掉才行，因为原本的cmd窗口依然使用的是你修改之前的环境变量。参考链接java 安装教程window10下java环境变量的配置 javac不是内部或外部命令的问题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd - 使用curl命令的注意点]]></title>
    <url>%2Fposts%2F2ed0604f.html</url>
    <content type="text"><![CDATA[前言最近在cmd中使用curl命令来测试rest api，发现有不少问题，这里记录一下。在cmd中使用curl命令的注意事项json不能由单引号包括起来json数据里的双引号要用反斜杠\转义json数据里不能带有空格如果想要在json数据里使用空格则必须用双引号将整个json数据包括起来Content-type要由双引号包括起来比如下边的例子就是正确的格式：1curl -X POST localhost:8080/employees -H &quot;Content-type:application/json&quot; -d &quot;&#123;\&quot;name\&quot;: \&quot;Samwise Gamgee\&quot;, \&quot;role\&quot;: \&quot;gardener\&quot;&#125;&quot;总的来说，还是用postman来测试rest api方便快捷。参考链接使用curl post json到webApi]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
        <tag>计算机</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat - ClassFormatException的解决方法]]></title>
    <url>%2Fposts%2Fe5b9143e.html</url>
    <content type="text"><![CDATA[问题与分析在使用Tomcat7运行web项目时报错如下：123严重: Compilation errororg.eclipse.jdt.internal.compiler.classfmt.ClassFormatExceptionat ....仔细查看了报错的堆栈信息，发现基本说的都是无法编译jsp的错误。百度了一番，才明白原来是因为Tomcat7和jdk8存在着不兼容的情况。Tomcat通过ecj.jar来编译jsp，这个ecj是Eclipse自己开发和使用的针对Java的编译器。ecj即the Eclipse Compiler for Java，Eclipse并没有使用JDK自带的编译器，而是使用自己开发的ecj编译器，而ecj也通过了java的验证。除了Eclipse之外，Tomcat也用到了ecj，用于动态编译jsp文件，可以在Tomcat的lib目录下找到该jar包。而这个ClassFormatException，就是因为Tomcat7使用的ecj.jar版本比较低，里边使用的是较低版本的jdk，导致无法在jdk8的环境下去编译jsp文件。解决方案方案一既然是Tomcat7和jdk8不兼容导致的，那么我们只要使用Tomcat8或者jdk7自然就没这个问题了。如果希望还是使用Tomcat7和jdk8来运行项目，就需要使用方案二了。方案二将Tomcat7的lib目录下的ecj.jar换成Tomcat8里边的ecj.jar，比如说将ecj3.7.2换成ecj.4.4.2，这样就可以让Tomcat7和jdk8兼容了。如果你懒得去下载Tomcat8然后获取里边的高版本ecj.jar，可以去Maven中央仓库获取对应版本的ecj.jar：https://mvnrepository.com/artifact/org.eclipse.jdt.core.compiler/ecj参考链接jdk1.8+Tomcat7.0小版本无法兼容问题解决(ecj)Eclipse的Java编译器分析之一——ecj介绍]]></content>
      <categories>
        <category>中间件</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>中间件</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - Class版本号和UnsupportedClassVersionError]]></title>
    <url>%2Fposts%2Ffd82a4a.html</url>
    <content type="text"><![CDATA[问题分析Java是向下兼容的，每一个jdk版本都有对应的class版本号(major + minor version numbers)；如果用低版本的jvm去加载高版本jdk编译的类，就会报错：java.lang.UnsupportedClassVersionError源码中关于这个UnsupportedClassVersionError的注释如下：1234567/*** Thrown when the Java Virtual Machine attempts to read a class* file and determines that the major and minor version numbers* in the file are not supported.** @since 1.2*/Java版本对应的Class版本号Java版本Class版本JDK1.0.245.0~45.3JDK1.145.0~46.0以下J2SE1.246.0J2SE1.347.0J2SE1.448.0JavaSE549.0JavaSE650.0JavaSE751.0JavaSE852.0解决方法把类重新用当前的jdk版本去编译，只要确保jvm的版本比类版本号相同或更高就可以了。参考链接Class版本号和Java版本对应关系]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何正确地打印异常堆栈信息]]></title>
    <url>%2Fposts%2Fea188909.html</url>
    <content type="text"><![CDATA[前言最近老大让我修改项目里所有和log有关的代码，之前我也用过log4j、slf4j或者Logback等日志框架/接口，一直以为打印异常信息就是简单地一句log.info()或者log.error()而已，没想到原来一直都使用错了，以至于有些错误信息没能在log文件中打印出堆栈信息，最终难以定位bug，排查困难。如何正确地打印异常的堆栈信息？一般在catch到异常的时候，不要使用e.printStackTrace()来打印异常信息。我们使用日志框架来打印信息，一般来说，日志框架的log级别从低到高是：debug, info, warn, error, fatal。对于异常，一般使用log.error()来打印堆栈信息。下边的三个log语句都打印了异常，但是写法却不一样，打印出来的效果也是不同的：123log.error(&quot;ERROR&quot;, &quot;Error found: &quot;, e);log.error(&quot;ERROR&quot;, &quot;Error found: &quot; + e.getMessage());log.error(&quot;ERROR&quot;, &quot;Error found: &quot; + e);以下边的代码为例：1234567try &#123; System.out.println(1/0);&#125; catch (final Exception e) &#123; log.error(&quot;ERROR&quot;, &quot;Error found: &quot;, e); log.error(&quot;ERROR&quot;, &quot;Error found: &quot; + e.getMessage()); log.error(&quot;ERROR&quot;, &quot;Error found: &quot; + e);&#125;在log文件中可以发现输出是这样的：123452018-11-09 11:46:34,834 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero at com.lewis.test.TestLewis.main(TestLewis.java:46)2018-11-09 11:46:34,837 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: / by zero2018-11-09 11:46:34,838 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero对于第一个log语句，可以看到堆栈信息被打印了出来。对于第二个log语句，只是打印出了异常的具体信息，既没有异常类名，也没有堆栈信息。对于第三个log语句，打印出了异常的类名和具体信息，但是没有打印出来堆栈信息。总结一下，就是我们应该使用第一种log语句的形式来将堆栈信息打印出来，方便日后定位bug，排除错误。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven - settings.xml里的offline节点的作用]]></title>
    <url>%2Fposts%2Fc6f35a05.html</url>
    <content type="text"><![CDATA[场景某天我在本地修改了某个子项目的代码，并进行了打包：mvn clean install -DskipTests，接着我运行父项目却发现自己刚刚的改动并没有生效，或者说，我刚刚打包好的子项目变回了打包前的代码。通过cmd的输出我发现在运行父项目的时候，自动下载更新了远程依赖库的子项目，因此将我本地打包修改好的子项目依赖给更新成了远程库的，这就是为什么我明明打包了本地修改好的子项目代码却没有在父项目生效的原因。解决方法在maven的配置文件settings.xml里有个offline节点，可以通过该节点来控制是否在编译项目时自动下载远程依赖库的最新版本。注意，如果你同时有多个配置文件，必须要修改~/.m2下的settings.xml才有效。1234567&lt;!-- offline| Determines whether maven should attempt to connect to the network when executing a build.| This will have an effect on artifact downloads, artifact deployment, and others.|| Default: false&lt;offline&gt;false&lt;/offline&gt;--&gt;将配置文件里的offline节点的注释去掉并改为true，或者自己加一个：1&lt;offline&gt;true&lt;/offline&gt;当然，这样做只是为了方便本地测试而已，如果测试完毕不需要再改代码了，最好还是将该节点改为false，否则你如果在pom文件里引入了本地仓库所没有的依赖时，是不会自动帮你从远处库下载依赖的！！相关的问题offline可能会导致启动mvn项目时报错：1Caused by: org.eclipse.aether.transfer.ArtifactNotFoundException: Cannot access spring-releases (https://repo.spring.io/libs-release) in offline mode and the artifact org.springframework.boot:spring-boot-loader-tools:jar:2.0.5.RELEASE has not been downloaded from it before.因为offline mode导致无法从线上仓库下载依赖，将offline的值改为false就行了。]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis - Windows平台下怎么切换db并且清理数据]]></title>
    <url>%2Fposts%2Fb6751edd.html</url>
    <content type="text"><![CDATA[Redis 本身支持16个数据库(0~15)，通过 数据库id 设置，默认为0。在Windows平台下可以通过启动redis-cli.exe来进入客户端，客户端默认连接数据库0，在客户端里可以输入各种命令。增加db数量可以通过修改配置来增加Redis的db数量。在Windows平台下，打开redis.windows.conf，找到databases 16并修改即可。切换db通过命令来切换当前的db：select 0，该命令表示切换到第一个数据库。数据库id是从0到15，可以自由切换db，每个db的存储空间是不一样的。当切换db成功时，可以看到当前是使用的哪一个db：123127.0.0.1:6379&gt; SELECT 2OK127.0.0.1:6379[2]&gt;清理当前db数据1flushdb该命令只会清理当前db的数据，不会影响到其他db。清理所有db数据1flushall该命令会将当前的Redis实例的所有数据都清理掉，慎用！参考链接redis 中如何切换db]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat日志文件的输出在Linux和Windows下的差异]]></title>
    <url>%2Fposts%2F5ee24a02.html</url>
    <content type="text"><![CDATA[前言最近老大发现Tomcat的日志文件catalina.out里存在着大量的和公司项目相关的log信息，因为一般都是会使用日志框架并另外将log信息输出到另外的文件里的，catalina.out文件里就不需要这些多余的log信息了。不过我在测试的时候发现，Linux和Windows下catalina.out文件的输出是有区别的。在Linux和Windows下的差异在Windows平台下，所有System.out, System.err以及printStackTrace()输出的log信息都会在Tomcat的控制台(console，就是通过startup.bat启动的命令行窗口)里输出，但是并不会被输出到catalina.out里。而在Linux平台，上述的api会把信息输出到catalina.out里。而企业项目一般都是部署在Linux平台上的，日积月累之下catalina.log文件将会变得异常庞大，拖累系统性能，也不利于定位bug，可以通过修改日志配置文件改变存储策略。参考链接*. Tomcat日志输出在linux和windows差异]]></content>
      <categories>
        <category>中间件</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>中间件</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git - Merge: refusing to merge unrelated histories]]></title>
    <url>%2Fposts%2Ff25652af.html</url>
    <content type="text"><![CDATA[场景我在本地有个代码仓库local-A，本地仓库local-A已经和一个远程仓库remote-A关联了。接着我又在GitHub上新建了一个仓库remote-B，我希望将本地仓库local-A的本地dev分支push到这个新建的远程库remote-B。我的想法是这样的：在本地仓库local-A里添加刚刚新建的远程库remote-B检出(check out)并切换到remote-B的master分支将本地dev分支merge到当前的master分支解决可能发生的冲突后，将改动全部commit并push到远程库remote-B的master分支上接着当我做到第三步的时候，发现报错如下：1Merge: refusing to merge unrelated histories看到报错，我又重新操作了一遍，依然是同样的错误。记得以前我也做过类似的操作，但是却没有现在的问题，百度了下，发现可能是git升级之后造成的。解决方案因为两个仓库是不同的项目(本地仓库已经跟踪了另外一个远程库了)，git默认不允许不相干的项目进行push等操作。如果想要进行这些操作，就需要加入--allow-unrelated-histories参数才可以合并两个不同的项目：1git merge --squash dev --allow-unrelated-histories这句命令表示将dev分支合并到当前分支，这里的两个本地分支各自追踪不同的远程库，需要加入--allow-unrelated-histories参数才能够完成合并操作而不报错，至于--squash参数是为了压缩dev分支原本的commit历史，可以将原本所有的commit历史合成一个commit，以避免当前分支在合并之后掺入了其他项目的commit历史。参考链接如何去解决fatal: refusing to merge unrelated historiesgit merge –no-ff是什么意思]]></content>
      <categories>
        <category>版本控制工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - lombok的@Slf4j和@Data无效]]></title>
    <url>%2Fposts%2Feea0b72e.html</url>
    <content type="text"><![CDATA[问题与分析最近开始学习spring-boot框架，我用的是Eclipse，然后发现在使用到了lombok的@Data注解时，Eclipse会编译错误。@Data的作用是自动生成toString方法和setter/getter方法，可以减少大量重复性的代码工作。另外在使用了@Slf4j注解时，这个注解可以自动为当前类生成一个log变量，即：rivate final Logger logger = LoggerFactory.getLogger(XXX.class);。然而Eclipse无法识别log变量，会报log变量未声明的错误。一开始我以为是没导入包或者漏了jar包，但是检查一番后没有问题。百度了下才知道，原来除了导包之外，还需要为Eclipse安装该lombok插件。解决方法安装方法很简单，找到你导入的lombok的jar包，双击运行该jar包，会出现一个安装界面。或者右键jar包，选择打开方式，接着选择Java (TM) Platform SE binary，会出现安装界面。在安装界面选择当前的Eclipse进程，或者点击左下角的Specify location...选择你要安装插件的Eclipse，接着点右下角的Install / Update，很快就安装完毕，点击Quit Installer。lombok的下载地址：https://projectlombok.org/downloads/lombok.jar问题补充当我安装好lombok之后，Eclipse虽然能够正常识别@Slf4j注解生成的log变量，但@Data注解依然无效。在使用到了pojo类的私有变量时，依然会提示说缺少setter/getter方法。折腾了好久，才发现原来是因为Eclipse自动给我的pojo类的私有变量加上final修饰符，导致setter/getter方法注入失败了。把pojo类的私有变量前边的final去掉后，@Data终于生效了。之所以会自动给变量加上final修饰符，是因为我设置了Save Action，Eclipse会自动在我保存代码的时候自动在私有变量、局部变量前加上final修饰符，这个是公司制定的代码编程规范。]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - Template render error unexpected token]]></title>
    <url>%2Fposts%2F2a5ffb7e.html</url>
    <content type="text"><![CDATA[问题与分析今天发现在使用hexo g时报错如下：12FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: unexpected token: &#125;&#125;一时间很诧异，因为前几天还可以正常生成静态文件，今天忽然就挂了。看看报错的信息，说是模板渲染失败，因为出现了预期外的标志。因为我刚刚写了新的文章，就出现了这个错误，可以想象到，应该是文章中出现了特殊字符导致hexo命令执行失败了。百度了下，确实如此。因为在Hexo中，有些特殊字符如果不进行转义的话，在渲染模板时就会报错。解决方法如果遇到类似的报错，解决方法很简单，就是对这些特殊字符进行转义，需要使用转义标签来将这些特殊字符包括起来，如下：123&#123;% raw %&#125;特殊字符&#123;% endraw %&#125;比如我的报错是因为使用}}，那么就需要对这对大括号进行转义：123&#123;% raw %&#125;&#123;&#123; something... &#125;&#125;&#123;% endraw %&#125;如果是在引用块里，可以随便使用特殊字符；如果是行内引用块，就需要进行转义了。参考链接Hexo的一个小BUG(Template render error)Hexo 异常 - Template render error unexpected token]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS - 入门小Demo]]></title>
    <url>%2Fposts%2F69c71fa6.html</url>
    <content type="text"><![CDATA[AngularJS四大特效MVC模式、模块化设计、自动化双向数据绑定、依赖注入如果了解了后端开发知识，想必对这些词汇不会陌生，AngularJS融合了后端开发的一些思想，虽然身为前端框架，但与jQuery框架却是完全不相同的东西。AngularJS分为几个模块，需要使用哪个模块的功能，就直接引入对应的模块，这种模块化设计具备高内聚、低耦合的特点。官方提供的模块有：ng、ngRoute、ngAnimate用户也可以自定义模块：angular.module(‘模块名’, [])这里的ng是引擎engine的缩写，类似于Nginx的Ngin也是engine的缩写(谐音？)Demo1 - 表达式在当前目录下新建一个demo-1.html文件，并将angular.min.js文件放置在同一目录下。123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-1 表达式&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;&#123;&#123;100+100&#125;&#125;&lt;/body&gt;&lt;/html&gt;通过在html中引入angular.min.js，并在body标签中加入ng-app指令，则会对{{}}里的表达式进行计算。双击打开这个html文件，会发现页面显示的是200，如果不加载ng-app指令，页面显示的则是{{100+100}}。Demo2 - 双向绑定1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-2 双向绑定&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入姓名：&lt;input ng-model="name"&gt;&lt;br&gt;请输入姓名：&lt;input ng-model="name"&gt;&lt;br&gt;&#123;&#123;name&#125;&#125;&lt;/body&gt;&lt;/html&gt;通过ng-model来绑定变量，双击上边的页面文件，在任意一个输入框中输入字符，都会影响到绑定同一变量的标签元素。比起用js或者jQuery来实现这个功能，AngularJS的写法要简单快捷很多。Demo3 - 初始化指令12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-3 初始化指令&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app ng-init="name='JOJO'"&gt;请输入姓名：&lt;input ng-model="name"&gt;&lt;br&gt;&#123;&#123;name&#125;&#125;&lt;/body&gt;&lt;/html&gt;通过ng-init指令来对变量进行初始化，比如上边的html页面，在打开或刷新后，name变量的值会被初始化为JOJO。Demo4 - 控制器12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-4 控制器&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module("myApp", []); //创建控制器 app.controller("myController", function($scope)&#123; $scope.add = function() &#123; return parseInt($scope.x) + parseInt($scope.y); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" ng-controller="myController"&gt;第一个数：&lt;input ng-model="x"&gt;&lt;br&gt;第二个数：&lt;input ng-model="y"&gt;结果：&#123;&#123;add()&#125;&#125;&lt;/body&gt;&lt;/html&gt;自定义一个模块，为模块创建一个控制器，控制器里可以定义一些逻辑来处理绑定的变量。这里的控制器也有个参数$scope，这个参数表示作用域，可以通过该作用域来获取操作变量，它就是视图层和控制层交互数据的桥梁。更多和$scope相关的，可以了解下这篇文章关于AngularJS学习整理—浅谈$scope(作用域) 新手必备！。Demo5 - 事件指令1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-5 事件指令&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module("myApp", []); //创建控制器 app.controller("myController", function($scope)&#123; $scope.add = function() &#123; return $scope.z = parseInt($scope.x) + parseInt($scope.y); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" ng-controller="myController"&gt;第一个数：&lt;input ng-model="x"&gt;&lt;br&gt;第二个数：&lt;input ng-model="y"&gt;&lt;button ng-click="add()"&gt;运算&lt;/button&gt;&lt;br&gt;结果：&#123;&#123;z&#125;&#125;&lt;/body&gt;&lt;/html&gt;ng-click表示事件指令，类似于js里的绑定事件的用法。Demo6 - 循环数组123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-6 循环数组&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module("myApp", []); //创建控制器 app.controller("myController", function($scope)&#123; $scope.list = [101, 252, 345, 836]; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" ng-controller="myController"&gt; &lt;table&gt; &lt;tr ng-repeat="x in list"&gt; &lt;td&gt;&#123;&#123;x&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;使用ng-repeat来循环数组，类似于foreach的遍历操作。Demo7 - 循环对象数组(JSON)1234567891011121314151617181920212223242526272829303132333435&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-7 循环对象数组&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module("myApp", []); //创建控制器 app.controller("myController", function($scope)&#123; $scope.list = [ &#123;name:'张三', math:99, chinese:88&#125;, &#123;name:'李四', math:17, chinese:46&#125;, &#123;name:'赵五', math:60, chinese:60&#125; ]; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" ng-controller="myController"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat="entity in list"&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.math&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.chinese&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;实际应用中前后端一般通过JSON对象来交互，和上边的demo类似。Demo8 - 内置服务$http前端数据一般从后端获得，我们一般使用AngularJS的内置服务$http来获取后端数据，下边的demo需要在容器中运行(比如Tomcat)。首先建立一个demo-8.html文件，将页面和angular.min.js一起放置到web项目的webapp目录下。1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt;&lt;head&gt; &lt;title&gt;AngularJS入门小Demo-8 内置服务$http&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module("myApp", []); //创建控制器 app.controller("myController", function($scope, $http)&#123; $scope.findList = function() &#123; $http.get("data.json").success( function(response) &#123; $scope.list = response; &#125; ); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" ng-controller="myController" ng-init="findList()"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat="entity in list"&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.math&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.chinese&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;接着在同一目录下，新建一个data.json文件，内容如下：12345[ &#123;"name":"张三", "math":99, "chinese":88&#125;, &#123;"name":"李四", "math":17, "chinese":46&#125;, &#123;"name":"赵五", "math":60, "chinese":60&#125;]需要注意的是，在.json文件中的数据必须严格遵守JSON的规范，所有key必须使用双引号，value除了数值型以外的类型也必须使用双引号。在Demo7中由于是在js中书写的，所以可以不必遵守严格的JSON格式。另外可以看到，这个$http的用法和AJAX很相似，其实其内部就是封装的AJAX。本文最后附上所有demo源码，demo-8在里边的web项目里。可以通过mvn tomcat7:run来启动该web项目(或者双击源码里的start.bat来启动项目)，接着在浏览器地址栏输入localhost:8080/demo-8.html，即可得到该JSON数据。项目相关GitHub地址下载地址]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端框架</tag>
        <tag>AngularJS</tag>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[foreach循环报NPE空指针异常]]></title>
    <url>%2Fposts%2Ffba3f254.html</url>
    <content type="text"><![CDATA[前言最近debug时忽然发现，如果一个集合赋值为null，那么对该集合进行foreach循环(也叫增强for循环)时，会报NPE(即空指针异常NullPointerException)。代码如下：12345final List&lt;String&gt; list = null;// final List&lt;String&gt; list = new ArrayList&lt;&gt;();for (final String string : list) &#123; System.out.println(string);&#125;运行时报错如下：12Exception in thread &quot;main&quot; java.lang.NullPointerExceptionat com.lewis.test.TestLewis.main(TestLewis.java:42)一时间很惊奇，因为在我印象中，foreach循环在遇到null的集合时，应该是会自动跳过去不进行遍历的才对。于是修改代码如下：12345//final List&lt;String&gt; list = null;final List&lt;String&gt; list = new ArrayList&lt;&gt;();for (final String string : list) &#123; System.out.println(string);&#125;运行后发现没有报错，看来是以前记错了。foreach循环只会自动跳过遍历空的集合，如果对于null值的集合，就会直接报NPE。解决方法在写业务逻辑时难免会遇到遍历集合的情况，这时候应该先判断集合是否为null再进行遍历，可以使用Apache的工具类CollectionUtils。另外补充下，foreach循环内部是使用的迭代器来遍历，也就是说，这种遍历方式和使用迭代器来遍历是一样的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌套循环的优化]]></title>
    <url>%2Fposts%2Ffe753197.html</url>
    <content type="text"><![CDATA[需求背景今天拿到这样一个需求：有Map A和Map B，这两个Map都持有着一个同样的key——id，其对应的value可能相同，也可能不相同。现在需要对两个Map中该key对应的value相同的键值对做些特殊的操作。这是个很简单的需求，代码很简单，我直接一个循环里嵌套另一个循环去实现这个功能需求：123456for(Map.Entry&lt;String, String&gt; entry : mapA.entrySet()) &#123; //do something，需要循环10次 for(Map.Entry&lt;String, String&gt; entry : mapB.entrySet())&#123; //do something，需要循环1000次 &#125;&#125;写的时候也没有考虑太多，提交代码给组长review的时候，组长表示这里的循环嵌套这样写不好，因为在实际业务中，集合B会比较大，假设mapA的size是10，mapB的size是1000，这样写就需要循环10*1000次，毕竟循环的时候需要进行一系列操作，假如有很多人同时通过ui来触发这段逻辑，就可能存在性能上的问题，对于用户来说，如果点击ui上的一个按钮需要等待个十来秒才有结果，那简直是毁灭性的用户体验。所以遇到这种需要嵌套循环的时候，应该尽量减少循环的次数；此外，一般情况下将大循环放到内部，将小循环放在外部，也会提高性能。一种优化思路根据组长的建议，我可以将内部的大循环的循环次数尽量降低，原本是n*m的总循环次数，可以根据业务需求尽量拆分成n+m的总循环次数。当然，不太可能真的拆分成n+m，只是尽量往这个方向靠拢。想要实现这个优化，就只能对内部的大循环进行分组。具体怎么分组呢？可以new一个新的map，然后按照id分组(这里是因为我的业务需求中id会重复，所以将id作为分组依据)。将id相同的数据分成一组，然后存放到一个ArrayList中；然后这个id作为key存入map里，而这个ArrayList则作为value存入map里。假设原本内部大循环的集合size是1000，我们将其分成了10组，而外部小循环的集合size是10，那么原本的101000总循环次数就可以变形成1000+1010次。如下：123456789for(Map.Entry&lt;String, String&gt; entry : mapB.entrySet())&#123; //先对大集合Map B进行分组，并存入一个Map C中，需要循环1000次&#125;for(Map.Entry&lt;String, String&gt; entry : mapA.entrySet()) &#123; //do something，需要循环10次 for(Map.Entry&lt;String, String&gt; entry : mapC.entrySet())&#123; //do something，需要循环10次 &#125;&#125;当然了，这种优化思路是在特定的功能需求下才能实现的，具体问题具体分析，因为组长的提醒，我才知道原来嵌套循环还可以这样来优化，代码之道果然是要日积月累才行。另外关于大循环在内小循环在外的写法的具体分析，可以看看这篇文章：for循环嵌套的效率可惜暂时我还看不懂。。]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd - 命令行窗口中文乱码]]></title>
    <url>%2Fposts%2F761efa7.html</url>
    <content type="text"><![CDATA[问题在cmd窗口中输入curl www.baidu.com可以看到有中文乱码的现象，这是因为默认使用的是GBK编码。另外，curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本，在win10的cmd中有内嵌curl。1234C:\Users\lewis.liu&gt;curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;鐧惧害涓€涓嬶紝浣犲氨鐭ラ亾&lt;/title&gt;&lt;/head&gt; ...解决方法在cmd窗口中输入：1CHCP 65001回车后重新输入上边的curl命令，会发现不再中文乱码。不过这种方法只对当前的cmd窗口有效果，如果退出当前窗口重新打开一次cmd，你会发现依然中文乱码。如果想要一次性解决这个问题，需要去修改注册表。这个方法这里就不说了，有兴趣的可以查看下边的参考链接。CHCP是一个计算机指令，能够显示或设置活动代码页编号。代码页 描述65001 UTF-8代码页950 繁体中文936 简体中文默认的GBK437 MS-DOS 美国英语可以通过右键cmd窗口，点击属性查看当前的活动代码页编码(Current Code Page)。参考链接windows下使用curl命令 &amp;&amp; 常用curl命令windows 控制台cmd乱码的解决办法]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
        <tag>计算机</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - N''和::bpchar]]></title>
    <url>%2Fposts%2Fdf5055d.html</url>
    <content type="text"><![CDATA[N’’和::bpchar的区别N’’的效果和::bpchar效果类似，都表示定长字符串。比如下边的sql：123select n'233' as num;select '233'::bpchar as num;select '233' as num;以上sql都会得到’233’的结果集，但是对于前两条sql拿到的字符串是bpchar类型，相当于MySQL的char类型；而第三条sql拿到的字符串是text类型。VARCHAR(n) varchar 指定了最大长度，变长字符串，不足定义长度的部分不补齐。CHAR(n) bpchar 定长字符串，实际数据不足定义长度时，以空格补齐。TEXT text 没有特别的上限限制（仅受行的最大长度限制）对于::bpchar，其实更多表示的是转型，比起N’’，还可以这样使用：12select 233 as num;select 233::bpchar as num;第一条sql拿到的是数值类型，第二条sql拿到的是字符串，233这个数值被转型成bpchar类型。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作系列(2) - 如何令文章目录显示序号]]></title>
    <url>%2Fposts%2F99e0f22b.html</url>
    <content type="text"><![CDATA[前言NexT主题会自动为每一篇文章生成目录，这个目录可以通过配置来控制是否生成对应的序号。毕竟有时候我们会给文章的小标题写上序号，有时候又会懒得去写，这个时候这个配置就很重要了。有两种方法来实现这个效果，一种是全局生效，一种是对具体某篇文章生效。全局生效在NexT的主题配置文件 _config.yml中启用如下配置：12345678# Table Of Contents in the Sidebar# 侧栏文章目录设置toc: enable: true # Automatically add list number to toc. # 自动为文章目录添加行号 number: true设置为true后就可以对站点下所有文章自动添加序号，如果想取消这个功能，再设置为false即可。对具体某篇文章生效如果你在文章的小标题中已经使用了序号，那么自动为文章目录添加序号的功能会导致你的文章目录出现了赘余的序号，解决方法很简单，在你的文章的文件头添加一行代码即可，如下：12345---title: XXXdate: XXXtoc_number: false---这样这篇文章就不会被自动添加序号到文章目录里了。]]></content>
      <categories>
        <category>Hexo</category>
        <category>写作系列</category>
      </categories>
      <tags>
        <tag>Hexo写作系列</tag>
        <tag>NexT主题</tag>
        <tag>NexT写作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作系列(1) - NexT主题自带的样式]]></title>
    <url>%2Fposts%2F38eb04fa.html</url>
    <content type="text"><![CDATA[前言本系列主要介绍和hexo-NexT主题相关的一些写作技巧，可能会涉及到部分前端知识(不了解也没关系，能用就行)。我之所以选择hexo-NexT来搭建个人网站，一个很重要的原因就是因为简单、方便、快捷！不需要服务器，直接通过Markdown来进行写作，不仅文章布局美观，还可以节省大量的时间。我一般不会在文章中手动加入各种html标签，因为太麻烦了–而NexT主题就很贴心地自带了一些样式，让你可以不需要自己写一大堆html标签就能得到美观的页面效果。本系列针对的是NexT 5.1.4版本的样式，请到我的个人站点更加直观地看到页面效果，不便之处还请见谅。-&gt;这是本文在个人站点的链接&lt;-文本居中引用该样式可以将一段文本居中显示，并在首尾各自生成一个引号图片，效果如下：人类的本质是复读机。——复读机源码如下：12345&#123;% cq %&#125;人类的本质是复读机。——**复读机**&#123;% endcq %&#125;原本该样式的字体是黑色的，我把它改成红色了。这里的cq是标签别名，也可以用完整的标签名：12345&#123;% centerquote %&#125;人类的本质是复读机。——**复读机**&#123;% endcenterquote %&#125;图片突破容器宽度限制使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。效果如下：附上一张wlop大大的saber~使用方式如下：1234&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125;这里的alt和title可以不写，alt属性是找不到图片时显示的文本，title是鼠标停留在图片上时显示的文本。Note标签本标签出自于Bootstrap，使用前需要先启用主题配置文件：12345678910111213141516171819# 主题自带的标签样式，有 note、label、tabs 三种# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. # Note标签的样式有四种： # - simple：默认的样式，也是Bootstrap Callout旧版本的样式。 # - modern：Bootstrap Callout新版本(v2-v3)的样式。 # - flat：该样式会连同背景也一起渲染，如同Mozilla或者StackOverflow那样。 # - disabled：禁用本Note标签。 style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0效果如下：defaultprimarysuccessinfowarningdangerNote标签一共有以上六种类型：default,primary,success,info,warning,danger，源码如下：123456&#123;% note default %&#125;default&#123;% endnote %&#125;&#123;% note primary %&#125;primary&#123;% endnote %&#125;&#123;% note success %&#125;success&#123;% endnote %&#125;&#123;% note info %&#125;info&#123;% endnote %&#125;&#123;% note warning %&#125;warning&#123;% endnote %&#125;&#123;% note danger %&#125;danger&#123;% endnote %&#125;Label标签使用前同样需要启用配置：12# Label tag.label: true效果如下：defaultprimarysuccessinfowarningdanger和Note标签一样，同样是六种类型。@前面是类型，@后面是显示的文本内容。这个label标签的样式并不好看，我基本不用。Tab标签这个标签和浏览器的tab是类似的，使用前也需要启用配置：1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 3效果如下：android开发吧java吧c++吧c语言神奇海螺有问题为什么不先问问隔壁Java吧呢？有问题为什么不先问问隔壁C++吧呢？有问题为什么不先问问隔壁C语言吧呢？有问题为什么不先问问神奇海螺吧呢？有问必答不知道源码如下：1234567891011121314151617&#123;% tabs 贴吧, 1 %&#125;&lt;!-- tab android开发吧 --&gt;有问题为什么不先问问隔壁Java吧呢？&lt;!-- endtab --&gt;&lt;!-- tab java吧 --&gt;有问题为什么不先问问隔壁C++吧呢？&lt;!-- endtab --&gt;&lt;!-- tab c++吧 --&gt;有问题为什么不先问问隔壁C语言吧呢？&lt;!-- endtab --&gt;&lt;!-- tab c语言 --&gt;有问题为什么不先问问神奇海螺吧呢？&lt;!-- endtab --&gt;&lt;!-- tab 神奇海螺 --&gt;有问必答不知道&lt;!-- endtab --&gt;&#123;% endtabs %&#125;简单介绍下常规用法：源码第一行的数字表示默认显示哪一个tab页面，如果是-1则表示隐藏所有tab页面内容。如果不为每个tab单独制定名字，则会以第一行源码的名字为每个tab命名，并自动在名字后加上1,2,3...以示区分。tab的名字支持fontawesome图标，使用方法是@加上图标的名字，例如@home，注意该图标需要添加在tab名字的最后，渲染时图标会自动放在名字最前面，比如：&lt;!-- tab android开发吧@home --&gt;我的about页面就使用了图标，可以去看看效果。更多用法可以参考该文章按钮标签样式这个样式和阅读全文那个按钮一样，效果如下：点击前往百度源码如下：1&#123;% btn https://www.baidu.com, 点击前往百度, download fa-lg fa-fw %&#125;更多用法可以参考该文章此外还有其他的标签样式的使用方法，请参考下边的连接文章。参考链接官方文档：内置标签 - NexT 使用文档打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化样式汇总]]></content>
      <categories>
        <category>Hexo</category>
        <category>写作系列</category>
      </categories>
      <tags>
        <tag>Hexo写作系列</tag>
        <tag>NexT主题</tag>
        <tag>NexT写作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(8) - 添加评论系统]]></title>
    <url>%2Fposts%2Fec12c039.html</url>
    <content type="text"><![CDATA[前言Hexo的NexT主题本身就集成了一些评论系统，多说啊之类的已经关闭服务的略过不提，目前比较多人用的有畅言、来必力livere、Gitment、Gitalk、Disqus等。我刚用的评论系统的时候，网易云跟贴和多说已经gg了，畅言需要备案，Disqus需要FQ，Gitment和Gitalk类似，都需要GitHub账号。经过搜集资料和考虑，我最终还是决定使用Gitment。只是在用了一段时间后，终于还是放弃了Gitment，转而使用来必力livere。Gitment的优缺点最初我选择使用Gitment的原因如下：Gitment是一个基于GitHub的issue来开发的评论插件，本身很有创意，对于我这种没事看看GitHub的也很有吸引力。使用Gitment进行评论需要有GitHub账号，这无形中过滤掉了一些评论者，毕竟不是谁都有GitHub账号的，也不是谁都能登陆上GitHub的。GitHub的评论数据存放在GitHub的issue里，基本不用担心数据丢失或者GitHub关闭服务，毕竟GitHub可是全球最大同性交友社区(滑稽)。当我美滋滋地享受了Gitment一段时间后，开始发现一些问题：GitHub是个神奇的网站，有时候会登陆不上去，这导致我的个人站点加载页面时无法把Gitment加载出来，这使得我的页面长时间处于一片空白的状态，用户体验极差，而且最后页面加载出来了，Gitment评论模块依然没有加载出来。我希望我的站点可以不分国界，所以我将站点分别部署到了Coding.net和GitHub上，这样可以国内外都快速访问到站点(这个需要域名才能实现)。由于国内有些地区在有些时段是无法访问到GitHub的，这将导致我的页面长时间假死。Gitment的使用太繁琐，每一篇文章都必须先初始化一遍，才能使用评论系统，如果你有一百篇文章，你就需要手动初始化一百次！虽然后来有脚本一键初始化，但还是很麻烦。issue的滥用。因为Gitment是建立的issue之上的，当你的文章越来越多，你会发现你的站点仓库里的issue会越来越多，这就不太友好了。综上所述，我还是放弃了Gitment，转投了来必力的怀抱。Gitment使用流程虽然现在没有使用Gitment了，但这里还是记录下当初遇到的问题，方便回顾或者大家解决类似的困难。安装模块使用Gitment需要安装模块：1npm i --save gitment申请应用ID与密钥因为Gitment需要GitHub的授权，所以需要先去New OAuth App申请一个密钥，需要填写的内容如下：1234Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址这里只有最后一个callback必须写准确，申请成功后你可以看到ClientID和Client Secret，这个会被使用到，另外注意不要把这个ID和密钥告诉别人–在主题配置文件中启用123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled这里的配置，只有github_user，github_repo，client_id，client_secret是必须填准确的，其他的可以不使用。初始化Gitment到这里为止已经全部配置完毕，接下来只需要登陆你的个人站点，然后手动给每篇文章初始化Gitment就行了。初始化也很简单，打开每篇文章，在下方的评论模块那里点一下初始化就行，以后就可以直接评论了。据说由一键初始化所有文章的脚本，我没用过，不清楚。Gitment踩坑记录这里说一下当初折腾了我很久的一个地方，在主题配置文件里有个github_user，这个由于注释写的是Your Github ID，我误以为是要填写的不是用户昵称，而是一串数字id。于是就去了GitHub的api里查看了自己的id，然后填了一串数字进去，之后花费了我几个小时的时间，始终有授权失败的错误，最后终于发现，这个ID其实是要填的用户昵称…orzGitHub的api地址：https://api.github.com/users/xxx把这里的xxx随便改成某个用户名，可以拿到对方的json数据，里边有各种用户首页上的数据信息。更多Gitment踩坑相关的文章可以参考：Gitment评论功能接入踩坑教程来必力livere的使用来必力的使用就简单多了，直接去官网注册个账号，拿到来必力City版安装代码里的data-uid，把这个uid填写到主题配置文件里的livere_uid后就行，记得id要和前边的冒号之间有一个空格，否则在启用hexo服务的时候会解析出错。这样我们的来必力就使用成功了，平时可以去来必力的后台系统查看站点的评论数据等。如果不会注册安装来必力的，可以看看这篇文章参考链接Hexo 使用Gitment评论功能Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件添加网易云跟帖(跟帖关闭，已失效，改为来必力)]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误]]></title>
    <url>%2Fposts%2F7ac531d2.html</url>
    <content type="text"><![CDATA[问题今天我的个人站点SSL/TLS证书到期，我的证书是由Coding Pages提供的，每次申请成功后有效期是三个月，证书到期后可以继续免费申请。但是当我登陆进入Coding Pages服务的后台并点击申请证书时，竟然报错了！！我重新点了申请，几秒后依然报错，并提示我半小时只能申请一次。我查看了下报错的提示信息，如下：urn:acme:error:unauthorized:Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx一时间也不明白是怎么回事，因为我第一次申请的时候不用几秒钟就成功了，由于报错信息中包含了本静态博客的部署时间，我以为可能存在部署时间的校验，于是重新部署了一下，半小时后继续申请，依然报同样的错误。好吧，有事就问度娘，百度了一下，发现了Coding Pages的官方文件：Coding Pages 常见问题这时候按照官方文件的指引，找到了和我一样的错误信息的解决方案：错误原因：无法获取正确的域名验证信息解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器因为Coding Pages的静态Pages是免费的，而动态Pages是收费的，对于用Hexo搭建的静态站点，自然是选择免费的静态Pages服务就足够了。于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。分析由于我的个人站点是同时部署到GitHub Pages和Coding Pages上的，接着在阿里云域名解析里进行了配置：默认的解析线路将我的域名指向pages.coding.me，国外的解析路线则是指向了lewky.github.io。之所以这样配置，是因为国内部分地区无法直接访问GitHub，自然就无法访问我部署在GitHub上的个人站点，于是我又选择了Coding.net的Pages服务，这样国内用户就可以快速访问到我部署在Coding Pages的个人站点，而国外用户则是快速访问到Coding Pages上的个人站点。问题就出现在这里，因为我第一次申请SSL/TLS证书的时候，还没有解析境外的线路，所以很快就申请成功了。后来添加了国外线路的解析，这导致在Coding Pages的后台申请证书时无法通过验证，自然就申请失败了。分析到这里，我也基本知道怎么解决这个错误了。解决方法由于我是在阿里云购买的域名，于是登陆到阿里云域名解析的后台系统，打开个人域名的解析设置，暂停对于境外线路的解析。这里暂停就行了，一般来说大概需要5分钟左右的生效时间，毕竟DNS解析是存在缓存的。五分钟后，我又进入Coding Pages服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后我申请证书成功，又给续了三个月。最后，再次返回阿里云域名解析的后台，将境外解析的线路再次启用，嗯，完美。其他的申请错误这里罗列下申请证书时所有可能遇到的错误与解决方案，以备不时之需。错误类型：urn:acme:error:connection1、错误信息：DNS problem: NXDOMAIN looking up A for example.com错误原因：域名不存在解决方式1：检查域名是否填写正确解决方式2：到域名注册商处检查是否设置了 DNS 服务器解决方式3：咨询 DNS 服务商是否支持解析该域名2、错误信息：DNS problem: SERVFAIL looking up A for exmaple.com错误原因：DNS 解析 A 记录出错解决方式1：到域名注册商处检查是否设置了 DNS 服务器解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求3、错误信息：DNS problem: SERVFAIL looking up CAA for example.com错误原因：DNS 解析 CAA 记录出错解决方式1：到域名注册商处检查是否设置了 DNS 服务器解决方式2：咨询 DNS 服务商是否支持解析 CAA 记录4、错误信息：DNS problem: query timed out looking up A for exmaple.com错误原因：DNS 解析超时解决方式1：到域名注册商处检查是否设置了 DNS 服务器解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求解决方式3：重新申请解决方式4：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器5、错误信息：Fetching http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxx错误原因：获取域名验证信息失败解决方式1：重新申请解决方式2：请确认是否启动了 DNS 的分区解析。如果有则要把国外的解析记录也设置成 CNAME 至 pages.coding.me。SSL 证书是通过 Let’s Encrypt API 申请。申请证书前需要验证域名，而 Let’s Encrypt 位于国外，所以需要保证 Let’s Encrypt 能通过您的域名正常访问到 Coding Pages 服务器以读取验证信息。错误类型：urn:acme:error:malformed错误信息：Error creating new authz :: Name does not end in a public suffix错误原因：域名不以公共后缀结尾解决方式：咨询域名注册商错误类型：urn:acme:error:unauthorized1、错误信息：Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx错误原因：无法获取正确的域名验证信息解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器2、错误信息：The key authorization file from the server did not match this challenge错误原因：无法获取正确的域名验证信息解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器3、错误信息：Error creating new authz :: “example.com” was considered an unsafe domain by a third-party API错误原因：无法获取正确的域名验证信息解决方式：使用 https://transparencyreport.google.com/safe-browsing/search 查看域名存在的安全隐患，按照说明进行清理，清理完后到 https://www.stopbadware.org/ 提交审查请求。审查通过后，回到 Coding Pages 重新申请证书错误类型：urn:acme:error:unknownHost错误信息：No valid IP addresses found for example.com错误原因：找不到可用 IP 地址解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器解决方式3：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求错误类型：urn:acme:error:rateLimited错误信息：Error creating new cert :: too many certificates already issued for exact set of domains: example.com错误原因：证书申请数目超出限制解决方式：下周再重新申请，详情见 https://letsencrypt.org/docs/rate-limits/错误类型：urn:acme:error:rejectedIdentifier错误信息：Error creating new authz :: Policy forbids issuing for name错误原因：相关政策禁止为此域名签发证书参考链接Coding Pages的官方文件：Coding Pages 常见问题]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css - 单词的自动换行问题]]></title>
    <url>%2Fposts%2F4d6b513d.html</url>
    <content type="text"><![CDATA[转载自：解决文档中有url链接时被强制换行的问题问题当行内出现很长的英文单词或者url的时候，会出现自动换行的问题，为了美化页面，往往会希望这些很长的英文单词或者url能够断开来，超出的部分换行到下一行。解决方案可以通过使用两个属性来实现该需求：12word-wrap:break-word;word-break:break-all;word-wrapword-wrap用来控制换行，有两种取值：normalbreak-word（此值用来强制换行，内容将在边界内换行，中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。）word-breakword-break用来控制断词，有三种取值：normalbreak-all（是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。）keep-all（是指Chinese, Japanese, and Korean不断词，一句话一行，可以用来排列古诗哟~）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - Maven项目Update Project后jdk版本变成1.5]]></title>
    <url>%2Fposts%2F519a131c.html</url>
    <content type="text"><![CDATA[问题与分析最近遇到个奇怪的问题，在Eclipse里对一个Maven项目进行Update Project(快捷键是 Alt+F5)，原本jdk为1.8的项目忽然就变成了1.5，于是就报了一些错误。我猜想可能跟Maven默认的jdk版本有关系，百度了下，确实如此，Maven项目如果不指定编译的jdk版本，就会默认为jdk1.5。查了下项目的pom文件，里边并没有指定编译的jdk版本，而Maven的配置文件settings.xml里也没有指明jdk版本，所以当我Update Project后，这个Maven项目就会自动变成jdk1.5了。解决方法有两种解决方法，一种是针对某个Maven项目而言，直接在pom文件中指明jdk版本；一种是全局设置，为所有Maven项目指明jdk版本。在pom文件中指明jdk版本在项目的pom.xml中的build节点里使用maven的编译插件来指定jdk版本，项目中通常使用这种方法来指定，因为比较灵活，可以随意指定版本，修改保存后即可生效。1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;修改settings.xml文件找到Maven的安装路径，打开conf\settings.xml，找到profiles节点，在该节点下添加一个profile节点：123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt;使用这种方法的好处是所有Maven项目都会按照这里的jdk版本来编译，当然如果在pom文件里也指定了jdk版本，则以pom里的为准。这种全局修改的方法必须要重启Eclipse才有效果。个人建议就算是修改了全局配置，也要在每个Maven项目里指明jdk版本，这是种良好的规范，利于别人理解。参考链接maven 修改默认的JDK版本Maven管理项目的时候 Update Project后jre变成1.5]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UltraEdit - 怎么显示文件标签栏和侧边栏]]></title>
    <url>%2Fposts%2Fa39d8a42.html</url>
    <content type="text"><![CDATA[显示文件标签栏view -&gt; views/lists -&gt; open Files Tabs显示侧边栏view -&gt; views/lists -&gt; File Tree View参考链接ultraEdit打开多个页面时 怎样显示页面标签]]></content>
      <categories>
        <category>常用软件</category>
        <category>文本编辑器</category>
      </categories>
      <tags>
        <tag>常用软件</tag>
        <tag>文本编辑器</tag>
        <tag>UltraEdit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过split命令分割大文件]]></title>
    <url>%2Fposts%2F54434588.html</url>
    <content type="text"><![CDATA[场景线上出了问题，我需要去查找log来定位问题，但是由于线上数据量庞大，这些log文件每过一个小时就会自动回滚一次，尽管如此，有的log文件依然达到了五六g以上的大小。对于这种巨大的log文件，常用的一些文本编辑器诸如EditPlus、Notepad++就不用说了，打开几百m的文件都会很卡，上g的直接程序崩溃。虽然UltraEdit对于大文件的读取会友好一些，但打开这种五六g的文件时也会陷入长时间的无响应状态。后来我又得知了一个看log神器——glogg，打开五六g的大文件速度很快，但是有个问题，就是只能读取文件，不能编辑文件。毕竟我不只是要查看log，有时候还要对这些有用的log信息进行编辑。最后还是决定先把大文件分割成数个小文件，再用UltraEdit来查看这些文件。使用split命令分割大文件在Linux下，切割和合并文件可以使用split和cat命令来实现。在Windows下，安装Git Bash也可以使用split和cat命令。分割文件的命令是split，通过输入split --help可以查询帮助信息。假设现在有个6GB大小的文件test.log，这里简单介绍下几种分割的方式：按大小分割文件1split -b 1000000000 test.log-b参数表示按字节大小进行分割，在数字后边要指定被分割的文件名。这里在输入文件名时有个小技巧，可以直接把该文件拖动到cmd窗口中，会自动输入该文件的具体目录。这里的文件还可以使用通配符，比如split -b 1000000000 *。这个命令表示按1000000000byte的大小进行分割，近似于1GB，大概是953MB的大小。对于这个6GB大小的文件test.log，会被分割成6个小文件。这些小文件的命名是有规律的：xaa、xab、xac、xad、xae、xaf。如果你分割了非常多的小文件，当文件名到了xyz之后，会变成xzaaa、xzaab、xzaac、xzaad……所以不用担心小文件过多而导致文件重名什么的。当然，上边的这种写法不够人性化，我们可以使用其他的单位来指定分割的大小：k、m。k表示KB，m表示MB。split -b 100k test.log表示将test.log按照100KB的大小进行分割。split -b 100m test.log表示将test.log按照100MB的大小进行分割。按照所有行数加起来的最大字节数进行分割1split -C 100k test.log-C参数表示按照所有行数加起来的最大字节数进行分割，同样可以使用k或者m作为单位，其实效果和上边的-b差不多，只是在切割时将尽量维持每行的完整性。按照行数进行分割12split -l 1000 test.logsplit -1000 test.log-l参数表示按照行数进行分割，即一个小文件中最多有多少行，-l number可以缩写成-number，上边的命令表示按照1000行一个小文件进行分割。注意点这三种分割的方式不能混合使用，如下：1split -l 3000 -C 100k *会报错split: cannot split in more than one way。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令英文全称]]></title>
    <url>%2Fposts%2F84a6a4d.html</url>
    <content type="text"><![CDATA[转载自：Linux命令英文全称Linux命令英文全称su：Swith user 切换用户，切换到root用户cat: Concatenate 串联uname: Unix name 系统名称df: Disk free 空余硬盘du: Disk usage 硬盘使用率chown: Change owner 改变所有者chgrp: Change group 改变用户组ps：Process Status 进程状态tar：Tape archive 解压文件chmod: Change mode 改变模式umount: Unmount 卸载ldd：List dynamic dependencies 列出动态相依insmod：Install module 安装模块rmmod：Remove module 删除模块lsmod：List module 列表模块alias :Create your own name for a commandbash :GNU Bourne-Again Shell linux内核grep:global regular expression printhttpd :Start Apacheipcalc :Calculate IP information for a hostping :Send ICMP ECHO_Request to network hostsreboot: Restart your computersudo:Superuser do/bin = BINaries/dev = DEVices/etc = ETCetera/lib = LIBrary/proc = PROCesses/sbin = Superuser BINaries/tmp = TeMPorary/usr = Unix Shared Resources/var = VARiable ?FIFO = First In, First OutGRUB = GRand Unified BootloaderIFS = Internal Field SeperatorsLILO = LInux LOaderMySQL = My最初作者的名字SQL = Structured Query LanguagePHP = Personal Home Page Tools = PHP Hypertext PreprocessorPS = Prompt StringPerl = “Pratical Extraction and Report Language” = “Pathologically Eclectic Rubbish Lister”Python Monty Python’s Flying CircusTcl = Tool Command LanguageTk = ToolKitVT = Video TerminalYaST = Yet Another Setup Toolapache = “a patchy” serverapt = Advanced Packaging Toolar = archiveras = assemblerbash = Bourne Again SHellbc = Basic (Better) Calculatorbg = BackGroundcal = CALendarcat = CATenatecd = Change Directorychgrp = CHange GRouPchmod = CHange MODechown = CHange OWNerchsh = CHange SHellcmp = comparecobra = Common Object Request Broker Architecturecomm = commoncp = CoPycpio = CoPy In and Outcpp = C Pre Processorcups = Common Unix Printing Systemcvs = Current Version Systemdaemon = Disk And Execution MONitordc = Desk Calculatordd = Disk Dumpdf = Disk Freediff = DIFFerencedmesg = diagnostic messagedu = Disk Usageed = editoregrep = Extended GREPelf = Extensible Linking Formatelm = ELectronic Mailemacs = Editor MACroSeval = EVALuateex = EXtendedexec = EXECutefd = file descriptorsfg = ForeGroundfgrep = Fixed GREPfmt = formatfsck = File System ChecKfstab = FileSystem TABlefvwm = F*** Virtual Window Managergawk = GNU AWKgpg = GNU Privacy Guardgroff = GNU troffhal = Hardware Abstraction Layerjoe = Joe’s Own Editorksh = Korn SHelllame = Lame Ain’t an MP3 Encoderlex = LEXical analyserlisp = LISt Processing = Lots of Irritating Superfluous Parenthesesln = LiNklpr = Line PRintls = listlsof = LiSt Open Filesm4 = Macro processor Version 4man = MANual pagesmawk = Mike Brennan’s AWKmc = Midnight Commandermkfs = MaKe FileSystemmknod = MaKe NODemotd = Message of The Daymozilla = MOsaic GodZILLamtab = Mount TABlemv = MoVenano = Nano’s ANOther editornawk = New AWKnl = Number of Linesnm = namesnohup = No HangUPnroff = New ROFFod = Octal Dumppasswd = PASSWorDpg = pagerpico = PIne’s message COmposition editorpine = “Program for Internet News &amp; Email” = “Pine is not Elm”ping = Packet InterNet Grouperpirntcap = PRINTer CAPabilitypopd = POP Directorypr = preprintf = PRINT Formattedps = Processes Statuspty = pseudo ttypushd = PUSH Directorypwd = Print Working Directoryrc = runcom = run command, shellrev = REVerserm = ReMovern = Read Newsroff = RunOFFrpm = RPM Package Manager = RedHat Package Managerrsh, rlogin, = Remoterxvt = ouR XVTsed = Stream EDitorseq = SEQuenceshar = SHell ARchiveslrn = S-Lang rnssh = Secure SHellssl = Secure Sockets Layerstty = Set TTYsu = Substitute Usersvn = SubVersioNtar = Tape ARchivetcsh = TENEX C shelltelnet = TEminaL over Networktermcap = terminal capabilityterminfo = terminal informationtr = traslatetroff = Typesetter new ROFFtsort = Topological SORTtty = TeleTypewritertwm = Tom’s Window Managertz = TimeZoneudev = Userspace DEVulimit = User’s LIMITumask = User’s MASKuniq = UNIQuevi = VIsual = Very Inconvenientvim = Vi IMprovedwall = write allwc = Word Countwine = WINE Is Not an Emulatorxargs = eXtended ARGumentsxdm = X Display Managerxlfd = X Logical Font Descriptionxmms = X Multimedia Systemxrdb = X Resources DataBasexwd = X Window Dumpyacc = yet another compiler compiler]]></content>
      <categories>
        <category>计算机</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding]]></title>
    <url>%2Fposts%2F369cf01c.html</url>
    <content type="text"><![CDATA[前言由于本人只是将Hexo博客同时部署到 Github 和 Coding.net ，所以这里只介绍怎么同时部署到这两个网站的pages。之所以选择这两个网站，是因为国外用户可以访问 Github，而国内用户可以访问 Coding.net。另外，Coding.net可以拥有自己的私人仓库。修改站点配置文件在站点根目录下找到 _config.yml文件，将里边的deploy节点修改成下边的形式：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:&#123;username&#125;/&#123;repository&#125;.git,master coding: git@git.coding.net:&#123;username&#125;/&#123;repository&#125;.git,master将上边的仓库url的{username}/{repository}改成自己的项目地址，这里使用的是SSH协议的Git仓库地址，即：1git@&#123;domain&#125;:&#123;username&#125;/&#123;repository&#125;.git还有一种是HTTPS协议的Git仓库地址，即：1https://&#123;domain&#125;/&#123;username&#125;/&#123;repository&#125;.git一般推荐使用SSH协议的地址，因为可以免去每次push都要输入账号密码的繁琐，而且也够安全。在 Github 和 Coding.net 上各自创建一个仓库如果我们只是将项目部署到某一个代码托管站点而已，那么该项目仓库的名字可以随便起；但是现在我们需要将项目同时部署到 Github 和 Coding.net 上，那就不能随意命名了。我们需要采用特定的命名方式，才能正确将Hexo博客同时部署到这两个站点上；否则很可能会导致只有博客的主页能访问到，而其他的路径全部失效。仓库的命名对于 Coding.net，你可以选择建立一个私人仓库来部署自己的Hexo博客，不过和 Github 不同的地方在于：Github 的仓库名要命名为：1&#123;username&#125;.github.io而 Coding.net 的仓库名要命名为：1&#123;username&#125;这里的 username 指的是你在这两个网站上的用户名，只有以这种命名形式的仓库，才能够不通过子域名的形式来访问我们的博客。比如说，我的 Github 和Coding.net 的账号都是lewky，那么在部署博客成功后，我就可以通过下边的url来访问我的Hexo博客：12https://lewky.github.io/https://lewky.coding.me/如果将仓库名命名为其他的形式，比如：hexo-blog，那么要访问该博客，就需要输入下边的url：12https://lewky.github.io/hexo-bloghttps://lewky.coding.me/hexo-blog这里的仓库名hexo-blog就变成了子域名，于是问题就来了，对于存在子域名的Hexo博客，需要在站点配置文件里配置url节点：123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:如果不配置这里的url节点，会导致除了首页以外的所有页面都请求404；但是我们由于是同时部署在两个网站上，其父域名是不一样的，那么这里的url节点也就只能配置一个而牺牲另一个了；但是如果你有自己的域名，就可以解决这个问题了：直接在这里配置自己的域名就行了。配置 SSH key创建RSA密钥对使用 Git Bash 生成RSA密钥对：1ssh-keygen -t rsa -b 4096 -C "your_email@example.com"看到提示就按一次回车，在连续三次回车后，就表示创建成功了。接着将 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。Github 配置 SSH key登陆 Github 的账号：进入 Settings 页面选择 SSH and GPG keys点击 New SSH key填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来）然后在 Key 里将我们刚刚复制的公钥复制进去最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。Coding.net 配置 SSH keyCoding.net 和 Github 有些不一样，Coding.net存在账户公钥和部署公钥；账户公钥配置后拥有账户下所有项目的读写权限部署公钥配置后默认拥有该项目的只读权限，如果需要获取推送权限，需要勾选部署公钥设置里的『授予推送权限』登陆 Coding.net 的账号：进入个人设置选择 SSH 公钥选择新增公钥填写公钥名称和内容添加后输入输入账号密码进行确认验证 SSH 连接使用 Git Bash 输入：1ssh -T git@github.com第一次连接时会问你是否继续连接，输入 yes 即可；接下来验证 Coding.net 的ssh连接：1ssh -T git@git.coding.net同样输入 yes 即可。如果按照前边说的来配置，这里的 SSH 验证应该都是没问题的。接下来只要撰写博文，然后使用命令进行部署就行了：12hexo cleanhexo g -d]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
        <tag>Next性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源]]></title>
    <url>%2Fposts%2Ff90c8f1a.html</url>
    <content type="text"><![CDATA[为什么要压缩页面静态资源对于个人博客来说，优化页面的访问速度是很有必要的，如果打开你的个人站点，加载个首页就要十几秒，页面长时间处于空白状态，想必没什么人能够忍受得了吧。我个人觉得，如果能把页面的加载时间控制在三四秒内，就很不错了。那么怎么提高hexo这个静态博客的页面加载速度呢？可以从以下的几个方面去入手：将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么卵用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。hexo的压缩静态资源插件网上有很多相关的博文，常规的做法是使用gulp来进行压缩，gulp是Node.js下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下相关的东西。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。这里我选择的是由rozbo大佬开发的hexo-neat压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！如何使用hexo-neat在站点根目录下安装hexo-neat1npm install hexo-neat --save为站点配置文件添加相关配置下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js'hexo-neat插件踩坑记录由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。跳过压缩文件的正确配置方式如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：1234neat_css: enable: true exclude: - '**/*.min.css'压缩html时不要跳过.md文件.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。压缩html时不要跳过.swig文件.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。参考链接GitHub项目地址hexo博客压缩优化Hexo-Neat介绍]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
        <tag>Next性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml报错：Invalid content was found starting with element 'init-param']]></title>
    <url>%2Fposts%2F474ffd9f.html</url>
    <content type="text"><![CDATA[问题与分析在web.xml中配置servlet节点时报错如下：cvc-complex-type.2.4.a: Invalid content was found starting with element ‘init-param’. One of ‘{“http://java.sun.com/xml/ns/j2ee&quot;:run-as, “http://java.sun.com/xml/ns/j2ee&quot;:security-role-ref}&#39; is expected.原因是init-param节点不能放在load-on-startup节点的后面，将init-param节点放置到前边就不再报这个错误了：12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;resteasy-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt; org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt; &lt;param-value&gt;com.cbx.ws.rest.jaxrs.CbxApplication&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PMD - Avoid autogenerated methods to access private fields and methods of inner / outer classes]]></title>
    <url>%2Fposts%2F1ad7b6fb.html</url>
    <content type="text"><![CDATA[PMD错误Avoid autogenerated methods to access private fields and methods of inner / outer classes样例1234567891011121314151617181920public class Test &#123; public static void main(final String[] args) &#123; //code &#125; public void test()&#123; Executors.newSingleThreadExecutor().execute(new Thread() &#123; @Override public void run() &#123; final int a = getNum(); System.out.println(a); &#125; &#125;); &#125; private int getNum() &#123; return 0; &#125;&#125;报错原因在匿名内部类的方法里去调用外部类的私有方法或变量就会报这个PMD错误。解决方法可以将匿名内部类的方法里调用到的外部类的私有方法/变量改成protected。以样例来举例，即将getNum()的权限改为protected：123protected int getNum() &#123; return 0;&#125;]]></content>
      <categories>
        <category>代码规范</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码规范</tag>
        <tag>PMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器时间和数据库时间的校验]]></title>
    <url>%2Fposts%2F663a514f.html</url>
    <content type="text"><![CDATA[问题与分析今天在公司进行Sanity Test(可用性测试)时发现服务器启动失败，查找log后发现在启动时发生了异常导致了服务器启动失败。由于公司的服务器和数据库分别部署在不同的主机，所以会在启动时进行时间上的校验，如果两台主机的时间差超过600s就会抛出异常、启动失败。这个设定的时间差被存储在数据库中，以方便日后修改。而在代码中，通过mybatis来读取到这个存储在db中的时间差，sql语句如下：1SELECT TO_CHAR(CURRENT_TIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS "DBTIME";而服务器的本地时间以及时间的校验则是由下边的代码来实现：12345678final DateTime dbTime = systemMapper.getDBTime();final long dbTimeMs = dbTime.getMilliseconds(TimeZone.getDefault());final DateTime webAppTime = DateTime.now();final long webAppTimeMs = webAppTime.getMilliseconds(TimeZone.getDefault());// Calculate difference between WebApp time and DB timefinal long timeDifferent = Math.abs(dbTimeMs - webAppTimeMs);从代码可以看到，将服务器和数据库所在的主机的本地时间转换成默认的时区后，再进行相减取绝对值，如果这个结果值超过db中设定的时间差(也就是600s)就会抛出异常，令服务器启动失败。分析到这里，便开始进行验证：分别连接到两台主机并通过date命令来查询各自的时间，发现双方的时间差大概有15分钟左右，确实超过了600s。于是问题来了，为什么会忽然出现这么大的时间差？明明昨天还可以正常启动，今天却因为时间差变大而导致失败了？可以确定的是，db中设定的时间差一直就是600s，并没有人去改动它。在工作群里说了下服务器启动失败的原因，有同事说可能是机器断电造成的？百度了下，也有人遇到这种类似的情况，Linux的系统时间忽然变慢了几分钟到十几分钟，也有的是时间变快了。暂时没找到具体的原因，解决办法基本都是直接修改系统时间。目前看来，这个问题的答案是无法得知了，对于这方面我确实不了解。如果哪位朋友知道的，欢迎评论告诉我一下O(∩_∩)O哈哈~今天写篇文章记录下这个问题，以前我还真没想到需要对不同主机的服务器和数据库进行时间校验，百度了下，倒是发现很多安卓app关于客户端和服务端进行时间校验的文章，挺有意思的。]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 官方手册、中文手册及Github项目地址]]></title>
    <url>%2Fposts%2F20454419.html</url>
    <content type="text"><![CDATA[官方手册、中文手册PostgreSQL每次更新都会有语法变化，低版本的PostgreSQL是无法运行高版本的sql语法的，下边是官方手册地址，可以查看多个版本的：https://www.postgresql.org/docs/10/static/index.html官方手册都是英文的，嫌麻烦可以看下边的中文手册：PostgreSQL 10.1 手册中文手册在Github的项目地址维护中文手册的团队翻译了几个版本的PostgreSQL，如果有发现typo什么的可以到Github上去提issue：postgres-cn/pgdoc-cn最后，感谢中文手册团队的各位大佬的翻译~]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml中classpath*:与classpath:的区别]]></title>
    <url>%2Fposts%2F56592abf.html</url>
    <content type="text"><![CDATA[classpath*:与classpath:classpath对应src目录，该目录下的文件会在编译后被存放到WEB-INF文件夹下的classes目录。classpath：只会到你的class路径中查找配置文件，对于多个同名的配置文件，只会加载找到的第一个文件；classpath*：除了指定的class路径，还会到该class路径下的jar包中进行查找配置文件，对于多个同名的配置文件，都会被加载。但是对于classpath*，无法使用模糊匹配的方式，可以通过逗号来隔开多个配置文件。123456789&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml, classpath*:app-1.xml, classpath*:app-2.xml, classpath*:app-3.xml, classpath*:app-4.xml &lt;/param-value&gt; &lt;/context-param&gt;参考链接：在Web.xml中自动扫描Spring的配置文件及resource时classpath*:与classpath:的区别]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 转义字符]]></title>
    <url>%2Fposts%2F727d105a.html</url>
    <content type="text"><![CDATA[转载至：postgresql字符转义前言在PostgreSQL 9之前的版本中，可以直接使用反斜杠\进行转义；比如：\b表示退格， \n表示换行， \t表示水平制表符，\r标示回车，\f表示换页。除此之外还支持\digits和\xhexdigits，分别表示转义八进制和十六进制数据。但是在PostgreSQL 9之后的版本，反斜杠已经变成了普通字符；如果想要使用反斜杠来转义字符，就必须在需要转义的字符串前面加上E（E就是Escape），如下：1select E'张\t小明';对单引号的两种转义方式在SQL标准中字符串是用单引号括起来的，而在PostgreSQL中遵守了该标准，双引号则是用来表示变量的，如果在字符串中需要使用到单引号，就需要对其进行转义。方式一：使用E和反斜杠进行转义1select E'\'233';方式二：直接用一个单引号来转义单引号1select '''233';这两种方式都能得到&#39;233的结果而不会报错，第二种方式比较简单，也可以通过修改standard_conforming_strings参数的值来让反斜杠从普通字符变回转义字符：查询并修改该参数的值：123show standard_conforming_strings;SET standard_conforming_strings = on;SET standard_conforming_strings = off;当该参数的值为off时就可以直接使用反斜杠作为转义字符里，如下：1select '\'233';将会得到&#39;233的结果而不会报错。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络适配器、网卡和网卡驱动]]></title>
    <url>%2Fposts%2Fb66922.html</url>
    <content type="text"><![CDATA[网络适配器（网卡）网络适配器其实就是计算机内部的网络连接设备，也就是俗称的网卡。网卡分为有线网卡和无线网卡，有线网卡能够支持宽带有线网络的连接和网络访问，而无线网卡则支持无线wifi局域网的网络连接和访问。台式电脑一般默认都不带无线卡，所以是无法接收wifi进行上网的。如果想要台式机接收无线网使用wifi，电脑必须安装一块无线网卡，可以选择USB接口无线网卡。网卡驱动网卡是硬件设备，网卡驱动是配套的软件。驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器——CPU控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。所有的硬件都要安装驱动程序，没有驱动程序的硬件是运行不了的，就像一辆有轮胎但是没有传动轴的汽车一样跑不起来，控制不了。假如某设备的驱动程序未能正确安装，便不能正常工作。网卡驱动程序就是CPU控制和使用网卡的程序。参考链接网络适配器无法启动怎么办台式电脑如何连接wifi网卡驱动_百度百科]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google hosts - 简单介绍与使用方法]]></title>
    <url>%2Fposts%2F9cdb4f66.html</url>
    <content type="text"><![CDATA[什么是Hosts百度百科：Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。Hosts所在文件夹Windows系统hosts位于 C:\Windows\System32\drivers\etc\hostsAndroid（安卓）、Mac（苹果电脑）iPhone（iOS）、Linux 、绝大多数Unix等系统hosts都是位于 /etc/hostsAndroid（安卓）iPhone（iOS）修改hosts 需要Root或越狱。Hosts的作用加快域名解析方便局域网用户屏蔽网站（域名重定向）顺利连接系统虚拟域名更加具体的说明请参考百度百科。使用步骤获取最新的hosts文件可以自己百度Google hosts寻找最新的hosts文件，获取前往GitHub上由大佬们维护的项目获取：https://github.com/googlehosts/hosts附上项目的镜像地址，访问不了GitHub的同学可以访问这个：https://coding.net/u/scaffrey/p/hosts/git在上述的项目地址中找到hosts文件(无后缀名)，也可以直接在线浏览该文件的内容，下边附上链接：https://raw.githubusercontent.com/googlehosts/hosts/master/hosts-files/hosts同样附上国内镜像的浏览链接：https://coding.net/u/scaffrey/p/hosts/git/raw/master/hosts-files/hosts修改本地hosts文件从上边的项目地址将hosts文件下载到本地，直接替换掉本地的hosts文件，建议替换之前先备份原本的hosts文件。或者直接在线浏览文件内容，将内容拷贝到本地的hosts文件的末尾。这里说明一下，文件里的#开头表示注释，也就是说那一行没有效果，只是起到说明作用。刷新本地dns修改了hosts文件后不需要重启电脑，直接在本地刷新dns的缓存即可生效：Windowswin+R组合键启动运行，输入cmd在cmd界面输入ipconfig /flushdns，然后回车接下来你会看到已成功刷新 DNS 解析缓存。Linux终端输入sudo rcnscd restart对于systemd发行版，输入sudo systemctl restart NetworkManager如果不懂请都尝试下。Mac OS X终端输入sudo killall -HUP mDNSResponderAndroid开启飞行模式 -&gt; 关闭飞行模式通用方法拔网线(断网) -&gt; 插网线(重新连接网络)如不行请清空浏览器缓存再不行请重启电脑相关事项说明注意事项本文提供的hosts链接仅限于方便学习使用hosts里不会添加屏蔽广告条目，也不会劫持任何网站您现在的hosts能使用，就没必要经常更新！版权声明Github项目的所有代码除另有说明外,均按照 MIT License 发布。Github项目的hosts，README.MD， wiki等资源基于 CC BY-NC-SA 4.0 这意味着你可以拷贝、并再发行本项目的内容， 但是你将必须同样提供原作者信息以及协议声明。同时你也不能将本项目用于商业用途，按照我们狭义的理解 (增加附属条款)，凡是任何盈利的活动皆属于商业用途。感谢大佬们的无私奉献致谢：Github项目维护者 @racaljk @andytimes @Too-Naive @laodcn @lrinQVQ @K-Guan @imcaffrey @smounives @lautis0503 @aofall @davymai @Ignotus-CN @cw881014 等等…]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>网络通信</tag>
        <tag>Google hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 修改默认端口号]]></title>
    <url>%2Fposts%2F5186d3f4.html</url>
    <content type="text"><![CDATA[升级PostgreSQL遇到的问题之前将PostgreSQL从9.5升级到了10.3版本，安装时将端口设置成了5433，(默认是5432)，后来发现在使用psql来restore db会发生语法错误。由于PostgreSQL10.3版本添加了9.5版本没有的sql语法，导致了这个错误，但我明明已经升级了数据库，为什么还会遇到语法错误呢？而且我发现我在cmd窗口里连接了数据库之后，psql提示我psql的版本是10.3，而server版本却是9.5。在折腾了好一会，才被自己的蠢都哭了。原来是因为我在连接数据库时没有通过-p 5433来指定10.5版本的server端口号，所以psql自动连接了默认端口号是5432的9.5版本server。解决方式连接数据库时指定端口号如果要连接5432以外的端口号，必须通过-p参数来指定端口号。由于我原本用的是9.5版本的，本身就启动着9.5版本的server服务，端口号是默认的5432；后来我升级了10.3版本的，实际上PostgreSQL在升级时并不会卸载旧版本的，会在安装了新版本之后就自动启动新版本的server服务，这里我设置的端口号是5433。于是在我的电脑上就同时启动着9.5和10.3两个版本的server服务，当我没有指定端口号时，其实一直是连接的9.5版本的server，于是在restore使用了新版本语法的db时就会报错。修改默认端口号如果我希望不指定端口号就能连接新版本的server，就只能将10.3的server的端口号改为默认端口号5432。首先将9.5版本的server服务关闭，这个要在系统的服务管理器中将其关闭：win + R快捷键打开运行；输入services.msc打开服务管理器；找到运行中的9.5版本的server服务将其关闭。在PostgreSQL的安装路径下，找到对应版本的postgresql.conf文件（在data文件夹内）：修改port = 5432；保存修改，重启该版本的server服务，即可生效。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL - 单引号和双引号的区别]]></title>
    <url>%2Fposts%2F8600baa4.html</url>
    <content type="text"><![CDATA[原文转载至：SQL中的单引号和双引号有区别吗？在标准 SQL 中，字符串使用的是单引号。如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。但在其它的数据库中可能存在对 SQL 的扩展，比如在 MySQL 中允许使用单引号和双引号两种。MySQL 参考手册：字符串指用单引号&#39;或双引号&quot;引起来的字符序列。例如：‘a string’“another string”如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - 允许远程访问的设置方法]]></title>
    <url>%2Fposts%2Fde4d3e94.html</url>
    <content type="text"><![CDATA[原文转载至：PostgreSQL 允许远程访问设置方法安装PostgreSQL数据库之后，默认是只接受本地访问连接。如果想在其他主机上访问PostgreSQL数据库服务器，就需要进行相应的配置。配置远程连接PostgreSQL数据库的步骤很简单，只需要修改data目录下的pg_hba.conf和postgresql.conf。pg_hba.conf：配置对数据库的访问权限。postgresql.conf：配置PostgreSQL数据库服务器的相应的参数。修改pg_hba.conf文件配置用户的访问权限（#开头的行是注释内容）123456789# TYPE DATABASE USER CIDR-ADDRESS METHOD# "local" is for Unix domain socket connections onlylocal all all trust# IPv4 local connections:host all all 127.0.0.1/32 trusthost all all 192.168.1.0/24 md5# IPv6 local connections:host all all ::1/128 trust上边的第7行是新添加的内容，表示允许网段192.168.1.0上的所有主机使用所有合法的数据库用户名访问数据库，并提供加密的密码验证。其中，数字24是子网掩码，表示允许192.168.1.0–192.168.1.255的计算机访问！修改postgresql.conf文件将数据库服务器的监听模式修改为监听所有主机发出的连接请求：定位到#listen_addresses=&#39;localhost&#39;，PostgreSQL安装完成后，默认是只接受来在本机localhost的连接请求。将行开头的#去掉，将行内容修改为listen_addresses=&#39;*&#39;来允许数据库服务器监听来自任何主机的连接请求。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
        <tag>远程访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - psql的使用与退出]]></title>
    <url>%2Fposts%2F7eb5e777.html</url>
    <content type="text"><![CDATA[PostgreSQL连接数据库的两种方式PostgreSQL在安装时自带了pgAdmin和psql，pgAdmin是可视化工具，psql是命令行工具。虽然pgAdmin操作起来会更加直观简单，但是在restore和backup db的时候，效率和性能会比较低下，如果db过于庞大，还会导致pgAdmin内存溢出。推荐使用psql来连接数据库进行备份和恢复db，同样大小的db，使用psql来restore会比pgAdmin快上数倍！psql连接数据库在psql PostgreSQL 手册里对于psql有非常详细的介绍，不过一般来说我们是用不到那么多参数的。1psql -h &lt;dbserver_IP&gt; -p&lt;dbserver_port&gt; -d &lt;database_Name&gt; -u &lt;db user&gt;如果host是localhost，可以不指定该参数，当不指定端口号时会使用默认的端口号5432，或者你可以通过-p来指定其他端口号。比如你想连接本地的dbtest:5432，用户名是postgres，可以使用如下的命令：1psql -d test -u postgres如果有密码的话还需要输入密码，连接数据库后就可以直接通过sql语句来进行相关的操作了。退出psql和其他的命令行工具不一样，psql在退出时并不是使用exit，而是使用\q，接着按下回车就行了。这里的q指的是quit。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
        <tag>psql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL - nulls值排序问题]]></title>
    <url>%2Fposts%2F419004ef.html</url>
    <content type="text"><![CDATA[给字段排序时遇到的null值问题当我们使用order by来为指定的字段进行排序时，如果db中该字段的值存在着null值，那么在排序时这些null值会不会参与排序呢？如果参与排序的话，又是以怎样的标准来排序？在不同的DB中，对于null值的默认值不同。在PostgreSQL中，null值默认最大如果对一个学生表里的数据按照age字段进行顺序排序，如下：1select * from student order by age如果name字段存在null值，那么这条sql的结果集就如下所示：12345|id|student|age||1|小明|10||2|小红|12||3|小黑|null||4|小白|null|因为null值默认是最大，所以在升序排列中null值的记录就会被排到最后。同样地，如果是降序排列，null值记录就会被排到最前面。在Oracle中，null值默认最大Oracle中同样认为null值最大，也就是说，升序排列时null值默认排在最后；降序排列时null值默认排在最前。在MySQL和SQLServer中，null值默认最小MySQL和SQLServer则相反，null值默认是最小。当升序排列时null值默认排在最前；降序排列时null值默认排在最后。在实际的业务中，null值参与的排序这可能会造成一些不必要的问题，有时候甚至会造成一个bug并且难以被发现。所以，在对这些有可能存在null值的字段进行排序时需要注意使用关键字nulls last/first。nulls last/first的具体用法我们可以通过nulls last或者nulls first关键字来指定这些null值的record是排在最后还是最前，如下：1select * from student order by age desc nulls last;该语句指定了降序排列时，null值排到最后；需要注意的是，该关键字只能搭配order by来使用。一共也就四种用法：order by [asc] nulls firstorder by [asc] nulls lastorder by desc nulls firstorder by desc nulls last如果想了解更多关于db中的这些null值，可以看看下边的链接：mysql 空值排序问题PostgreSQL 数据库NULL值的默认排序行为与查询、索引定义规范 - nulls first\last, asc\desc]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log日志中不打印异常栈的具体信息]]></title>
    <url>%2Fposts%2Fa3da2383.html</url>
    <content type="text"><![CDATA[问题与分析最近在查项目的log时发现报了大量的NPE(NullPointerException)，诡异的是只log了Exception的类名，却没有具体的堆栈信息，以致于无法对该NPE异常进行准确定位。这是因为jvm自身存在着优化机制，但一个同样的异常重复出现并被打印到log后，jvm可以不提供具体的堆栈信息来提高性能。关于这个的具体信息我们可以从官网上查到相关的资料：http://www.oracle.com/technetwork/java/javase/relnotes-139183.html#vmThe compiler in the server VM now provides correct stack backtraces for all “cold” built-in exceptions. For performance purposes, when such an exception is thrown a few times, the method may be recompiled. After recompilation, the compiler may choose a faster tactic using preallocated exceptions that do not provide a stack trace. To disable completely the use of preallocated exceptions, use this new flag: -XX:-OmitStackTraceInFastThrow.谷歌翻译如下：服务器VM中的编译器现在为所有“冷”内置异常提供正确的堆栈回溯。出于性能目的，当抛出这样的异常几次时，可以重新编译该方法。重新编译之后，编译器可以使用不提供堆栈跟踪的预分配异常来选择更快的策略。要完全禁用预分配的异常，请使用以下新标志：-XX：-OmitStackTraceInFastThrow。解决方案有两个解决方案，第一个是安装官网说的，可以通过设置jvm的启动参数来关闭该策略：1-XX：-OmitStackTraceInFastThrow另一个解决方案是不设置启动参数，直接重新启动服务器，比如Tomcat。重启服务器时jvm被重新启动，这样再遇到同样的Exception时就会打印出来，当然如果后续如果重复遇到同样的Exception还是无法打印出具体的异常栈信息。当时我是选择了后者这个方案，因为如果启用了该参数会导致log日志太过庞大，也降低了性能，直接重启服务器，并快速定位bug以便于解决问题。补充如果想了解更多关于该参数的细节，可以参考下边的文章：异常栈信息不见了之JVM参数OmitStackTraceInFastThrow]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(4) - 站点首页不显示文章全文]]></title>
    <url>%2Fposts%2F62111.html</url>
    <content type="text"><![CDATA[文章摘要设置打开主题配置文件 _config.yml 文件，找到如下：12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150把这里的false改为true就可以了在首页启动显示文章预览了，length是显示预览的长度。这里我们可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。强烈推荐使用该&lt;!-- more --&gt;标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。其他的文章配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 自动将页面滚动到&lt;!-- more --&gt;标记下的地方。scroll_to_more: false# Automatically saving scroll position on each post/page in cookies.# 自动保存每篇文章或页面上一次滚动的地方。save_scroll: false# Automatically excerpt description in homepage as preamble text.# 自动在首页对文章进行摘要描述作为前言文本。excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 不推荐使用自动摘要。# 请在文章中使用&lt;!-- more --&gt;标志来精确控制摘要长度。auto_excerpt: enable: true length: 200# Post meta display settings# 文章元数据展示设置post_meta: # 文本显示 item_text: true # 创建时间 created_at: true # 更新时间 # 这个更新时间有点问题，因为每次重新生成文章/部署时都会刷新更新时间，不建议使用 updated_at: false # 目录分类 categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 文章字数展示设置post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: true # 该post_wordcount的所有设置另起一行显示 separated_meta: true]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(3) - 添加GitHub彩带和GitHub Corner]]></title>
    <url>%2Fposts%2F844109c2.html</url>
    <content type="text"><![CDATA[页面右上角添加GitHub彩带你可以在这里找到一共12种样式的GitHub彩带，复制其中的超链代码。在themes\next\layout\_layout.swig目录下找到头部彩带相关的代码：1&lt;div class="headband"&gt;&lt;/div&gt;在这里的div标签内部添加我们刚刚复制的超链代码，并修改超链指向你的GitHub地址：123&lt;div class="headband"&gt; &lt;a href="https://github.com/lewky"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"&gt;&lt;/a&gt;&lt;/div&gt;当然我本人并不是很推荐用这种方法，因为这个超链使用的图片有时候会加载很久，最后图片还是挂掉了，我是直接将图片保存到站点的images目录下，然后直接使用自己站点的图片，这样可以避免加载过久甚至图片挂掉的情况。123&lt;div class="headband"&gt; &lt;a href="https://github.com/lewky" target="_blank"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="/images/headband/forkme_right_red.png" alt="Fork me on GitHub"&gt;&lt;/a&gt;&lt;/div&gt;我只找到了10张彩带图片，可以直接在我的GitHub项目中找到这些图片并复制到自己的站点上。页面右上角添加GitHub Corner这是我后来在其他博客中见到的，可能是6.x.x版本的NexT主题自带的，由于我使用的主题版本较低，只能自己添加了。还是在themes\next\layout\_layout.swig目录下，找到如下代码：123&lt;header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"&gt; &lt;div class="header-inner"&gt; &#123;%- include '_partials/header.swig' %&#125; &lt;/div&gt;&lt;/header&gt;我们在这个header标签的下边，添加一个超链代码：123456&lt;a href="https://github.com/lewky" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"&gt; &lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt; &lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt; &lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt; &lt;/svg&gt;&lt;/a&gt;将上边的超链的href改为自己的GitHub地址，然后我们需要修改这个超链的样式，在上文中提及的themes/next/source/css/_custom/custom.styl里添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* GitHub Cornor */.github-corner :hover .octo-arm &#123; animation: octocat-wave 560ms ease-in-out;&#125;@media (max-width: 991px) &#123; .github-corner &gt;svg &#123; fill: #fff !important; color: #222 !important; &#125; .github-corner .github-corner:hover .octo-arm &#123; animation: none; &#125; .github-corner .github-corner .octo-arm &#123; animation: octocat-wave 560ms ease-in-out; &#125;&#125;@-moz-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@-webkit-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@-o-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;这段长长的css代码是令这个GitHub Corner能够呈现出响应式的效果，当你缩放页面的时候，你会发现页面右上角的GitHub的吉祥物——章鱼猫(Octocat)会随着页面的大小变化而变化！此外，当我们将鼠标移动到GitHub Corner的上方时，章鱼猫的手臂还会摆动一下哦~下边是GitHub Corner的项目地址，一共有10种颜色样式，任君选择！GitHub Corners项目地址]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(2) - 添加背景图片轮播]]></title>
    <url>%2Fposts%2F576ee548.html</url>
    <content type="text"><![CDATA[动态背景图片插件jquery-backstretchjquery-backstretch是一款简单的jQuery插件，可以用来设置动态的背景图片，以下是官方网站的介绍。A simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element.可以直接在页面中引入该插件的cdn来调用函数，也可以直接下载下来使用，这是官方地址。jquery-backstretch的使用方法引入该插件的cdn打开themes\next\layout\_custom\custom-foot.swig，引入该背景图片插件的cdn：12345678&#123;#Custom foot in body, Can add script here.#&#125;&lt;!-- 图片轮播js文件cdn --&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt;&lt;!-- 自定义的js文件 --&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt;需要注意的是，我们要引入的插件cdn，都需要在自定义的js文件custom.js之前引入才行！否则，插件会在访问页面时无法生效，可以在浏览器的控制台看到报错。调用backstretch函数在themes\next\source\js\src\custom.js中添加如下代码：12345678/* 轮播背景图片 */$(function () &#123; $.backstretch([ "/images/background/saber1.jpg", "/images/background/saber2.jpg", "/images/background/bg1.jpg" ], &#123; duration: 60000, fade: 1500 &#125;); &#125;);这里可以随意添加你想要轮播的图片，但要确保图片路径是正确的，比如我的背景图片就存放在站点根目录下的images/background/目录下。然后duration指的是轮换图片的时间，单位是毫秒，也就是说这里的代码表示一分钟就轮换到下一张图片；fade指的是轮换图片时会有个渐进渐出的动作，而这个过程需要花费的时间单位也是毫秒，如果不加上这个参数，就表示离开轮换成下一张图片。注意这里的$.backstretch指的是对整个页面设置背景图片，我们也可以专门给某个元素设置背景图片，如下：1234$(function () &#123; $(".saber1").backstretch(["/images/background/saber1.jpg"]); $(".saber2").backstretch(["/images/background/saber2.jpg"]); &#125;);如果只有一张图片，就没必要设置duration和fade参数了。为背景图片设置样式虽然我们设置好了背景图片，但如果页面的许多元素是不透明的，背景图片可能并不能很好地被看见，所以我们可以对背景图片和其他的页面元素进行设置样式。首先为背景图片设置透明度，因为有的图片颜色比较深厚，而页面多为白色，然后造成喧宾夺主的感觉。file:themes\next\source\css\_custom\custom.styl1234/* 背景图片透明度 */.backstretch &#123; opacity: .75;&#125;接下来设置页面元素透明度，需要注意的是，如果我们在主题配置文件中启用了搜索功能，那么就不能简单粗暴地直接将整个页面都设置透明度，这会导致搜索框失效，无法正常使用。原因是因为搜索框是通过jQuery临时添加的，如果整个页面都设置了透明度，会导致搜索框的z-index失效而无法触发点击事件。我在折腾了一段时间后，终于想到了个取巧的方法，那就是将搜索框的父元素设置为白色透明的，而其他页面元素则直接设置透明度，如下：file:themes\next\source\css\_custom\custom.styl1234567/* 页面透明度 */.content-wrap, .sidebar &#123; opacity: .9 !important;&#125;.header-inner &#123; background: rgba(255, 255, 255, 0.9) !important;&#125;]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo瞎折腾系列(1) - 准备工作与简单美化]]></title>
    <url>%2Fposts%2Fef301a4d.html</url>
    <content type="text"><![CDATA[前言网上有不少相关的帖子，不过版本会比较旧，而不同版本可能存在代码不同的问题，不过大部分还是大同小异，本系列就不啰嗦重复了，基本只会按照本人所使用的版本以及个人所使用到的内容来进行介绍。该系列是对我所使用的Next主题进行个性化定制，涉及到js和css等的修改，还有各种插件的使用；另一个系列是针对Next主题进行一些写作技巧的介绍与运用，希望能对大家有所帮助。有疑问的朋友可以给我留言，我会尽可能回复O(∩_∩)O。我所使用的Hexo和NexT的版本如下：12hexo: 3.7.1next: 5.1.4关于配置文件对于使用了Next主题的Hexo静态博客，存在着两个至关重要的配置文件_config.yml。在本系列中，统一将位于站点根目录下的该文件称为站点配置文件，将位于themes\next目录下的该文件称为主题配置文件。准备工作：添加美化博客的相关文件本系列会使用到大量的css与JavaScript的相关内容，为了更有效率与可观赏性的美化博客，我们将这些美化相关的东西都尽可能地写到一类文件中，方便日后查询与修改。譬如下边的几个文件里，就存放了博客的大部分美化内容：themes/next/source/css/_custom/custom.stylthemes/next/source/js/src/custom.jsthemes/next/layout/_partials/head/custom-head.swigthemes/next/layout/_custom/custom-foot.swig除了第一个文件custom.styl保存的是css代码，另外三个文件都是保存的js代码。这几个文件分别会在页面的以下位置中被引入：123456789101112131415&lt;html&gt; &lt;head&gt; .... &#123;&#123; custom.styl &#125;&#125; //css .... &#123;&#123; custom-head.swig &#125;&#125; //js .... &lt;/head&gt; &lt;body&gt; .... .... &#123;&#123; custom-foot.swig &#125;&#125; //js &#123;&#123; custom.js &#125;&#125; //js &lt;/body&gt;&lt;/html&gt;这里的custom.styl，custom-head.swig是原本的NexT主题自带的，另外两个是我自己添加的，之所以又添加了另外两个js文件，是因为在页面的不同地方引入js文件会对页面产生不一样的效果与影响。添加 custom-foot.swig 文件在themes/next/layout/_custom/目录下添加custom-foot.swig文件，该文件内容如下：12345&#123;#Custom foot in body, Can add script here.#&#125;&lt;!-- 自定义的js文件 --&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt;接着修改themes\next\layout\_layout.swig，在body标签的闭合标签前添加一行代码，表示将我们新添加的custom-foot.swig文件包括进去：123456&lt;body&gt; .... &#123;% include '_custom/custom-foot.swig' %&#125;&lt;/body&gt;&lt;/html&gt;这个文件的作用是负责引入我们想要的js文件，比如其他第三方js的cdn等等。因为页面在引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。添加 custom.js 文件在themes/next/source/js/src目录下添加custom.js文件，该文件用来存放我们自己写的js函数等等，需要注意的是，我们之前是在custom-foot.swig文件中的script标签里引入了该文件，也就是说，在该文件里，我们不能再自己添加script标签了，直接书写js函数就行了，如下所示：1234/* 返回随机颜色 */function randomColor() &#123; return "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")";&#125;页面的简单美化由于很多大佬的博客都有很详尽的美化教程，这里我就不赘述了，只简单介绍下比较少人讲述到的部分简单美化。改变页面的字体大小打开 themes\next\source\css\_variables\base.styl，该文件保存了一些基础变量的值，我们找到$font-size-base，将值改为16px。12// Font size$font-size-base = 16px这个文件里定义了很多常量，有兴趣的可以自己去琢磨琢磨，修改一些其他的变量。文章启用tags和categories可能是该版本的NexT主题的关系，在我第一次使用NexT主题时，折腾了很久都没办法让菜单栏里的tags和categories的页面生效，一直显示白屏。后来终于在知乎找到答案，首先我们需要将某篇文章设置tags和categories，如下：12345678---title: Testtags: - MyTagcategories: - MyCategorydate: 20xx-xx-xx xx:xx:xx---接下来是重点了，首先确定是否已经在主题配置文件中启用了tags和categories这两个菜单，如下：12345menu: home: / || fas fa-home archives: /archives/ || fas fa-archive categories: /categories/ || fas fa-th tags: /tags/ || fas fa-tags接着确定是否在source目录下是否已经存在tags和categories这两个文件夹，如果不存在需要运行下边的命令：12hexo n page tagshexo n page categories运行之后会在source目录下生成对应的两个文件夹，在文件夹下会存在一个index.md文件，打开这两个index.md文件，分别添加type: tags和type: categories，如下：file:~/source/tags/index.md12345---title: 标签date: 20xx-xx-xx xx:xx:xxtype: tags---file:~/source/categories/index.md12345---title: 分类date: 20xx-xx-xx xx:xx:xxtype: categories---接下来重新使用本地调试三连，就可以看到tags和categories这两个菜单的页面显示正常了。去掉图片边框NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\next\source\css\_custom\custom.styl，添加如下CSS代码：12345678/* 去掉图片边框 */.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125;修改语法高亮的主题语法高亮就是在引入代码时让代码呈现特定的样式，而在Markdown文件中语法高亮的使用方法是在引入代码的前一行添加三个反引号加上使用的语言名字，然后在引入代码的下一行使用三个反引号结尾。如下所示的格式，就表示html代码的语法高亮：1&lt;h2&gt;Hello World!&lt;/h2&gt;其源码如下：1&lt;h2&gt;Hello World!&lt;/h2&gt; 由于NexT默认的语法高亮的主题比较一般，我们可以换成其他的主题，比如我所使用的就是黑色的主题。打开主题配置文件，修改如下配置：123456# 语法高亮主题# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties指定Markdown的解析器上边我们设置了语法高亮后，虽然在本地调试没有问题，然而当我们将博客部署到GitHub Pages和 Coding Pages后却发现，前者的页面不支持语法高亮，而后者支持。百度后才知道原来是因为 GitHub 默认使用的 Markdown 解析器不支持语法高亮，解决方法如下：打开站点配置文件_config.yml，在末尾添加如下内容：123markdown: redcarpetredcarpet: extensions: ["fenced_code_blocks", "autolink", "tables", "strikethrough"]接下来重新执行部署三连命令，就会发现 GitHub Pages 上部署的页面语法高亮显示成功了。推荐一些写得很齐全的文章链接hexo的next主题个性化配置教程打造个性超赞博客Hexo+NexT+GithubPages的超深度优化]]></content>
      <categories>
        <category>Hexo</category>
        <category>瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo瞎折腾系列</tag>
        <tag>Next主题</tag>
        <tag>主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 序列化的注意点]]></title>
    <url>%2Fposts%2F71bd19d3.html</url>
    <content type="text"><![CDATA[1、使用serialVersionUID在Eclipse中，如果一个类实现了Serializable接口，且没有给这个类设置一个serialVersionUID，就会有一个警告标志：The serializable class BaseEntity does not declare a static final serialVersionUID field of type long通过设置一个serialVersionUID可以解除该警告，虽然不设置该ID也可以，但若是实现了序列化，一定不能少这个serialVersionUID。之所以要设置该ID，原因如下：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。该serialVersionUID的值可以默认为1L，也可以用Eclipse直接生成。1private static final long serialVersionUID = 5647613333522643572L;2、静态变量不会被序列化序列化顾名思义，就是将实例对象的各种信息/状态存储到本地，而静态变量是属于类的，则不会被序列化，注意：序列化是针对实例变量的，和静态变量和方法无关。3、非静态的内部类必须实现序列化如果被序列化的对象中存在非静态的内部类，该内部类必须实现序列化，否则会报异常如果是静态内部类，则可以正常序列化外部类的实例对象4、如果实例变量是对象类型，则该对象类型的类必须实现序列化序列化要求所有的成员变量都实现了Serializable，比如String类型的变量。5、使用transient关键字阻止序列化实例变量如果不想要将某个实例变量序列化，可以使用transient关键字来阻止其序列化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo3.X.X版本无法生成baidusitemap]]></title>
    <url>%2Fposts%2F49fbb32a.html</url>
    <content type="text"><![CDATA[今天安装了hexo-generator-baidu-sitemap后，运行hexo g报错如下：到了作者的GitHub上发现也有人提了相关的issue，不过都过了相当一段时间了依然没有解决，最后还是自己动手丰衣足食，解决方法很简单，因为Hexo3.X.X版本改变了代码导致toArray()无法使用，我们直接将该方法去掉就行了。打开 node_modules\hexo-generator-baidu-sitemap\baidusitemap.ejs，将这里边的 post.tags.toArray() 和 post.categories.toArray() 改成 post.tags 和 post.categories，简单的说就是把这里的 toArray() 去掉，新版本的Hexo的tags和categories可以直接遍历。接下来重新运行 hexo g 和 hexo s，本地调试成功~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工程师成神之路(2018版本)]]></title>
    <url>%2Fposts%2F5044311b.html</url>
    <content type="text"><![CDATA[一、基础篇1.1 JVMJVM内存结构堆、栈、方法区、直接内存、堆和栈区别Java内存模型内存可见性、重排序、顺序一致性、volatile、锁、final垃圾回收内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定JVM参数及调优Java对象模型oop-klass、对象头HotSpot即时编译器、编译优化类加载机制classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）虚拟机性能监控与故障处理工具jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler编译与反编译javac 、javap 、jad 、CRF1.2 Java基础知识阅读源代码String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSetJava中各种变量类型熟悉Java String的使用，熟悉String的各种函数JDK 6和JDK 7中substring的原理及区别、replaceFirst、replaceAll、replace区别、String对“+”的重载、String.valueOf和Integer.toString的区别、字符串的不可变性自动拆装箱Integer的缓存机制熟悉Java中各种关键字transient、instanceof、volatile、synchronized、final、static、const 原理及用法。集合类常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因枚举枚举的用法、枚举与单例、Enum类Java IO&amp;Java NIO，并学会使用bio、nio和aio的区别、三种IO的用法与原理、nettyJava反射与javassist反射与工厂模式、 java.lang.reflect.*Java序列化什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全注解元注解、自定义注解、Java中常用注解使用、注解与反射的结合JMS什么是Java消息服务、JMS消息传送模型JMXjava.lang.management.、 javax.management.泛型泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法单元测试junit、mock、mockito、内存数据库（h2）正则表达式java.lang.util.regex.*常用的Java工具库commons.lang, commons.*… guava-libraries netty什么是API&amp;SPI异常异常类型、正确处理异常、自定义异常时间处理时区、时令、Java中时间API编码方式解决乱码问题、常用编码方式语法糖Java中语法糖原理、解语法糖1.3 Java并发编程什么是线程，与进程的区别阅读源代码，并学会使用Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors线程池自己设计线程池、submit() 和 execute()线程安全死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系锁CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁死锁volatilehappens-before、编译器指令重排和CPU指令重synchronizedsynchronized是如何实现的？synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例sleep 和 waitwait 和 notifynotify 和 notifyAllThreadLocal写一个死锁的程序写代码来解决生产者消费者问题守护线程守护线程和非守护线程的区别以及用法二、进阶篇2.1 Java底层知识字节码、class文件格式CPU缓存，L1，L2，L3和伪共享尾递归位运算用位运算实现加、减、乘、除、取余2.2 设计模式了解23种设计模式会使用常用设计模式单例、策略、工厂、适配器、责任链。实现AOP实现IOC不用synchronized和lock，实现线程安全的单例模式nio和reactor设计模式2.3 网络编程知识tcp、udp、http、https等常用协议三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包http/1.0 http/1.1 http/2之前的区别Java RMI，Socket，HttpClientcookie 与 sessioncookie被禁用，如何实现session用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则”了解nginx和apache服务器的特性并搭建一个对应的服务器用Java实现FTP、SMTP协议进程间通讯的方式什么是CDN？如果实现？什么是DNS？反向代理2.4 框架知识Servlet线程安全问题Servlet中的filter和listenerHibernate的缓存机制Hiberate的懒加载Spring Bean的初始化Spring的AOP原理自己实现Spring的IOCSpring MVCSpring Boot2.0Spring Boot的starter原理，自己实现一个starterSpring Security2.5 应用服务器知识JBosstomcatjettyWeblogic2.6 工具git &amp; svnmaven &amp; gradle三、高级篇3.1 新技术Java 8lambda表达式、Stream API、Java 9Jigsaw、Jshell、Reactive StreamsJava 10局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制Spring 5响应式编程Spring Boot 2.03.2 性能优化使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存3.3 线上问题分析dump获取线程Dump、内存Dump、gc情况dump分析分析死锁、分析内存泄露自己编写各种outofmemory，stackoverflow程序HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow常见问题解决思路内存溢出、线程死锁、类加载冲突使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题、当一个Java程序频繁FullGC时如何解决问题、如何查看垃圾回收日志、当一个Java应用发生OutOfMemory时该如何解决、如何判断是否出现死锁、如何判断是否存在内存泄露3.4 编译原理知识编译与反编译Java代码的编译与反编译Java的反编译工具词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化3.5 操作系统知识Linux的常用命令进程同步缓冲区溢出分段和分页虚拟内存与主存3.5 数据库知识MySql 执行引擎MySQL 执行计划如何查看执行计划，如何根据执行计划进行SQL优化SQL优化事务事务的隔离级别、事务能不能实现锁的功能数据库锁行锁、表锁、使用数据库锁实现乐观锁、数据库主备搭建binlog内存数据库h2常用的nosql数据库redis、memcached分别使用数据库锁、NoSql实现分布式锁性能调优3.6 数据结构与算法知识简单的数据结构栈、队列、链表、数组、哈希表、树二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树排序算法各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列、贪心算法、KMP算法、hash算法、海量数据处理3.7 大数据知识Zookeeper基本概念、常见用法Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。Hadoop，离线计算HDFS、MapReduce分布式日志收集flume，kafka，logstash数据挖掘，mahout3.8 网络安全知识什么是XSSXSS的防御什么是CSRF什么是注入攻击SQL注入、XML注入、CRLF注入什么是文件上传漏洞加密与解密MD5，SHA1、DES、AES、RSA、DSA什么是DOS攻击和DDOS攻击memcached为什么可以导致DDos攻击、什么是反射型DDoSSSL、TLS，HTTPS如何通过Hash碰撞进行DOS攻击用openssl签一个证书部署到apache或nginx四、架构篇4.1 分布式数据一致性、服务治理、服务降级分布式事务2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCCDubbo服务注册、服务发现，服务治理分布式数据库怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase分布式文件系统mfs、fastdfs分布式缓存缓存一致性、缓存命中率、缓存冗余4.2 微服务SOA、康威定律ServiceMeshDocker &amp; KubernetsSpring BootSpring Cloud4.3 高并发分库分表CDN技术消息队列ActiveMQ4.4 监控监控什么CPU、内存、磁盘I/O、网络I/O等监控手段进程监控、语义监控、机器资源监控、数据波动监控数据采集日志、埋点Dapper4.5 负载均衡tomcat负载均衡、Nginx负载均衡DNSDNS原理、DNS的设计CDN数据一致性五、扩展篇5.1 云计算IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess5.2 搜索引擎Solr、Lucene、Nutch、Elasticsearch5.3 权限管理Shiro5.4 区块链哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名比特币挖矿、共识机制、闪电网络、侧链、热点问题、分叉以太坊超级账本5.5 人工智能数学基础、机器学习、人工神经网络、深度学习、应用场景。常用框架TensorFlow、DeepLearning4J5.6 其他语言Groovy、Python、Go、NodeJs、Swift、Rust六、推荐书籍《深入理解Java虚拟机》《Effective Java》《深入分析Java Web技术内幕》《大型网站技术架构》《代码整洁之道》《Head First设计模式》《maven实战》《区块链原理、设计与应用》《Java并发编程实战》《鸟哥的Linux私房菜》《从Paxos到Zookeeper》《架构即未来》]]></content>
      <categories>
        <category>Java修仙</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java修仙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd - 批量重命名文件]]></title>
    <url>%2Fposts%2F79682f1b.html</url>
    <content type="text"><![CDATA[相信大家或多或少都遇到过类似的情况：从网上下载了好多图片(或者其他的文件)，这些图片的名字往往都是些乱七八糟的字母数字的组合，我们想要一次性修改几十张上百张的图片的名字应该怎么办呢？这里有两种方法，最简单的就是直接使用Windows自带的批量重命名方法；但是这种方法有缺陷，只能以固定的命名规律来命名。另一种方法就是通过dos命令来批量修改文件名。Windows自带的批量重命名选定所有你想修改的文件，然后右键菜单选择重命名，接下来输入随便一个名字，比如 photo，然后回车确定。接下来你就会看到被选中的 n 张图片都被重命名为从 photo (1) 到 photo (n) 这样的名字。如果你很介意名字中出现的(n)的格式，那么推荐你使用下边的方法来进行批量重命名文件。通过dos命令来批量修改文件名首先新建一个txt文件，然后修改名字为rename.bat(随便起名字，只是后缀必须是.bat)用编辑器打开该bat文件并输入以下dos命令并保存该文件(如果没有编辑器比如EditPlus之类的，就先在txt文件里输入以下dos命令再重新改名为.bat后缀的名字)1234567@echo offset a=0setlocal EnableDelayedExpansionfor %%n in (*.png) do (set /A a+=1ren "%%n" "bilibili_!a!.png")这里的命令表示将当前目录下的所有png后缀的图片都改名为bilibili_{a}.png，这里的{a}是从1开始到n的数字。双击执行该bat文件(注意该bat文件需要放在和要重命名的图片同一个目录下)，就会发现文件名变成了下图的样子：下图中红框标出来的三个地方可以随自己喜欢任意修改：]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DBeaver - 快捷键篇]]></title>
    <url>%2Fposts%2Fa815cce3.html</url>
    <content type="text"><![CDATA[公司使用的是 PostgreSQL 数据库，可以使用 pgAdmin或者 DBeaver 进行连接该数据库。个人更喜欢用 DBeaver，因为其界面更加美观，操作也相对简单。对于习惯了eclipse的开发者来说，DBeaver绝对是个不错的选择。DBeaver 是一个通用的数据库管理工具和 SQL 客户端，支持 MySQL, PostgreSQL, Oracle, DB2, MSSQL, Sybase, Mimer, HSQLDB, Derby, 以及其他兼容 JDBC 的数据库。DBeaver 提供一个图形界面用来查看数据库结构、执行 SQL 查询和脚本，浏览和导出数据，处理 BLOB/CLOB 数据，修改数据库结构等等。hot keyctrl + enter 执行sqlctrl + shift + ↑ 向上复制一行ctrl + shift + ↓ 向下复制一行ctrl + alt + F 对sql语句进行格式化，对于很长的sql语句很有用ctrl + d 删除当前行alt + ↑ 向上选定一条sql语句alt + ↓ 向下选定一条sql语句ctrl + / 行注释ctrl + shift+ / 块注释ctrl + f 查找、替换ctrl + space sql提示(如果写了from table后也会自动提示field)ctrl + shift + E 执行计划ctrl + shift + U 将选定的sql转换成大写字母ctrl + shift + L 将选定的sql转换成小写字母小技巧有一些快捷键在使用时，只需要将光标移动到某一条sql语句上就行，不需要选定整条完整的语句。有一些快捷键使用时是默认对当前一整个 Script 页面生效，可以通过光标来选定只想生效的范围。双击sql语句里的括号边缘，可以直接选定括号内的内容(不包括该括号)，这个功能很方便。添加双击单引号/双引号的内侧可以直接选定被单引号/双引号包括起来的内容。]]></content>
      <categories>
        <category>数据库</category>
        <category>可视化工具</category>
      </categories>
      <tags>
        <tag>数据库可视化工具</tag>
        <tag>DBeaver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 添加文章置顶功能]]></title>
    <url>%2Fposts%2F6ed0d627.html</url>
    <content type="text"><![CDATA[安装插件及其使用方法在站点根目录执行命令：12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save接下来在需要置顶的文章头部添加 top: true 或者 top: n，这里的n是数字，数字越大表示置顶等级越高。1234567title: XXXtags: - XXXcategories: - XXXdate: XXXtop: 100在文章标题下方添加置顶样式打开 themes/next/layout/_macro/post.swig，在 &lt;div class=&quot;post-meta&quot;&gt; 下方添加如下代码：1234567&#123;% if post.top %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;/span&gt; &lt;font color="red"&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 启用搜索功能]]></title>
    <url>%2Fposts%2F3e5e6b79.html</url>
    <content type="text"><![CDATA[安装搜索插件在站点根目录使用 git bash 执行命令：1npm install hexo-generator-searchdb --save启用搜索功能打开主题配置文件 _config.yml，修改如下配置：123456789101112131415# Local search# Dependencies: https://github.com/flashlab/hexo-generator-search# 本地搜索，需要安装 hexo-generator-search# 站点根目录执行：npm install hexo-generator-searchdb --savelocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button # auto表示改变输入就自动触发搜索 # manual表示按下回车键或搜索按钮才触发搜索 trigger: auto # show top n results per article, show all results by setting to -1 # 这里的数字n表示显示每篇文章搜索到的n个结果 # -1表示显示每篇文章搜索到的全部结果(不建议) top_n_per_article: 1]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 修改行内代码块的样式]]></title>
    <url>%2Fposts%2Fefd1caf6.html</url>
    <content type="text"><![CDATA[效果图打开 themes\next\source\css\_custom\custom.styl，添加如下样式：1234567/* 行内代码块的自定义样式 */code &#123; color: #d500fc; background: rgba(78, 240, 233, 0.42); margin: 2px; border: 1px solid #d6d6d6;&#125;]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 修改文章内的超链样式]]></title>
    <url>%2Fposts%2F770f091e.html</url>
    <content type="text"><![CDATA[a:link 效果图a:hover 效果图打开 themes\next\source\css\_custom\custom.styl，添加如下样式：123456789101112/* 文章内链接文本样式 */.post-body p a,.post-body li a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;这里选择 .post-body p a 是为了不影响文章标题和首页 阅读全文》 的样式，选择 .post-body li a 是为了对列表内的超链也有效果。总之，我们可以随意定义这里的具体样式。]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - 修改永久链接的默认格式]]></title>
    <url>%2Fposts%2Fff4321d8.html</url>
    <content type="text"><![CDATA[Hexo的永久链接的默认格式是 :year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。安装插件在站点根目录使用 git bash 执行命令：1npm install hexo-abbrlink --save修改站点配置文件打开根目录下的 _config.yml 文件，修改如下配置：123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex这里将页面都添加了 .html 的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。接下来重新部署三连，可以看到我们的文章路径变成了 /posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 让所有的文章链接在新窗口打开]]></title>
    <url>%2Fposts%2F4d58b14d.html</url>
    <content type="text"><![CDATA[打开 themes\next\layout\_macro\post-collapse.swig，修改这里的超链的target：1234567&lt;a class="post-title-link" href="&#123;&#123; url_for(post.path) &#125;&#125;" itemprop="url"&gt; &#123;% if post.type === 'picture' %&#125; &#123;&#123; post.content &#125;&#125; &#123;% else %&#125; &lt;span itemprop="name"&gt;&#123;&#123; post.title | default(__('post.untitled')) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125;&lt;/a&gt;接着打开 themes\next\layout\_macro\post.swig，修改这里的超链的target：123&lt;a class="post-title-link" href="&#123;&#123; url_for(post.path) &#125;&#125;" itemprop="url"&gt;&#123;# #&#125;&#123;&#123; post.title | default(__('post.untitled'))&#125;&#125;&#123;# #&#125;&lt;/a&gt;在这两个超链里添加 target=&quot;_blank&quot; ，最终修改如下：]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 对文章进行加密]]></title>
    <url>%2Fposts%2F15308.html</url>
    <content type="text"><![CDATA[阅读本文前需要先填写密码 123修改 JS 代码打开 themes\next\layout\_partials\head.swig，在文件的开头位置找到如下代码：1234&lt;meta charset="UTF-8"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/&gt;&lt;meta name="theme-color" content="&#123;&#123; theme.android_chrome_color &#125;&#125;"&gt;在上边代码的末尾添加如下代码：12345678910111213141516&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); if (history.length === 1) &#123; window.opener = null; window.open('', '_self'); window.close(); &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt;注意：网上其他的帖子是在这里选择输入密码错误后进行回退历史的操作，代码如下：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;我经过测试发现，这段代码有问题：如果当前页面是新打开的窗口，其历史页面只有一个，也就是history.length === 1时，就算不输入密码或者输入错误的密码，也会在提示密码错误之后成功进入文章页面！！！所以我们使用改良后的JS代码。给某篇文章设置密码添加完脚本代码，接下来在想要加密的文章的文件头加上 password 属性就行了，如下：123456789---title: XXXdate: XXXtags: - XXXcategories: - XXXpassword: 123---这样在打开这篇文章时只有输入了123这个密码才可以打开成功。]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 使用FontAwesome 5]]></title>
    <url>%2Fposts%2F55711.html</url>
    <content type="text"><![CDATA[NexT主题集成的是4.6.2版本的fontawesome，现在已经出了更高版本的了，修改fontawesome的版本有两种方式。方式一：直接修改主题配置文件打开主题配置文件 _config.yml，修改如下配置：123# Internal version: 4.6.2# See: http://fontawesome.io/fontawesome:在这里的 fontawesome: 后面直接添加上 fontawesome 的 CDN 就行了；不过不推荐这种改法，因为版本5的 fontawesome 改变了不少，直接在这里添加 fontawesome 5的 CDN 会导致原本的图标全部显示不出来。推荐方式二的改法。方式二：修改页面头文件的模板打开 themes\next\layout\_partials\head.swig，找到如下代码：1234&#123;% if theme.vendors.fontawesome %&#125; &#123;% set font_awesome_uri = theme.vendors.fontawesome %&#125;&#123;% endif %&#125;&lt;link href="&#123;&#123; font_awesome_uri &#125;&#125;" rel="stylesheet" type="text/css" /&gt;在上边的代码后插入 fontawesome 5 的 CDN：1&lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"&gt;如果这里的CDN链接无效，请去官网复制CDN链接：https://fontawesome.com/get-started]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题个性化 - 文章启用字数统计、阅读时长]]></title>
    <url>%2Fposts%2F22195.html</url>
    <content type="text"><![CDATA[安装 wordcount 插件在站点根目录打开 git bash，输入：1npm i --save hexo-wordcount该插件的具体使用方法可以参考 GitHub 上的仓库：https://github.com/willin/hexo-wordcount在主题配置文件启用该插件NexT主题本身就集成了该插件，在安装了该插件后直接启用就行了。进入主题配置文件 _config.yml，修改如下配置：1234567891011121314# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 文章字数展示设置post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: false # 该post_wordcount的所有设置另起一行显示 separated_meta: true自定义字数计数的显示样式启用了该插件后的显示样式也是可以自己修改的，进入 themes\next\layout\post.swig，找到如下代码，这里可以修改字数统计的样式：123456789101112&#123;% if not theme.post_wordcount.separated_meta %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt;&lt;/span&gt;&#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.wordcount') &#125;&#125;&amp;#58;&lt;/span&gt;&#123;% endif %&#125;&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt;下边是阅读时长的代码：1234567891011&#123;% if theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125; &amp;asymp;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt;&#123;% endif %&#125;改完样式后，再去 themes\next\languages 目录下找到你所使用的语言对应的 yml 文件，修改要显示的文本。比如我使用的语言是 zh-Hans，就修改 zh-Hans.yml里的文本：1234post: wordcount: 本文共计 min2read: 阅文耗时 totalcount: Site words total count]]></content>
      <categories>
        <category>NexT主题个性化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>NexT主题个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - 修改默认的post和draft的模板]]></title>
    <url>%2Fposts%2F1369.html</url>
    <content type="text"><![CDATA[修改默认的post和draft的模板通过hexo n post XXX或者hexo n draft XXX所生成的文章或草稿是根据默认的模板来生成的，我们可以自己来定制想要的模板。在站点根目录下的 scaffolds 文件夹下，存放着 draft.md， page.md 和 post.md这三个文件夹，一般我们只需要修改draft和post这两个模板就行了。我们可以在模板的文件头里添加自己想要的格式，如下：123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:---这样使用命令生成的draft或post都会默认带有上边的文件头了。添加新的模板来生成定制的post其实我们还可以在 scaffolds 目录下添加新的模板文件，比如 Hexo.md，其模板内容如下：12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: - Hexocategories: - Hexo---然后通过命令：1hexo n hexo XXX注意，这里的第二个 hexo 指的是我们刚刚新添加的模板文件 hexo.md 的文件名；这里的文件名和命令都是大小写不敏感的。执行完命令会在 source/_posts 目录下生成与 hexo.md 模板相对应的文章。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - 如何在文章中插入图片]]></title>
    <url>%2Fposts%2F12046.html</url>
    <content type="text"><![CDATA[网上有不少办法，有的是启用配置文件中的属性，有的则是安装插件，这里只介绍最简单的一种方法。在 source/ 目录下新建一个文件夹，比如 images；在该文件夹下存放各种图片资源，比如 test.jpg；新建一篇文章，在文章中使用markdown的插入图片语法：1![test](/images/test.jpg)这里使用的是绝对路径，如果使用相对路径比如images/test.jpg可能会无法访问到该图片资源。建议在博客或者配置中都使用绝对路径。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js、css外部文件的相对路径问题]]></title>
    <url>%2Fposts%2F29169.html</url>
    <content type="text"><![CDATA[如果js、css外部文件有使用到相对路径时，需要注意其相对路径的基准是不一样的。比如说，在index.html中引用到了外部的js和css文件，这两个文件都通过相对路径引用了某一张图片；这些文件所在的目录如下：12345678.├── js| └── index.js├── css| └── index.css├── images| └── bg.jpg└── index.htmljs文件的相对路径是以引用该js文件的页面为基准，所以在js文件中的相对路径是：123function changeImage()&#123; document.body.style.backgroundImage="url(images/bg.jpg)";&#125;css文件的相对路径是以自身的位置为基准，所以在css文件中的相对路径是：123.index_bg &#123; background-image: url(../images/bg.jpg);&#125;index.html的代码如下：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;index&lt;/title&gt;&lt;link rel="stylesheet" href="css/index.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;div class="index_bg"&gt;&lt;/div&gt;&lt;br&gt;&lt;button type="button" onclick="changeImage()"&gt;设置背景图片&lt;/button&gt;&lt;script src="js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;总结js文件的相对路径是以引用该js文件的页面为基准css文件的相对路径是以自身的位置为基准]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程(3) - 远程部署到GitHub Pages]]></title>
    <url>%2Fposts%2F1657.html</url>
    <content type="text"><![CDATA[本章讲的是如何将本地的个人项目远程部署到 GitHub Pages，涉及到GitHub的项目仓库、Git的使用，以及Hexo的远程部署等。一、安装 hexo-deployer-git 插件想要将Hexo项目部署到 GitHub上，需要先安装一个插件。在Hexo项目的根目录打开命令窗口，输入：npm install hexo-deployer-git --save 二、GitHub上创建一个仓库仓库的名字可以随便起，不过这个仓库是作为我们的博客仓库的，所以尽量将名字以 {username}.github.io 的形式来起。比如，我的GitHub用户名是lewky，我就会把这个仓库命名为lewky.github.io。（为什么要这样起名，后面会说明）三、修改本地的项目配置文件在 _config.yml 找到如下：1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type:把刚刚我们新建的GitHub仓库链接配置进来：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:/&#123;user&#125;/&#123;repository&#125;.git branch: master message:请注意，这里的仓库地址如果写成：https://github.com/{user}/{repository}.git可能会在后边的部署时无法成功，需要将https://github.com改成如下格式：1git@github.com:另外这里的branch和message可以不填，branch会默认是master分支，message会默认用下边的格式模板：1Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;四、SSH key的创建与配置最关键的一步来了，我们需要生成一对密钥对，然后将公钥配置到GitHub账号上。4.1 生成RSA密钥对首先使用 Git Bash 输入：1cd ~/.ssh~ 指的是当前用户的根目录，即 C:\Users\{user}\；而 .ssh 目录下一般存放着公开的SSH key文件：id_dsa.pubid_ecdsa.pubid_ed25519.pubid_rsa.pub此外还有个 known_hosts 文件，SSH会把我们每个访问过的计算机的公钥(public key)都记录在里面。如果在使用了 cd ~/.ssh 后能找到路径，那就把该目录下的 id_rsa.pub 文件里的内容复制到剪切板。如果找不到路径，就执行命令：1ssh-keygen -t rsa -b 4096 -C "your_email@example.com"该命令会生成新的SSH key，这里的参数含义：123-t: type，生成的密钥类型-b: bits，指定密钥长度，对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位，一般越长越安全。-C: comment，提供一个新注释接着会看到如下提示：1Enter file in which to save the key (/c/Users/123/.ssh/id_rsa):这里按下回车，表示将SSH key保存到默认地址，即：C:\Users\{user}\如果本身已经存在一个RSA私钥了，会提示你：12/c/Users/123/.ssh/id_rsa already exists.Overwrite (y/n)?这里输入 y 可以重新生成RSA密钥对；然后就会看到如下提示：1Enter passphrase (empty for no passphrase):这里按下回车，表示不设置密码；接着会再提示你输入重复密码，依然是按下回车。1Enter same passphrase again:这时候我们的SSH key就生成好了，去 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。4.2 在 GitHub 上配置SSH key接着登陆我们的 GitHub 账号：进入 Settings 页面选择 SSH and GPG keys点击 New SSH key填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来）然后在 Key 里将我们刚刚复制的公钥复制进去最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。4.3 验证ssh连接使用 Git Bash 输入：1ssh -T git@github.com接着会看到：123The authenticity of host 'github.com (192.30.253.112)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)?输入 yes，会看到：12Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Hi lewky! You've successfully authenticated, but GitHub does not provide shell access.这时候 github.com的公钥被保存到known_hosts文件里，如果我们再执行一次ssh -T git@github.com，就不需要输入yes了，会直接看到：1Hi lewky! You've successfully authenticated, but GitHub does not provide shell access.4.4 部署到 GitHub Pages输入命令：123hexo d或者hexo g -d后一条命令表示生成静态页面并部署到远处仓库，第一次部署会久一点，部署成功后会看到：12 * [new branch] HEAD -&gt; masterINFO Deploy done: git接着登陆 GitHub 并进入我们的项目仓库，可以看到已经多出了很多文件，且其 message 都是默认的格式：1Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;接下来点击 Settings 进入该仓库的设置页面，找到 Github Pages 这一项，选择以 Master 分支作为 source，然后保存；接下来这个仓库就会被部署到 https://{username}.github.io/{仓库名}。如果你希望直接通过 https://{username}.github.io/ 来访问你的博客，可以将仓库名改为 {username}.github.io；这样就不需要在url后边添加上仓库名来访问了。接下来，开始享受你的个人博客吧 :)]]></content>
      <categories>
        <category>Hexo</category>
        <category>搭建博客教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo-blog-demo</tag>
        <tag>Hexo搭建博客教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程(2) - 博客的简单个性化配置]]></title>
    <url>%2Fposts%2F38619.html</url>
    <content type="text"><![CDATA[本章主要讲博客的个性化，譬如站点的基本配置（语言、头像、站点图标等）、安装新的Hexo主题（NexT主题）以及主题的配置。一、修改站点配置打开站点配置文件 ，找到：12345678# Sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone:根据自己的需要去修改上边的配置，这些配置的注释如下：123456789101112131415# Site# 站点标题title: Hexo# 站点副标题subtitle:# 站点描述description:# 站点关键词keywords:# 站点主人author: John Doe# 站点语言language:# 站点时区timezone:1.1 language目前 NexT 支持的语言如下：语言languageEnglishen简体中文zh-HansFrançaisfr-FRPortuguêspt或者pt-BR繁體中文zh-hk或者zh-twРусский языкruDeutschde日本語jaIndonesianidKoreanko1.2 timezoneHexo 默认使用电脑的时区，也可以自己配置，比如：UTC+8 二、安装新主题Hexo有很多大佬开发的主题，很多人使用的是NexT主题，该主题也确实挺简洁好看的，新版本的NexT主题还可以选择四个主题。那么怎么安装新的Hexo主题呢？在我们的Hexo项目路径下，可以看到有个 themes 文件夹，这个文件夹就是用于存放主题文件的。2.1 下载 NexT 主题首先在Hexo项目的路径下打开命令窗口，如果你没有配置好Git的环境变量，请使用Git Bash。1git clone https://github.com/iissnan/hexo-theme-NexT themes/NexT注意，当前路径是你的Hexo项目根目录，使用上边的命令才能正确地将 NexT 主题clone到themes文件夹下的NexT文件夹里。接下来你会看到 themes 下多了个 NexT 文件夹，点进去你会看到个.git文件夹，将该文件夹删掉，否则到时候你无法将整个完整的Hexo项目push到GitHub上。2.2 启用 NexT 主题在Hexo项目中，有两个重要的配置文件 _config.yml；这两个配置文件一个在项目根目录下，一个在主题目录下。前者是站点配置文件，后者是主题配置文件，顾名思义，一个是Hexo项目的配置选项，一个是主题文件的配置选项。打开站点配置文件，用Windows自带的笔记本是无法打开该文件的，请使用其他的编辑器来打开，常见的编辑器有Notepad++，UltraEdit，EditPlus等。在站点配置文件中，找到：1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape默认的博客主题就是这个，我们将其修改为NexT；这里的主题是指在 themes 文件夹下的对应主题的文件夹名字。注意，在配置文件中所有的属性的值，都必须和前边的 : 之间留一个空格。比如下边的写法就是错误的，不加上空格的话会出错。1theme:landscape2.3 选择对应主题的外观 Scheme打开主题配置文件，找到下边的选项：123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini默认会使用Muse作为NexT主题的外观，通过将某个scheme前边的#去掉来启动某个外观，如下：123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini2.4 验证新主题依然是老操作——启动调试模式服务器：1hexo s --debug启动成功后，使用浏览器访问http://localhost:4000/，看看博客能否访问成功。三、修改 NexT 主题配置主题配置文件 _config.yml 位于 themes\NexT 之下。3.1 头像设置打开主题配置文件，找到如下：123456# 侧边栏头像# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif# 头像的路径可以放在主题对应文件夹的source里，也可以放在站点根目录的source里，建议放在站点路径上#avatar: /images/avatar.gif将avatar前边的#去掉，接着配置图片的路径即可。3.2 网站图标打开主题配置文件，找到如下：1234567891011# 将你的网站图标放到`&#123;站点根目录&#125;/source/` (推荐）或者`hexo-site/themes/NexT/source/images/`目录下# 默认的NexT主题的网站图标放在`&#123;站点根目录&#125;/themes/NexT/source/images/`目录下# 如果你想将自己的网站图标放到`&#123;站点根目录&#125;/source/`根目录下，必须将`/images`从路径中去掉# 如果你将网站图标放到了`&#123;站点根目录&#125;/source/images`路径下，需要令网站图标的名字和`&#123;站点根目录&#125;/themes/NexT/source/images/`路径下的网站图标不同，否则网站图标会使用后者的同名图标favicon: small: /images/favicon-16x16-NexT.png medium: /images/favicon-32x32-NexT.png apple_touch_icon: /images/apple-touch-icon-NexT.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml这里需要注意的是，网站图标一般是.ico或者.gif的类型，而且图标的大小一般只有几k而已，可以使用下边的网站制作个人的网站图标，建议先将原本的图标弄成正方形的。在线制作ico图标3.3 菜单设置打开主题配置文件，找到如下：123456789101112131415# 如果该站点是运行在子目录之下（比如：domain.tld/blog；这里的blog就是指我们的博客，前边的是上一级的域名），需要将路径前的斜杠去掉（/archives -&gt; archives；即是将原本的绝对路径改成了相对路径）。# 用法：`Key：/link/ || 菜单图标`# Key就是菜单名，如果对该菜单名进行了国际化，即将其翻译放到对应的languages文件夹中，将会根据你设置的语言进行加载对应的菜单名翻译；如果没有设置翻译，则会使用这里的Key作为菜单名。这里的Key是大小写敏感的。# 在`||`分隔符之前的值是该菜单对应的路径# 在`||`分隔符之后的值是FontAwesome的图标（不懂的请百度什么是FontAwesome以及其用法），如果不指定图标，将会自动使用question这个图标。menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat使用方法很简单，依然是将需要展示的菜单的前边的#去掉就行，更加具体的操作信息我已经在上边的注释中给出了。3.4 标签分类首先我们需要新建页面，在站点根目录打开命令窗口，分别输入命令：123hexo n page "categories"hexo n page "tags"hexo n page "about"接着你会发现在根目录的 source 目录下多出了上边的三个文件夹，里面各自有一个 index.md 文件。如果之前我们将menu里的categories，tags，about三个菜单解开了封印，那么在创建好这三个页面后就可以成功访问到，否则会报404请求错误。3.5 社交链接123456789101112# 如果不指定图标，会默认使用globe图标#social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype老规矩，去掉#注释就可以启动。]]></content>
      <categories>
        <category>Hexo</category>
        <category>搭建博客教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo-blog-demo</tag>
        <tag>Hexo搭建博客教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程(1) - 安装环境与本地搭建]]></title>
    <url>%2Fposts%2F22143.html</url>
    <content type="text"><![CDATA[前言搭建个人博客一般有两种选择，一个是使用WordPress，但是需要将博客搭建在服务器上，不过搭建好后写文章方便，适合没有程序基础的人使用。另一个是使用Hexo，相对简洁高效，不需要服务器，既可以部署在本地，也可以将博客部署到GitHub Pages上，支持Markdown语法，缺点是需要有Git基础，写文章比WordPress麻烦点。初次使用Hexo来搭建个人博客，确实比较手忙脚乱，这里记录一下流程，希望对大家能有所帮助。（注：本文是只针对Windows平台的搭建教程）有兴趣的可以戳下这里看看我的个人博客。How to play本教程一共分为3章：第一章是安装环境和本地搭建第二章是博客的个性化配置第三章是将博客部署到 GitHub Pages请根据自身需要选择章节，以节省时间。一、安装环境安装Node.js安装Git安装Hexo1.1 安装Node.jsHexo是一个基于Node.js的快速、简洁且高效的静态站点生成框架，想要安装Hexo，需要先安装Node.js，官网的安装包有两种，一种是安装程序.msi文件，一种是.zip压缩包，这里选择.msi文件，安装后会自动配置好环境变量。下载链接1.2 安装GitGit就不多说了，作为开发者或多或少都会接触过吧，直接前往官网下载安装包即可。操作教程网上也是一堆，这里就不赘述了。下载链接如果Git和Node.js的环境变量都配置好了，可以通过在cmd中确认安装结果。12git --versionnode -v1.3 安装Hexo安装好Node.js，就可以使用npm来安装Hexo1npm install -g hexo-cli安装完毕后，可以通过hexo version来确认是否安装成功。二、开始搭建个人博客千里之行，始于足下，在安装好所有的环境之后，我们终于可以开始搭建博客的第一步了。2.1 初始化Hexo项目首先是选择一个文件夹，用来给我们我们的个人博客的存放各种文件。接着进入该文件夹的路径，打开cmd命令窗口，这里有两种打开方式：按住Shift，同时点击鼠标右键，选择在此处打开命令窗口。在上方的地址栏里输入cmd，接着回车即可快速打开命令窗口。当然，你也可以直接Win+R然后输入cmd来打开命令窗口，不过需要再通过cd命令将路径切换到你指定的文件夹。接着输入指令来初始化你的博客1hexo init初始化成功后，你会看到Start blogging with Hexo!2.2 生成静态页面文件接下来，执行命令1hexo g该命令用来生成静态页面文件到public目录，Hexo会将 source 文件夹中除 posts 文件夹之外，以下划线_开头命名的文件或文件夹、以及隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。最后，我们只要启动Hexo服务器就行了。2.3 本地启动Hexo服务器1hexo s --debugHexo启动服务器的速度非常快，很快你就可以看到Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.恭喜你，你的个人博客已经搭建成功了，接下来只要在浏览器输入http://localhost:4000/就可以在本地访问你的博客了。这里使用hexo s也可以启动服务器，只不过加上--debug参数，如果运行中出错可以看到错误信息。2.4 关闭Hexo服务器要想关闭服务器，只需要在命令窗口按下Ctrl+C就可以了，这个组合键不仅仅用于关闭服务器，事实上你在cmd窗口中任何执行中的命令都可以用这个组合键来结束命令，只要连按两次该组合键就可以连输入Y或者N都不用。三、常用的命令12345678hexo new "postName" #新建文章hexo new page "pageName" # 新建页面hexo generate # 生成静态页面至public目录hexo server # 启动服务器(默认端口4000，'ctrl+c'关闭server)hexo deploy # 项目部署hexo help # 查看帮助hexo version # 查看Hexo的版本hexo clean # 清除Hexo的缓存上边的一些命令可以使用简写1234hexo nhexo ghexo dhexo s3.1 本地调试三连123hexo cleanhexo ghexo s --debug3.2 远程部署三连123hexo cleanhexo ghexo d注：在使用部署命令时，需要先用npm安装 hexo-deployer-git 插件：npm install hexo-deployer-git --save 四、撰写第一篇博文Hexo撰写博文也不难，分为 post 和 draft 两种，其中 post 存放在 source/_posts 目录下，draft 存放在 source/_drafts 目录下。post 和 draft 的区别在于前者会被发布到博客，而后者不会被发布。4.1 第一篇文章1hexo n post "my-first-post"Hexo会自动在 source/_posts 目录下新建一个名为 my-first-post 的 .md 文件；打开该文件，可以看到：12345---title: my-first-postdate: 2018-04-21 23:11:30tags:---这是 post 模板自动生成的 YAML 文件头，title 是这篇 post 的标题，可以将其改为 My First Post；date 是创建的日期；tags 是该 post 的标签，可以添加自定义的标签：1234567---title: My First Postdate: 2018-04-21 23:11:30tags: - demo - first-post---接着再进行本地调试三连，就可以看到刚刚写好的博文了。123hexo cleanhexo ghexo s --debug4.1 第一篇草稿创建命令和前边类似：1hexo n draft "my-first-draft"另外草稿的头文件是没有日期的：1234---title: my-first-drafttags:---草稿文件是不会被 hexo g 命令生成到public目录下的。]]></content>
      <categories>
        <category>Hexo</category>
        <category>搭建博客教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo-blog-demo</tag>
        <tag>Hexo搭建博客教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2Fposts%2Fd65a1577.html</url>
    <content type="text"><![CDATA[2019-04-24好久没更新博客了，这阵子确实忙了很多，人也颓唐了不少，是时候改变了，不能继续丧下去了……2019-04-23已经连续三天在食堂拿到半价的绿盘子了，可能预示着这阵子会运势上升？晚上买了半个榴莲吃，花了68块大洋，一斤18.8，虽然贵了点，但美味程度确实不错，好吃！2019-03-07今天是个神奇的日子。早上煮的鸡蛋是双黄蛋；上午同事报喜生了龙凤胎；中午食堂破天荒给了一对鸡翅；怎么形容今天呢？简直是JOJO的奇妙冒险级别的日子~2019-02-19猿宵节猿宵节：通常指程序猿通宵写代码的节日2019-02-18建站300天纪念！！2019-02-17下午看到附近的狗子躺在地上不停往空中踢腿，跟踩单车一样，百度了下也找不到类似的状况，emmm，这狗不会是在瘦腿吧……2019-02-14今天是情人节，公司刚好在这天进行开工拜神活动，收到个开工红包，顺带吃了波烤乳猪和烧鸡。这烤乳猪比去年的好吃不少！不沾酱料吃最好，咸咸的脆脆的，沾了白糖后反而很腻。2019-01-27时间过得真快，转眼就要回家过春节了，新的一年里也快过去头个月了。发现自己是真的越发懒散怠惰了，想想去年的这个时候，还心怀高远，精神焕发，再看看如今，去年定下的目标是越发地遥不可及了。应该怎么有效地调节情绪呢，总觉得自己是个有自知之明却没有自制之力的废材呀。。2019-01-08第一次吃牛奶草莓，闻起来确实很香，不过吃起来倒是和普通草莓差不多。2018-12-19不知道写点啥，最近一直状态不好，记录下之前写的几句诗歌吧~纵心猿，驰意马。秋风秋雨织秋意，春花春水鉴春光。2018-11-14双十一买的戴尔和三只松鼠终于都到了，开心！！2018-11-04这个周末看了整整两天的《乌龙闯情关》，还是以前的电视剧好看。剧中的刘病已、霍水仙、许平君、大牛、鸠摩空都让人印象深刻，也知道了故剑情深的典故。现在各种快餐文化，人心浮躁，还是以前的影视、小说作品让人回味无穷，我不是个怀旧的人，却对过去的一些回忆很有感怀。这些都是宝贵的精神食粮，可能是一首歌，也可能是荧幕中、笔墨下的一个人物，每每带给我鼓舞与勇气。我也要努力，冲鸭！2018-10-24今天是程序员节，在这个日子里，我终于将自己定制的hexo主题正式起名为Beep了~1024节日快乐~2018-10-18又看了一遍JOJO第四部的boss战，真是百看不厌，爱死JOJO了！2018-10-14每周都是等待JOJO新一集的煎熬和畅享JOJO新一集的舒爽……2018-10-08《逍遥游》完结了，又追完了一本小说，现在能看的书真的不多了。。2018-10-07好久没更新随笔了，这阵子人懒散了好多，肚子也多了几圈，国庆回到家里人人都说我胖了，确实，上班一年我竟然重了二十斤左右。要知道当初大一那会还不到一百斤，瘦的跟猴子似的，现在却已经一百二十多了。马上就要新的一年了，距离三十大关又进了一步，我时间不多啦，得加把劲践行自己的目标，顺便把肥给减了。。2018-09-18今天竟然被老大叫进去开了波会，会议中对我上半年的表现和绩效表示肯定，加薪之余望我能再接再厉。哈哈，还是挺开心的，感觉自己一直以来的努力没有白费，果然单身能促进生产力啊_(:з」∠)_2018-09-12今天早上看到唐家三少妻子去世的消息，有些震惊，心情不知道怎么形容，难受又复杂。高中最早接触的网络小说之一就是三少写的光之子，里边男主女主就是化用的他们夫妻两人的名字，到现在还记忆深刻。曾经受到三少的影响，很想去写书，只是时间无情，人很脆弱。。只能说句，三少，节哀。2018-09-01妈蛋啊！！昨晚买的榴莲千层蛋糕，本来是作为第二天早餐的，结果起床一看整个蛋糕都化水了，还发出腐烂的臭味！！我的心在滴血，八块钱的蛋糕就这么没了……2018-08-27卧槽，下了一天一夜的雨，第二天下班收衣服时发现上衣有半边被雨水打湿而发霉了……2018-08-27加班到九点半下班，赶上下大雨，然后雨伞又开始漏雨，好气哦。都买了三把雨伞了，怎么还是漏雨的货！伞外下大雨，伞内下小雨。2018-08-17今天是七夕，emmm单身汪岁2018-08-13自律真的很重要，我要培养自己的自律能力，毕竟已经是叔叔辈了……2018-08-06今晚一口气看了《刺客伍六七》这部国产动画，简直爽到！上一部让我看得这么酣畅淋漓的国产动画是《凸变英雄》，之前就经常瞥见刺客伍六七的消息，只是一直都听不起兴趣去看，直到今天无意间点开了第一集，之后就一发不可收拾了，还好没错过。2018-08-02建站100天！！！2018-07-29趁着这个月还没结束，赶紧开始撸品优购，还是敲完整的一个项目爽快~2018-07-28今天去看了《西虹市首富》，挺有趣的，沈腾还是那么好玩，开心麻花街的作品还是让人看得好开心。当初那个春晚小品《扶不扶》真的惊为天人，已经看过十几遍了，O(∩_∩)O哈哈~2018-07-15最近发现吃了香蕉后就会胃酸过多，也就是俗称的烧心。百度了下：香蕉性寒，脾胃虚寒、便溏腹泻者不能多食、生食，胃酸过的多者也不要吃香蕉，香蕉会增加胃酸分泌。所以最好不要空腹吃香蕉。明明以前吃香蕉都没什么事情，而且还是特地在饭后吃的，看来身体是真的越来越差了，要多锻炼才行。2018-06-13喝了这么多年的牛奶才尴尬地发现，原来我的肠胃会对牛奶过敏，一喝牛奶就会拉肚子，以前一直以为是其他原因，没想到是对牛奶过敏，看来以后只能喝酸奶了……2018-04-24在CSDN也写了一年的博客了，现在终于有了专属的个人博客了，用来记录自己平日里的感悟和积累~]]></content>
      <categories>
        <category>文心雕龙</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>文心雕龙</tag>
        <tag>影评</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站日志]]></title>
    <url>%2Fposts%2Fe62c38c4.html</url>
    <content type="text"><![CDATA[o(*￣▽￣*)ブ 持续更新中 2018-12-19最近发现打开页面略慢略卡，发现是jquery-backstretch的cdn加载不了，原本官网使用的cdn是cloudflare的，现在改成了另一个cdn地址。于是将jquery-backstretch的cdn修改了官网上最新的，总算变快了。2018-11-16将鼠标点击产生的文字设为不可选定2018-11-10解决在适配手机屏幕时，页面右上角的GitHub彩带被覆盖掉的问题。2018-09-18添加了图片懒加载插件hexo-lazyload-image出于强迫症，还是关闭了不蒜子的统计功能，目的是为了解决下边的问题二。2018-08-21最近发现了两个问题：如果文章不写小标题，是不会生成文章目录的，如果启用了leancloud的阅读计数功能，这时候这篇文章的阅读页面的侧边栏就会失去affix.js的固定定位效果；(该bug在火狐浏览器下偶尔会触发，在360浏览器下百分百触发)如果启用了不蒜子计数，在360浏览器下如果滚动页面时，侧边栏的底部无法和正文模块的底部持平，侧边栏底部会比正文模块的短一些。该问题在火狐浏览器下不存在。解决方案：问题一需要给每篇文章都起至少一个小标题，这样就会自动生成文章目录，也就不存在这个问题了。也可以选择关闭leancloud的阅读计数功能，重新生成静态页面就行了。问题二对于强迫症来说很难受，要么关闭不蒜子计数，要么不使用360浏览器。2018-08-18修改了hexo-neat的压缩选项，优化页面的加载2018-08-17添加了新的b站头像挂件添加头像挂件自动刷新功能2018-08-14去掉了文本首行缩进，首行缩进有个问题：当一个段落内存在换行时，比如使用&lt;br&gt;，会导致换行后无法缩进，不太好看；找了好久也没找到解决的方法，只能取消文本的首行缩进了。如果需要首行缩进还是自己手动添加&amp;emsp;&amp;emsp;(全角空格，即对应两个中文空格)……2018-07-30修改categories page的样式2018-07-26改善文章目录的换行问题添加文章不在首页显示的功能：在文件头里添加not_show: true即可启用2018-07-21添加了404页面2018-07-19修改代码块diff样式2018-07-10修改文本标题样式文本首行缩进两个字符2018-07-07添加网页标题监听事件2018-06-30代码块添加复制按钮2018-06-25修改about页面2018-06-20使用 hexo-neat 压缩博文插件，优化博客静态资源2018-06-16添加 Font Awesome 4.6.2的CDN，支持使用font awesome4或5友情链接里添加恶搞页面关于页面添加站点运行时间2018-06-16修改阅读全文按钮样式页脚爱心图形动画2018-06-16修改站点标题样式修改页脚样式添加站点背景图片轮播文章摘要添加标签2018-06-14修改文章标签样式2018-06-12使用 sitemap 和 baidusitemap2018-06-10改用来必力作为评论系统修改鼠标指针修改引用块样式2018-06-07添加友链并修改其样式2018-06-06启用 Gitment2018-06-05开启文章目录显示功能，替换掉显示错误的FontAwesome图标2018-06-04CDN有时候加载比较慢，所以去掉原本引入的 Font Awesome 4 和 Font Awesome Free CDN，直接将下载好的 Font Awesome 5 解压复制到 lib 目录下这里吐槽一下，由于 Font Awesome 从版本4升级到5修改了很多图标的名称，所以我花了一个多小时的时间去一个个替换这些改动的图标，累死…2018-06-03添加头像旋转2018-06-01去掉脚注超链的底部线条2018-05-31添加 custom.js 文件添加鼠标点击文字特效添加头像挂件点击事件2018-05-30设置文章摘要里的图片的最大宽度2018-05-27缩小文章摘要里标题和正文的间距2018-05-25修改预格式代码块(用tab键插入的代码块)的样式2018-05-17重新修改了头像挂件样式修改站点标题样式修改菜单栏样式2018-05-16将头部彩带图片保存到本地，避免因无法通过访问该图片(被墙)而显示不出来2018-05-14修改头像样式并添加了头像挂件(可耻地偷了波b站的头像挂件) ( ゜- ゜)つロ重修修改了加密文章的js代码，并将文章超链的打开方式复原 (눈_눈)2018-05-13修改文章超链的打开方式，添加文章置顶功能修改字体大小，关闭文章目录显示序号功能添加 by-nc-sa 许可协议，回到顶部按钮显示百分比修改文章内的超链样式、行内代码块的样式、回到顶部按钮样式启用搜索功能、顶部加载条去掉图片边框2018-05-12文章启用字数统计、阅读时长，修改其显示的样式使用 Font Awesome Free CDN ( upgrade from version 4 to 5 )添加文章加密功能指定 Markdown 的解析器修改 Hexo 永久链接的默认格式2018-05-11页面右上角添加 Fork me on GitHub2018-05-09修改 scaffolds 目录下的 post/draft.md 模板，并添加自定义的模板文件2018-05-07首页文章显示预览，添加字数统计和阅读时长2018-05-01添加建站日志2018-04-30启用 tags 和 categories 菜单2018-04-24使用 Hexo 搭建个人博客]]></content>
      <categories>
        <category>建站日志</category>
      </categories>
      <tags>
        <tag>建站日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证邮件地址的Java正则表达式]]></title>
    <url>%2Fposts%2F6c2d7772.html</url>
    <content type="text"><![CDATA[最近写了个Java正则表达式来验证RFC 5322规范的邮件地址，这个邮件地址比较复杂，对于这样一个地址：userName@domainName，它满足以下条件：对于userName1、允许使用以下所有字符作为用户名：[A-Z], [a-z], [0-9], [.], [-], [_], [@], [!], [#], [$], [%], [&amp;], [‘], [*], [+], [/], [=], [?], [^], [`], [{], [|], [}], [~]2、允许使用所有的ASCII字符，包括控制字符，前提条件是这些字符是被[\]所转义的或者被一对[“]所包括起来，比如下边的格式：“ [ ♥”或者\]都是合法的用户名3、[.]不能出现在用户名的开头或者结尾，也不能连续出现两个以上的[.]对于domainName1、只能使用[A-Z],[a-z],[0-9],[-]2、如果使用了[-]，那么该字符不能出现在域名的开头或结尾3、顶级域名不能全是数字4、至少要有二级域名Java正则表达式由于是用来验证邮件地址的，使用的是matches()这个完全匹配的方法，并且使用非捕获组来提高性能。写了两个正则表达式，一个是用来验证单个邮件地址的(比如xxx@xx.xx)；一个是用来验证多个邮件地址的，即多个邮件地址之间用空白符或者英文的逗号或分号分割开来(比如xxx@xx.xx; xx@xxx.xxx)。12345678910/** Regex format for multiple EmailValidator */public static final String MULTIPLE_EMAIL_REGEX_FORMAT = "(?:(?:%1$s)(?:(?:\\s*,\\s*)|(?:\\s*;\\s*)|\\s*$))*";/** Regex for single EmailValidator */public static final String SINGLE_EMAIL_REGEX = "(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~]|(?:\\\\[\\x00-\\xFF]?)|(?:\"[\\x00-\\xFF]*\"))+(?:\\.(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~])|(?:\\\\[\\x00-\\xFF]?)|(?:\"[\\x00-\\xFF]*\"))+)*)@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.)+(?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))";public static final Pattern SINGLE_EMAIL_REGEX_PATTERN = Pattern.compile(SINGLE_EMAIL_REGEX);/** Regex for multiple EmailValidator */public static final String MULTIPLE_EMAIL_REGEX = String.format(MULTIPLE_EMAIL_REGEX_FORMAT, SINGLE_EMAIL_REGEX);public static final Pattern MULTIPLE_EMAIL_REGEX_PATTERN = Pattern.compile(MULTIPLE_EMAIL_REGEX);上边验证单个邮件地址的正则表达式太长了，这里分一下行：12345public static final String SINGLE_EMAIL_REGEX = "(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~]|(?:\\\\[\\x00-\\xFF]?)|(?:\"[\\x00-\\xFF]*\"))+(?:\\.(?:(?:[A-Za-z0-9\\-_@!#$%&amp;'*+/=?^`&#123;|&#125;~])|(?:\\\\[\\x00-\\xFF]?)|(?:\"[\\x00-\\xFF]*\"))+)*)@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.)+(?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))";最后附上一些测试用的邮件地址1234567891011121314151617181920212223242526// =========TRUE EMAIL========== final String email = "Abc\\@def@example.com"; //true// final String email = "Fred\\ Bloggs@example.com"; //true// final String email = "Joe.\\\\Bloggs@example.com"; //true// final String email = "\"Abc@def\"@example.com"; //true// final String email = "\"Fred Bloggs\"@example.com"; //true// final String email = "user+mailbox@example.com"; //true// final String email = "customer/department=shipping@example.com"; //true// final String email = "$A12345@example.com"; //true// final String email = "!def!xyz%abc@example.com"; //true// final String email = "_somename@example.com"; //true// final String email = "Natasha.O'neill@thewarehouse.com"; //true// final String email = "ab.c@exam-ple.c--om"; // true// final String email = "------ab.c@example.12.com"; // true// final String email = "------ab.c@example.12.com "; // true// ==========FALSE EMAIL==========// final String email = "abc[@example.com"; //false// final String email = ".abc@example.com"; //false// final String email = "ab..c@example.com"; // false// final String email = "ab.c@example.com."; // false// final String email = "ab.c@example.com-"; // false// final String email = "------ab.c.@example.com"; // false// final String email = "------ab.c@-example-.com"; // false// final String email = "------ab.c@com"; // false// final String email = "------ab.c@example.12"; // false]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工作记录</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 如何修改web项目的web module version]]></title>
    <url>%2Fposts%2F4e16194f.html</url>
    <content type="text"><![CDATA[情景有时候我们想改变web项目的web module version，比如说原本是2.4版本，我们想改成3.0版本，通过右键项目名 -&gt; Properties -&gt; Project Facets，选中Dynamic Web Module后边的版本，将2.4改成3.0这时候会报错误：Cannot change version of project facet Dynamic Web Module to 3.0.而且这时候改动web.xml的文件头从2.4改成3.0版本的文件头也会报错。解决办法1、这时候我们需要找到该项目的目录，进入.setting文件夹，打开org.eclipse.wst.common.project.facet.core.xml2、我们可以发现在这个xml文件中，有这样一个标签：1&lt;installed facet="jst.web" version="2.4"/&gt;3、将这里的version改成你想要的版本，比如改成3.04、保存该文件的改动，接着刷新Eclipse中的该项目(左键选中项目名，按F5刷新项目)5、接着再去Properties -&gt; Project Facets ， 将Dynamic Web Module改为3.0；然后将web.xml的文件头改为对应3.0版本的文件头；此时会发现可以修改成功而不会报错。]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Ready Player One》观后感]]></title>
    <url>%2Fposts%2F23475.html</url>
    <content type="text"><![CDATA[这部电影国内译名又叫头号玩家、玩家一号，讲述的是在未来人们为了躲避一团糟的现实而沉迷于一个名为绿洲的现实虚拟游戏。虽然这部电影并没有直接传达什么正能量的道理之类的，但是这部3D电影所展现出来的绿洲的奇妙与各种彩蛋却是令人看得目不暇接、直呼过瘾。这绝对是一部值得去电影院大饱眼福的爽快作品！]]></content>
      <categories>
        <category>文心雕龙</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>文心雕龙</tag>
        <tag>影评</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小萝莉的猴神大叔》观后感]]></title>
    <url>%2Fposts%2F73.html</url>
    <content type="text"><![CDATA[今天去看了这部评分高达9.6分的印度电影，确实是挺好看的。这是讲述一个印度摩罗神信徒在没有护照和签证的情况下，不惜越过边境也要坚持将一个异国走失的哑巴小女孩送回巴基斯坦的父母家里的故事。印巴两国之间的仇恨，迥异的宗教信仰、森严的种姓制度都令我印象深刻。就算是宗教信仰不同，也不应当局限于各自的神明教义，神明传播于世间的是爱，而不是仇恨，不同的宗教信仰，也是有着共通的点。而上一代人的仇恨，也不应归结到下一代的孩子身上。仇恨的故事固然吸引眼球，但是爱的故事更应该被关注传颂。对于印巴两国的大人来说，对方即是邪恶，但是战争本就如此，不存在绝对的正义与邪恶，只有恪守信仰、遵从心中那杆爱与公正的天秤的一方，才是真正无愧于心的正义者。]]></content>
      <categories>
        <category>文心雕龙</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>文心雕龙</tag>
        <tag>影评</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - pl/pgsql的DO关键字]]></title>
    <url>%2Fposts%2Fd98f1635.html</url>
    <content type="text"><![CDATA[pl/pgsql即Procedural Language/ Postgres SQL(过程化sql语言)，是Postgresql数据库对sql语句的扩展，可以在pl/pgsql代码块内定义多条sql语句，每条语句以分号结束，代码块由begin开始，end结束，代码块的最后一个end可以不加分号。DO关键字用来执行一段匿名代码块，即在在程序语言过程中一次性执行的匿名函数。代码块可以看做是一段没有参数、没有返回值的函数体。其格式如下：1DO [LANGUAGE lang_name] code;codecode block代码块实际上为一个字符串，可以用”美元符引用”$$书写字符串常量，$$中间可以包含标签名，可以自由命名，但是不能以数字开头，可以命名为$$，$_$，$a$，$a1$...，该标签名必须成对出现，且大小写敏感。用DECLARE声明变量(如果不需要声明变量可以不写declare)，用BEGIN和END包括需要执行的代码/sql语句，每个语句末尾需要加上分号，BEGIN不加分号，代码块最后一个END后可以省略分号；其格式如下：12345DO $body$BEGIN update student set name = '张小明' where id = 10010;END$body$;12345678DO $body$DECLARE NEW_NAME varchar(100);BEGIN NEW_NAME:='张'||'小明'; update student set name = NEW_NAME where id = 10010;END$body$;lang_name用来解析code的程序语言的名字，如果缺省，默认为plpgsql，lang_name可以写在code前，也可以写在code后，即1DO code;等效于下边的1DO LANGUAGE PLPGSQL code;或者1DO code LANGUAGE PLPGSQL;这里的code指的是代码块，也就是上边说的内容格式。一个例子123456789101112131415161718DO $body$DECLARE SIZES_VALUE varchar(1000); MEASUREMENT_TEMPLATE RECORD;BEGIN FOR MEASUREMENT_TEMPLATE IN (SELECT ID FROM CNT_MEASUREMENT_TEMPLATE WHERE DOMAIN_ID IN (&apos;/&apos;,&apos;RD1&apos;,&apos;RD2&apos;) AND IS_LATEST = TRUE AND (SIZES IS NULL OR SIZES = &apos;&apos;)) LOOP -------- split sizes value from CNT_MEASUREMENT_TEMPLATE_SIZE order by seq_no -------- SIZES_VALUE = (SELECT ARRAY_TO_STRING(ARRAY(SELECT ALT_LABEL||CASE WHEN COALESCE(LABEL,&apos;&apos;) = &apos;&apos; THEN &apos;&apos; ELSE &apos;(&apos;||LABEL||&apos;)&apos; END FROM CNT_MEASUREMENT_TEMPLATE_SIZE WHERE PARENT_ID = MEASUREMENT_TEMPLATE.ID ORDER BY SEQ_NO),&apos;, &apos;)); -------- set sizes value for cnt_measurement_template whose sizes value is null or &apos;&apos; -------- UPDATE CNT_MEASUREMENT_TEMPLATE SET SIZES = SIZES_VALUE WHERE ID = MEASUREMENT_TEMPLATE.ID; END LOOP;END;$body$ LANGUAGE PLPGSQL;参考1.https://www.cnblogs.com/wangzhen3798/p/7630597.html2.https://www.2cto.com/database/201505/399624.html]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊的空格-ASCII码值160]]></title>
    <url>%2Fposts%2Fb226c16f.html</url>
    <content type="text"><![CDATA[问题与分析最近遇到个问题，在页面的搜索框输入带有空格的字符串时，总是无法从db中搜索出来对应的数据，于是将db里的空格复制出来，发现其ASCII码值为160，这才知道，原来ASCII码中除了32之外还有160这个特殊的空格。下边是查看字符对应ASCII值的逻辑：1234final char c1 = ' '; //db里的空格final char c2 = ' '; //手动输入的空格System.out.println((int)c1); //160System.out.println((int)c2); //32平时我们用键盘输入的空格的ASCII值是32，而这个ASCII值为160的空格，其实是不间断空格(non-breaking space)，是不是从来没听说过这东东？其实你平时一定也用过很多次的，就是页面上的&amp;nbsp;所产生的空格。不间断空格non-breaking space的缩写正是nbsp。这中空格的作用就是在页面换行时不被打断，如下：1页面某一行的末尾是一个人名Zhang Xiaoming我们希望在换行时人名不会被打断，导致Zhang 在第一行末尾，而Xiaoming跑到第二行开头，而是保持完整的人名在同一行的末尾，于是就有了不间断空格。(在word中也有这种空格的使用)如果使用了平常的空格，就会被页面压缩，变成下边这样12页面某一行的末尾是一个人名Zhang Xiaoming不间断空格的去除但是不间断空格有个问题，就是它无法被trim()所裁剪，也无法被正则表达式的\s所匹配，也无法被StringUtils的isBlank()所识别，也就是说，无法像裁剪寻常空格那样移除这个不间断空格。我们可以利用不间断空格的Unicode编码来移除它，其编码为\u00A0。解决办法如下：123456replace("\u00A0", "")replaceAll("\\u00A0+", "") //这是正则表达式的写法String str = "aacsdfe "; //包含了不间断空格的字符串str = str.replace("\u00A0", "");str = str.replaceAll("\\u00A0+", "");]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
        <tag>nbsp</tag>
        <tag>不间断空格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL - null和''的区别与判断以及COALESCE函数]]></title>
    <url>%2Fposts%2F9f80621c.html</url>
    <content type="text"><![CDATA[null和’’的区别与判断null是一种类型，&#39;&#39;是空字符串，打个比方，&#39;&#39;是你参加了考试且得了零分，而null则是你压根就没有参加考试。如果要在sql中对两者进行判断，是有区别的：12345678//null只能和is或is not搭配，不能使用=、!=或者&lt;&gt;select * from student where name is null;select * from student where name is not null;//''的判断可以使用=、!=或者&lt;&gt;select * from student where name = '';select * from student where name != '';select * from student where name &lt;&gt; '';使用COALESCE函数COALESCE函数是返回参数中的第一个非null的值，它要求参数中至少有一个是非null的，如果参数都是null会报错。123456select COALESCE(null,null); //报错select COALESCE(null,null,now(),''); //结果会得到当前的时间select COALESCE(null,null,'',now()); //结果会得到''//可以和其他函数配合来实现一些复杂点的功能：查询学生姓名，如果学生名字为null或''则显示“姓名为空”select case when coalesce(name,'') = '' then '姓名为空' else name end from student;]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL - ROW_NUMBER() OVER()函数]]></title>
    <url>%2Fposts%2Fd8914798.html</url>
    <content type="text"><![CDATA[ROW_NUMBER() OVER()函数用来为每条记录返回一个行号，可以用来对记录进行排序并返回该序号，序号从1开始排序。这里的over()是聚集函数，可以给记录进行分组、排序；row_number()不能单独使用，必须搭配over()才能使用，否则会报错。简单地返回的行号12给student的每条记录进行排序并返回序号select *, row_number() over() from student;numclassnamerow_number10001小明110012小白210022小黑3给返回的行号起个别名1select *, row_number() over() rank from student;numclassnamerank10001小明110012小白210022小黑3配合partition by/order by12给每个班的学生按照学号递减的顺序返回行号select *, row_number() over(partition by class order by num desc) rank from student;numclassnamerank10001小明110022小黑110012小白2]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL笔记-查看表的主外键等约束关系]]></title>
    <url>%2Fposts%2F90196397.html</url>
    <content type="text"><![CDATA[12345678910SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name, tc.is_deferrable,tc.initially_deferred FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = &apos;FOREIGN KEY&apos; AND tc.table_name = &apos;your table name&apos;;constraint_type有四种：UNIQUE、PRIMARY KEY、CHECK、FOREIGN KEY通过修改上边sql语句的table_name和constraint_type来进行相应的查询]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd - 如何在bat文件中调用另一个bat文件]]></title>
    <url>%2Fposts%2F39f5b6b2.html</url>
    <content type="text"><![CDATA[情景一：两个bat文件在同一个目录下有时候我们需要在一个bat文件中调用另一个bat文件，比如我们想在a.bat中调用b.bat，如下。a.bat12345@echo offecho I am a.bat...echo now run the b.batcall b.batecho overb.bat12@echo offecho I am b.bat...在cmd窗口中执行a.bat，结果如下：1234I am a.bat...now run the b.batI am b.bat...over通过call命令，我们可以调用另一个bat文件，执行完会再返回到原本的bat文件中继续执行。但是这里有个问题，就是两个bat文件必须在同一个目录下，否则会找不到要call的bat文件。情景二：两个bat文件不在同一个目录下假如要call的bat文件在其他目录，我们可以在call之前，先使用cd /d 目录来进入相应的目录，接着再call就行了，如下：a.bat123456@echo offecho I am a.bat...echo now run the b.batcd /d D:\testcall b.batecho overb.bat12@echo offecho I am b.bat...执行后得到结果如下：1234I am a.bat...now run the b.batI am b.bat...over不过，这里需要注意的是，此时执行完命令的cmd窗口的当前目录是b.bat所在的目录了，而不是a.bat的目录。情景三：开启一个新的cmd窗口来运行另一个bat文件假如我们希望另外启动一个新的cmd窗口来运行b.bat，可以通过start cmd命令来实现，如下：a.bat123456@echo offecho I am a.bat...echo now run the b.batcd /d D:\teststart "" cmd /k call b.batecho overb.bat12@echo offecho I am b.bat...执行后得到结果如下：原本的cmd窗口中：123I am a.bat...now run the b.batover新的cmd窗口中：1I am b.bat...这里简单解释下该命令的参数：1start "" cmd /k call b.bat&quot;&quot;是一段字符串，代表新打开的cmd窗口的名字，可以随便起名。/k是表示新打开的cmd窗口在执行完命令后保存打开状态，如果希望执行完就关闭窗口就使用/ccall b.bat表示call命令，即调用b.bat文件；该命令可以用&quot;&quot;括起来，即：&quot;call b.bat&quot;]]></content>
      <categories>
        <category>计算机</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL - 8小时连接闲置超时]]></title>
    <url>%2Fposts%2F1a76cb2d.html</url>
    <content type="text"><![CDATA[问题与分析最近发现之前部署在阿里云的一个web项目，每过一段时间就会报错，但是刷新下页面就会显示正常；在过了比较长的一段时间后，又会报同样的错误，如下：12345678com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failureThe last packet sent successfully to the server was *,*** milliseconds ago. The driver has not received any packets from the server. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:526) at com.mysql.jdbc.Util.handleNewInstance(Util.java:408) at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1137)在网上查了下资料，原来是因为项目中使用了连接池，由于连接池里的连接长时间闲置着，而MySQL默认的非交互式连接的闲置时间是8小时；也就是说，当连接池里的连接闲置超过8小时后就会被MySQL数据库自动断开而失效。由于连接池并不知道连接已经失效了，依然保持着这些失效的连接，这导致web项目在一段时间后访问页面时报错，而在刷新页面后连接池重新获取了有效的连接，所以项目又可以正常访问了。这里涉及到MySQL关于交互式连接和非交互式连接的概念。交互式连接通俗的说，在cmd里直接和MySQL进行各种sql操作的连接方式就是交互式连接，这里走的是TCP协议。非交互式连接而直接在项目中对MySQL进行sql操作的方式则是非交互式连接，我们的应用服务器通过Hibernate或者JDBC来实现和数据库的通信。怎么解决连接闲置超时的问题？这两种连接方式都有各自对应的一个超时时间属性，交互式连接是interactive_timeout；非交互式连接是wait_timeout。既然是闲置超时，那么解决的办法也很简单，就是直接将这个时间设置得更长些；在MySQL中最多可以设置到365天(即31536000，默认单位是s)，有两种设置的方法。第一种设置方式：修改配置文件my.ini文件该配置文件在MySQL的安装目录下，如果没有此文件，可以复制my-default.ini文件，将生成的复件重命名成my.ini；然后在文件中添加如下语句：12wait_timeout=31536000 interactive_timeout=31536000如果没有这两个语句则表示默认值是8小时(60608=28800)；需要注意的是，wait_timeout的最大值分别是24天/365天(Windows/Linux)。第二种设置方式：使用mysql命令进行修改12set global interactive_timeout=设置值set global wait_timeout=设置值不过闲置时间设置得过大并不好，MySQL里大量的SLEEP连接无法及时释放，拖累系统性能；设置得过小又容易产生如上所述的错误；由于我们的web项目中经常会使用到连接池技术，所以我们有更好的解决方法，那就是在项目中设置连接池的属性。在项目中设置连接池的属性我的项目是使用的c3p0，所以这里只介绍c3p0的设置方法，如下：方法一：减少连接池内连接的生存周期既然MySQL连接的默认闲置时间是8小时，那么只要将连接池内连接的生产周期设置得比8小时短就行了。1234&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 连接的最大空闲时间，若超过该时间还没被使用过则会自动断开，单位为s，默认为0(即永远不会断开) --&gt; &lt;property name="maxIdleTime" value="1800"/&gt; &lt;/bean&gt;方法二：定期使用连接池内的连接12345678910111213141516&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个可以显著提高测试速度。 注意：测试的表必须在初始数据源的时候就存在。Default:null --&gt; &lt;property name="preferredTestQuery" value="SELECT 1"/&gt; &lt;!-- 每1800秒检查所有连接池中的空闲连接 --&gt; &lt;property name="idleConnectionTestPeriod" value="1800"/&gt; &lt;!-- 如果设置为true，则每次从池中取一个连接就做一下测试，使用automaticTestTable或者preferredTestQuery来做一条查询语句。 看看连接好不好用，如果不好用就关闭它，接着重新从池中拿一个。 --&gt; &lt;property name="testConnectionOnCheckout" value="true"/&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven - 关于编码GBK的不可映射字符的问题]]></title>
    <url>%2Fposts%2F86689e1.html</url>
    <content type="text"><![CDATA[问题与分析之前都是用的Eclipse的Maven插件执行命令，后来偶然在最近完成的一个小项目的根目录里打开cmd，执行mvn clean package报编码GBK的不可映射字符的问题。明明之前在Eclipse上打成war包没问题，为什么用cmd执行package命令就会报错？在网上查了下资料，是因为没有在pom.xml文件中添加编译插件的编码字符集，如下：1234567891011121314&lt;build&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;utf8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;这里的source和target的1.7指的是编译时使用jdk1.7版本；而encoding指定了utf8编码（我测试了下，发现写utf-8也可以）。补充mvn clean package命令的执行顺序使用cmd的cd命令进入要打包的项目的根目录，也可以直接进入到该项目的根目录，然后按住Shift键+鼠标右键，选择在此处打开命令窗口接下来输入mvn clean package，这里的clean是为了在package之前清理掉已有的target目录。之后打包成功会出现BUILD SUCCESS的字样，而在打包过程中，会发现cmd的窗口出现一大堆东西，这里说一下这个mvn clean package命令的执行顺序。执行顺序使用清理插件maven-clean-plugin清理已有的target目录（使用了clean才有这一步）使用资源插件maven-resources-plugin处理资源文件使用编译插件maven-compiler-plugin编译所有源文件生成class文件到target/classes目录下使用资源插件maven-resources-plugin处理测试用的资源文件使用编译插件maven-compiler-plugin编译测试用的源码正常class文件到target/test-classes目录下使用测试插件maven-surefire-plugin运行测试用例使用打包插件maven-jar-plugin对编译后生成的文件进行打包，包名和配置的finalName一致，打包后的文件存放在target目录下备注：不管是compile、package还是install等前三个步骤都是必不可少的。参考链接http://www.cnblogs.com/frankyou/p/6062179.htmlhttp://blog.csdn.net/zyf_balance/article/details/50910521]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发秒杀API(四)之高并发优化]]></title>
    <url>%2Fposts%2F43941.html</url>
    <content type="text"><![CDATA[1. 高并发优化分析关于并发并发性上不去是因为当多个线程同时访问一行数据时，产生了事务，因此产生写锁，每当一个获取了事务的线程把锁释放，另一个排队线程才能拿到写锁，QPS(Query Per Second每秒查询率)和事务执行的时间有密切关系，事务执行时间越短，并发性越高，这也是要将费时的I/O操作移出事务的原因。在本项目中高并发发生在哪？在上图中，红色的部分就表示会发生高并发的地方，绿色部分表示对于高并发没有影响。为什么需要单独获取系统时间？这是为了我们的秒杀系统的优化做铺垫。比如在秒杀还未开始的时候，用户大量刷新秒杀商品详情页面是很正常的情况，这时候秒杀还未开始，大量的请求发送到服务器会造成不必要的负担。我们将这个详情页放置到CDN中，这样用户在访问该页面时就不需要访问我们的服务器了，起到了降低服务器压力的作用。而CDN中存储的是静态化的详情页和一些静态资源（css，js等），这样我们就拿不到系统的时间来进行秒杀时段的控制，所以我们需要单独设计一个请求来获取我们服务器的系统时间。CDN（Content Delivery Network）的理解获取系统时间不需要优化因为Java访问一次内存（Cacheline）大约10ns，1s=10亿ns，也就是如果不考虑GC，这个操作1s可以做1亿次。秒杀地址接口分析无法使用CDN缓存，因为CDN适合请求对应的资源不变化的，比如静态资源、JavaScript；秒杀地址返回的数据是变化的，不适合放在CDN缓存；适合服务端缓存：Redis等，1秒钟可以承受10万qps。多个Redis组成集群，可以到100w个qps. 所以后端缓存可以用业务系统控制。秒杀地址接口优化秒杀操作优化分析无法使用cdn缓存后端缓存困难： 库存问题一行数据竞争：热点商品大部分写的操作和核心操作无法使用CDN，也不可能在缓存中减库存。你在Redis中减库存，那么用户也可能通过缓存来减库存，这样库存会不一致，所以要通过mysql的事务来保证一致性。比如一个热点商品所有人都在抢，那么会在同一时间对数据表中的一行数据进行大量的update set操作。行级锁在commit之后才释放，所以优化方向是减少行级锁的持有时间。延迟问题很关键同城机房网络（0.5ms~2ms），最高并发性是1000qps。Update后JVM -GC(垃圾回收机制)大约50ms，最高并发性是20qps。并发性越高，GC就越可能发生，虽然不一定每次都会发生，但一定会发生。异地机房，比如北京到上海之间的网络延迟，进过计算大概13~20ms。如何判断update更新库存成功？有两个条件：update自身没报错；客户端确认update影响记录数优化思路：把客户端逻辑放到MySQL服务端，避免网络延迟和GC影响如何把客户端逻辑放到MySQL服务端有两种方案：定制SQL方案，在每次update后都会自动提交，但需要修改MySQL源码，成本很高，不是大公司（BAT等）一般不会使用这种方法。使用存储过程：整个事务在MySQL端完成，用存储过程写业务逻辑，服务端负责调用。接下来先分析第一种方案根据上图的成本分析，我们的秒杀系统采用第二种方案，即使用存储过程。优化总结前端控制暴露接口，按钮防重复（点击一次按钮后就变成灰色，禁止重复点击按钮）动静态数据分离CDN缓存，后端缓存事务竞争优化减少事务行级锁的持有时间2. Redis后端缓存优化编码关于CDN的说明由于不同公司提供的CDN的接口暴露不同，不同的公司租用的机房调用的API也不相同，所以慕课网的视频中并没有对CDN的使用过程进行讲解。2.1 下载安装Redis前往官网下载安装Stable版本的Redis，安装后可以将安装目录添加到系统变量Path里以方便使用，我使用的是Windows系统的Redis，懒得去官网下载的可以点这里下载。安装后，运行redis-server.exe启动服务器成功，接着运行redis-cli.exe启动客户端连接服务器成功，说明Redis已经安装成功了。为什么使用RedisRedis属于NoSQL，即非关系型数据库，它是key-value型数据库，是直接在内存中进行存取数据的，所以有着很高的性能。利用Redis可以减轻MySQL服务器的压力，减少了跟数据库服务器的通信次数。秒杀的瓶颈就在于跟数据库服务器的通信速度（MySQL本身的主键查询非常快）2.2 在pom.xml中配置Redis客户端123456&lt;!--添加Redis依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;JedisRedis有很多客户端，我们的项目是用Java语言写的，自然选择对应Java语言的客户端，而官网最推荐我们的Java客户端是Jedis，在pom.xml里配置了Jedis依赖就可以使用它了，记得要先开启Redis的服务器，Jedis才能连接到服务器。由于Jedis并没有实现内部序列化操作，而Java内置的序列化机制性能又不高，我们是一个秒杀系统，需要考虑高并发优化，在这里我们采用开源社区提供的更高性能的自定义序列化工具protostuff。2.3 在pom.xml中配置protostuff依赖1234567891011&lt;!--prostuff序列化依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt;&lt;/dependency&gt;关于序列化和反序列化序列化是处理对象流的机制，就是将对象的内容进行流化，可以对流化后的对象进行读写操作，也可以将流化后的对象在网络间传输。反序列化就是将流化后的对象重新转化成原来的对象。在Java中内置了序列化机制，通过implements Serializable来标识一个对象实现了序列化接口，不过其性能并不高。2.4 使用Redis优化地址暴露接口原本查询秒杀商品时是通过主键直接去数据库查询的，选择将数据缓存在Redis，在查询秒杀商品时先去Redis缓存中查询，以此降低数据库的压力。如果在缓存中查询不到数据再去数据库中查询，再将查询到的数据放入Redis缓存中，这样下次就可以直接去缓存中直接查询到。以上属于数据访问层的逻辑（DAO层），所以我们需要在dao包下新建一个cache目录，在该目录下新建RedisDao.java，用来存取缓存。RedisDao12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class RedisDao &#123; private final JedisPool jedisPool; public RedisDao(String ip, int port) &#123; jedisPool = new JedisPool(ip, port); &#125; private RuntimeSchema&lt;Seckill&gt; schema = RuntimeSchema.createFrom(Seckill.class); public Seckill getSeckill(long seckillId) &#123; // redis操作逻辑 try &#123; Jedis jedis = jedisPool.getResource(); try &#123; String key = "seckill:" + seckillId; // 并没有实现哪部序列化操作 // 采用自定义序列化 // protostuff: pojo. byte[] bytes = jedis.get(key.getBytes()); // 缓存重获取到 if (bytes != null) &#123; Seckill seckill = schema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, seckill, schema); // seckill被反序列化 return seckill; &#125; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; public String putSeckill(Seckill seckill) &#123; try &#123; Jedis jedis = jedisPool.getResource(); try &#123; String key = "seckill:" + seckill.getSeckillId(); byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE)); // 超时缓存 int timeout = 60 * 60;// 1小时 String result = jedis.setex(key.getBytes(), timeout, bytes); return result; &#125; finally &#123; jedis.close(); &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125;&#125;注意使用protostuff序列化工具时，被序列化的对象必须是pojo对象（具备setter/getter）在spring-dao.xml中手动注入RedisDao由于RedisDao和MyBatis的DAO没有关系，MyBatis不会帮我们自动实现该接口，所以我们需要在spring-dao.xml中手动注入RedisDao。由于我们在RedisDao是通过构造方法来注入ip和port两个参数的，所以需要配置，如果不配置这个标签，我们需要为ip和port提供各自的setter和getter（注入时可以没有getter）。在这里我们直接把value的值写死在标签里边了，实际开发中需要把ip和port参数的值写到配置文件里，通过读取配置文件的方式读取它们的值。12345&lt;!--redisDao --&gt;&lt;bean id="redisDao" class="com.lewis.dao.cache.RedisDao"&gt; &lt;constructor-arg index="0" value="localhost" /&gt; &lt;constructor-arg index="1" value="6379" /&gt;&lt;/bean&gt;修改SeckillServiceImpl使用注解注入RedisDao属性12@Autowiredprivate RedisDao redisDao;修改exportSeckillURI()1234567891011121314151617181920212223242526272829public Exposer exportSeckillUrl(long seckillId) &#123; // 优化点:缓存优化:超时的基础上维护一致性 // 1.访问redis Seckill seckill = redisDao.getSeckill(seckillId); if (seckill == null) &#123; // 2.访问数据库 seckill = seckillDao.queryById(seckillId); if (seckill == null) &#123;// 说明查不到这个秒杀产品的记录 return new Exposer(false, seckillId); &#125; else &#123; // 3.放入redis redisDao.putSeckill(seckill); &#125; &#125; // 若是秒杀未开启 Date startTime = seckill.getStartTime(); Date endTime = seckill.getEndTime(); // 系统当前时间 Date nowTime = new Date(); if (startTime.getTime() &gt; nowTime.getTime() || endTime.getTime() &lt; nowTime.getTime()) &#123; return new Exposer(false, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime()); &#125; // 秒杀开启，返回秒杀商品的id、用给接口加密的md5 String md5 = getMD5(seckillId); return new Exposer(true, md5, seckillId);&#125;2.5 测试类RedisDaoTest通过IDE工具快速生成测试类RedisDaoTest，新写一个testSeckill()，对getSeckill和putSeckill方法进行全局测试。123456789101112131415161718192021222324252627282930@RunWith(SpringJUnit4ClassRunner.class)// 告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring/spring-dao.xml" &#125;)public class RedisDaoTest &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); private long id = 1001; @Autowired private RedisDao redisDao; @Autowired private SeckillDao seckillDao; @Test public void testSeckill() &#123; Seckill seckill = redisDao.getSeckill(id); if (seckill == null) &#123; seckill = seckillDao.queryById(id); if (seckill != null) &#123; String result = redisDao.putSeckill(seckill); logger.info("result=&#123;&#125;", result); seckill = redisDao.getSeckill(id); logger.info("seckill=&#123;&#125;", seckill); &#125; &#125; &#125;&#125;如果测试通过了，会输出result={}OK以及id为1001的商品信息，如果输出的都是null，那说明你没有开启Redis服务器，所以在内存中没有存取到缓存。为什么不用Redis的hash来存储对象？第一：通过Jedis储存对象的方式有大概三种本项目采用的方式：将对象序列化成byte字节，最终存byte字节；对象转hashmap，也就是你想表达的hash的形式，最终存map；对象转json，最终存json，其实也就是字符串第二：其实如果你是平常的项目，并发不高，三个选择都可以，这种情况下以hash的形式更加灵活，可以对象的单个属性，但是问题来了，在秒杀的场景下，三者的效率差别很大。第三：结果如下10w数据时间内存占用存json10s14M存byte6s6M存jsonMap10s20M存byteMap4s4M取json7s取byte4s取jsonmap7s取bytemap4s第四：你该说了，bytemap最快啊，为啥不用啊，因为项目用了超级强悍的序列化工具啊，以上测试是基于java的序列化，如果改了序列化工具，你可以测试下。以上问答源自慕课网的一道问答教学视频中张老师对于Redis暴露接口地址的补充redis事务与RDBMS事务有本质区别，详情见http://redis.io/topics/transactions关于spring整合redis。原生Jedis API已经足够清晰。笔者所在的团队不使用任何spring-data整合API，而是直接对接原生Client并做二次开发调优，如Jedis,Hbase等。这里使用redis缓存方法用于暴露秒杀地址场景，该方法存在瞬时压力，为了降低DB的primary key QPS，且没有使用库存字段所以不做一致性维护。跨数据源的严格一致性需要2PC支持，性能不尽如人意。线上产品一般使用最终一致性去解决，这块相关知识较多，所以没有讲。本课程的重点其实不是SSM，只是一个快速开发的方式。重点根据业务场景分析通信成本，瓶颈点的过程和优化思路。初学者不要纠结于事务。事务可以降低一致性维护难度，但扩展性灵活性存在不足。技术是死的，人是活的。比如京东抢购使用Redis+LUA+MQ方案，就是一种技术反思。3. 秒杀操作——并发优化3.1 简单优化回顾事务执行sql语句的简单优化优化SeckillServiceImpl的executeSeckill()用户的秒杀操作分为两步：减库存、插入购买明细，我们在这里进行简单的优化，就是将原本先update（减库存）再进行insert（插入购买明细）的步骤改成：先insert再update。12345678910111213141516171819202122232425262728293031323334353637383940public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException &#123; if (md5 == null || !md5.equals(getMD5(seckillId))) &#123; throw new SeckillException("seckill data rewrite");// 秒杀数据被重写了 &#125; // 执行秒杀逻辑:减库存+增加购买明细 Date nowTime = new Date(); try &#123; // 否则更新了库存，秒杀成功,增加明细 int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); // 看是否该明细被重复插入，即用户是否重复秒杀 if (insertCount &lt;= 0) &#123; throw new RepeatKillException("seckill repeated"); &#125; else &#123; // 减库存,热点商品竞争 int updateCount = seckillDao.reduceNumber(seckillId, nowTime); if (updateCount &lt;= 0) &#123; // 没有更新库存记录，说明秒杀结束 rollback throw new SeckillCloseException("seckill is closed"); &#125; else &#123; // 秒杀成功,得到成功插入的明细记录,并返回成功秒杀的信息 commit SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, successKilled); &#125; &#125; &#125; catch (SeckillCloseException e1) &#123; throw e1; &#125; catch (RepeatKillException e2) &#123; throw e2; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); // 将编译期异常转化为运行期异常 throw new SeckillException("seckill inner error :" + e.getMessage()); &#125;&#125;为什么要先insert再update首先是在更新操作的时候给行加锁，插入并不会加锁，如果更新操作在前，那么就需要执行完更新和插入以后事务提交或回滚才释放锁。而如果插入在前，更新在后，那么只有在更新时才会加行锁，之后在更新完以后事务提交或回滚释放锁。在这里，插入是可以并行的，而更新由于会加行级锁是串行的。也就是说是更新在前加锁和释放锁之间两次的网络延迟和GC，如果插入在前则加锁和释放锁之间只有一次的网络延迟和GC，也就是减少的持有锁的时间。这里先insert并不是忽略了库存不足的情况，而是因为insert和update是在同一个事务里，光是insert并不一定会提交，只有在update成功才会提交，所以并不会造成过量插入秒杀成功记录。3.2 深度优化前边通过调整insert和update的执行顺序来实现简单优化，但依然存在着Java客户端和服务器通信时的网络延迟和GC影响，我们可以将执行秒杀操作时的insert和update放到MySQL服务端的存储过程里，而Java客户端直接调用这个存储过程，这样就可以避免网络延迟和可能发生的GC影响。另外，由于我们使用了存储过程，也就使用不到Spring的事务管理了，因为在存储过程里我们会直接启用一个事务。3.2.1 写一个存储过程procedure，然后在MySQL控制台里执行它1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-- 秒杀执行储存过程DELIMITER $$ -- 将定界符从;转换为$$-- 定义储存过程-- 参数： in输入参数 out输出参数-- row_count() 返回上一条修改类型sql(delete,insert,update)的影响行数-- row_count:0:未修改数据 ; &gt;0:表示修改的行数； &lt;0:sql错误CREATE PROCEDURE `seckill`.`execute_seckill` (IN v_seckill_id BIGINT, IN v_phone BIGINT, IN v_kill_time TIMESTAMP, OUT r_result INT) BEGIN DECLARE insert_count INT DEFAULT 0; START TRANSACTION; INSERT IGNORE INTO success_killed (seckill_id, user_phone, state) VALUES (v_seckill_id, v_phone, 0); SELECT row_count() INTO insert_count; IF (insert_count = 0) THEN ROLLBACK; SET r_result = -1; ELSEIF (insert_count &lt; 0) THEN ROLLBACK; SET r_result = -2; ELSE UPDATE seckill SET number = number - 1 WHERE seckill_id = v_seckill_id AND end_time &gt; v_kill_time AND start_time &lt; v_kill_time AND number &gt; 0; SELECT row_count() INTO insert_count; IF (insert_count = 0) THEN ROLLBACK; SET r_result = 0; ELSEIF (insert_count &lt; 0) THEN ROLLBACK; SET r_result = -2; ELSE COMMIT; SET r_result = 1; END IF; END IF; END;$$-- 储存过程定义结束-- 将定界符重新改为;DELIMITER ;-- 定义一个用户变量r_resultSET @r_result = -3;-- 执行储存过程CALL execute_seckill(1003, 13502178891, now(), @r_result);-- 获取结果SELECT @r_result;注意点1CREATE PROCEDURE `seckill`.`execute_seckill`上边这句语句的意思是为一个名为seckill的数据库定义一个名为execute_seckill的存储过程，如果你在连接数据库后使用了这个数据库（即use seckill;），那么这里的定义句子就不能这样写了，会报错（因为存储过程是依赖于数据库的），改成下边这样：1CREATE PROCEDURE `execute_seckill`row_count()存储过程中，row_count()函数用来返回上一条sql（delete,insert,update）影响的行数。根据row_count()返回值，可以进行接下来的流程判断：0：未修改数据；&gt;0: 表示修改的行数；&lt;0: 表示SQL错误或未执行修改SQL3.2.2 修改源码以调用存储过程在SeckillDao里添加调用存储过程的方法声明12345/** * 使用储存过程执行秒杀 * @param paramMap */ void killByProcedure(Map&lt;String,Object&gt; paramMap);接着在SeckillDao.xml里添加该方法对应的sql语句123456789&lt;!--调用储存过程 --&gt;&lt;select id="killByProcedure" statementType="CALLABLE"&gt; CALL execute_seckill( #&#123;seckillId,jdbcType=BIGINT,mode=IN&#125;, #&#123;phone,jdbcType=BIGINT,mode=IN&#125;, #&#123;killTime,jdbcType=TIMESTAMP,mode=IN&#125;, #&#123;result,jdbcType=INTEGER,mode=OUT&#125; )&lt;/select&gt;在SeckillService接口里添加一个方法声明123456789/** * 调用存储过程来执行秒杀操作，不需要抛出异常 * * @param seckillId 秒杀的商品ID * @param userPhone 手机号码 * @param md5 md5加密值 * @return 根据不同的结果返回不同的实体信息 */SeckillExecution executeSeckillProcedure(long seckillId,long userPhone,String md5);为什么这个方法不需要抛出异常？原本没有调用存储过程的执行秒杀操作之所以要抛出RuntimException，是为了让Spring事务管理器能够在秒杀不成功的时候进行回滚操作。而现在我们使用了存储过程，有关事务的提交或回滚已经在procedure里完成了，前面也解释了不需要再使用到Spring的事务了，既然如此，我们也就不需要在这个方法里抛出异常来让Spring帮我们回滚了。在SeckillServiceImpl里实现这个方法我们需要使用到第三方工具类，所以在pom.xml里导入commons-collections工具类123456&lt;!--导入apache工具类--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt;在接口的实现类里对executeSeckillProcedure进行实现12345678910111213141516171819202122@Overridepublic SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5) &#123; if (md5 == null || !md5.equals(getMD5(seckillId))) &#123; return new SeckillExecution(seckillId, SeckillStatEnum.DATE_REWRITE); &#125; Date killTime = new Date(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("seckillId", seckillId); map.put("phone", userPhone); map.put("killTime", killTime); map.put("result", null); // 执行储存过程,result被复制 seckillDao.killByProcedure(map); // 获取result int result = MapUtils.getInteger(map, "result", -2); if (result == 1) &#123; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, successKilled); &#125; else &#123; return new SeckillExecution(seckillId, SeckillStatEnum.stateOf(result)); &#125;&#125;接着对该方法进行测试，在原本的SeckillServiceTest测试类里添加测试方法1234567891011@Testpublic void executeSeckillProcedure()&#123; long seckillId = 1001; long phone = 13680115101L; Exposer exposer = seckillService.exportSeckillUrl(seckillId); if (exposer.isExposed()) &#123; String md5 = exposer.getMd5(); SeckillExecution execution = seckillService.executeSeckillProcedure(seckillId, phone, md5); logger.info("execution=&#123;&#125;", execution); &#125;&#125;经过测试，发现没有问题，测试通过。然后我们需要把Controller里的执行秒杀操作改成调用存储过程的方法。123456789101112131415161718192021222324252627282930313233 @RequestMapping(value = "/&#123;seckillId&#125;/&#123;md5&#125;/execution", method = RequestMethod.POST, produces = &#123;"application/json;charset=UTF-8"&#125;) @ResponseBody public SeckillResult&lt;SeckillExecution&gt; execute(@PathVariable("seckillId") Long seckillId, @PathVariable("md5") String md5, @CookieValue(value = "userPhone",required = false) Long userPhone) &#123; if (userPhone==null) &#123; return new SeckillResult&lt;SeckillExecution&gt;(false,"未注册"); &#125; try &#123; //这里改为调用存储过程// SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); SeckillExecution execution = seckillService.executeSeckillProcedure(seckillId, userPhone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125;catch (RepeatKillException e1) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125;catch (SeckillCloseException e2) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125; catch (Exception e) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125; &#125;存储过程优化总结存储过程优化:事务行级锁持有的时间不要过度依赖存储过程简单的逻辑依赖存储过程QPS:一个秒杀单6000/qps经过简单优化和深度优化之后，本项目大概能达到一个秒杀单6000qps（慕课网视频中张老师说的），这个数据对于一个秒杀商品来说其实已经挺ok了，注意这里是指同一个秒杀商品6000qps，如果是不同商品不存在行级锁竞争的问题。3.3 系统部署架构CDN：放置一些静态化资源，或者可以将动态数据分离。一些js依赖直接用公网的CDN，自己开发的一些页面也做静态化处理推送到CDN。用户在CDN获取到的数据不需要再访问我们的服务器，动静态分离可以降低服务器请求量。比如秒杀详情页，做成HTML放在cdn上，动态数据可以通过ajax请求后台获取。Nginx：作为http服务器，响应客户请求，为后端的servlet容器做反向代理，以达到负载均衡的效果。Redis：用来做服务器端的缓存，通过Jedis提供的API来达到热点数据的一个快速存取的过程，减少数据库的请求量。MySQL：保证秒杀过程的数据一致性与完整性。智能DNS解析+智能CDN加速+Nginx并发+Redis缓存+MySQL分库分表大型系统部署架构，逻辑集群就是开发的部分。Nginx做负载均衡分库分表：在秒杀系统中，一般通过关键的秒杀商品id取模进行分库分表，以512为一张表，1024为一张表。分库分表一般采用开源架构，如阿里巴巴的tddl分库分表框架。统计分析：一般使用hadoop等架构进行分析在这样一个架构中，可能参与的角色如下：本节结语至此，关于该SSM实战项目——Java高并发秒杀API已经全部完成，感谢观看本文。项目笔记相关链接Java高并发秒杀API(一)之业务分析与DAO层Java高并发秒杀API(二)之Service层Java高并发秒杀API(三)之Web层Java高并发秒杀API(四)之高并发优化项目源码源码下载GitHub地址项目视频教程链接这是慕课网上的一个免费项目教学视频，名为Java高并发秒杀API，一共有如下四节课程，附带视频传送门（在视频中老师是用IDEA，本文用的是Eclipse）Java高并发秒杀API之业务分析与DAO层Java高并发秒杀API之Service层Java高并发秒杀API之Web层Java高并发秒杀API之高并发优化]]></content>
      <categories>
        <category>项目笔记</category>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
        <tag>Java Web</tag>
        <tag>SSM框架</tag>
        <tag>高并发</tag>
        <tag>seckill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发秒杀API(三)之Web层]]></title>
    <url>%2Fposts%2F33818.html</url>
    <content type="text"><![CDATA[1. 设计前的分析Web层内容相关前端交互设计Restful规范SpringMVCBootstrap + jQuery前端页面流程详情页流程逻辑为什么要获取标准系统时间（服务器的时间）用户可能处在不同时区，用户的电脑的系统时间可能不同。Restful规范Restful规范是一种优雅的URI表达方式：/模块/资源/{标识}/集合1/···GET -&gt; 查询操作POST -&gt; 添加/修改操作（用于非幂等操作）PUT -&gt; 修改操作（用于幂等操作）DELETE -&gt; 删除操作怎么实现Restful接口@RequestMapping(value = “/path”,method = RequestMethod.GET)@RequestMapping(value = “/path”,method = RequestMethod.POST)@RequestMapping(value = “/path”,method = RequestMethod.PUT)@RequestMapping(value = “/path”,method = RequestMethod.DELETE)非幂等操作和幂等操作幂等性（idempotency）意味着对同一URL的多个请求应该返回同样的结果。在Restful规范中，GET、PUT、DELETE是幂等操作，只有POST是非幂等操作。POST和PUT都可以用来创建和更新资源，二者的区别就是前者用于非幂等操作，后者用于幂等操作。简单来说，使用POST方法请求创建一个资源，如果将这条请求重复发送N次，就会创建出N个资源；而如果用GET方法请求创建一个资源，就算重复发送该请求N次，也只会创建一个资源（就算第一次请求创建出来的资源）。附：《幂等和高并发在电商系统中的使用》秒杀API的URL设计@RequestMapping的映射技巧请求方法细节处理请求参数绑定请求方法限制请求转发和重定向数据模型赋值返回json数据Cookie访问2. 整合配置SpringMVC框架2.1 配置web.xml123456789101112131415161718192021222324&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0" metadata-complete="true"&gt; &lt;!--用maven创建的web-app需要修改servlet的版本为3.0 --&gt; &lt;!--配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置SpringMVC 需要配置的文件 spring-dao.xml，spring-service.xml,spring-web.xml MyBatis -&gt; Spring -&gt; SpringMVC --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!--默认匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;注意这里的Servlet版本是3.0，对应Tomcat7.0版本由于我们的配置文件都是以spring-开头命名的，所以可以用通配符*一次性全部加载url-pattern设置为/，这是使用了Restful的规范；在使用Struts框架时我们配置的是*.do之类的，这是一种比较丑陋的表达方式2.2 在src/main/resources/spring包下建立spring-web.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--配置spring mvc--&gt; &lt;!--1,开启springmvc注解模式 a.自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter b.默认提供一系列的功能:数据绑定，数字和日期的format@NumberFormat,@DateTimeFormat c:xml,json的默认读写支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.静态资源默认servlet配置--&gt; &lt;!-- 1).加入对静态资源处理：js,gif,png 2).允许使用 "/" 做整体映射 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3：配置JSP 显示ViewResolver--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!--4:扫描web相关的controller--&gt; &lt;context:component-scan base-package="com.lewis.web"/&gt;&lt;/beans&gt;3. Controller设计Controller中的每一个方法都对应我们系统中的一个资源URL，其设计应该遵循Restful接口的设计风格。3.1 在java包下新建com.lewis.web包，在该包下新建SeckillController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Controller@RequestMapping("/seckill")//url:模块/资源/&#123;&#125;/细分public class SeckillController&#123; @Autowired private SeckillService seckillService; @RequestMapping(value = "/list",method = RequestMethod.GET) public String list(Model model) &#123; //list.jsp+mode=ModelAndView //获取列表页 List&lt;Seckill&gt; list=seckillService.getSeckillList(); model.addAttribute("list",list); return "list"; &#125; @RequestMapping(value = "/&#123;seckillId&#125;/detail",method = RequestMethod.GET) public String detail(@PathVariable("seckillId") Long seckillId, Model model) &#123; if (seckillId == null) &#123; return "redirect:/seckill/list"; &#125; Seckill seckill=seckillService.getById(seckillId); if (seckill==null) &#123; return "forward:/seckill/list"; &#125; model.addAttribute("seckill",seckill); return "detail"; &#125; //ajax ,json暴露秒杀接口的方法 @RequestMapping(value = "/&#123;seckillId&#125;/exposer", method = RequestMethod.GET, produces = &#123;"application/json;charset=UTF-8"&#125;) @ResponseBody public SeckillResult&lt;Exposer&gt; exposer(@PathVariable("seckillId") Long seckillId) &#123; SeckillResult&lt;Exposer&gt; result; try&#123; Exposer exposer=seckillService.exportSeckillUrl(seckillId); result=new SeckillResult&lt;Exposer&gt;(true,exposer); &#125;catch (Exception e) &#123; e.printStackTrace(); result=new SeckillResult&lt;Exposer&gt;(false,e.getMessage()); &#125; return result; &#125; @RequestMapping(value = "/&#123;seckillId&#125;/&#123;md5&#125;/execution", method = RequestMethod.POST, produces = &#123;"application/json;charset=UTF-8"&#125;) @ResponseBody public SeckillResult&lt;SeckillExecution&gt; execute(@PathVariable("seckillId") Long seckillId, @PathVariable("md5") String md5, @CookieValue(value = "userPhone",required = false) Long userPhone) &#123; if (userPhone==null) &#123; return new SeckillResult&lt;SeckillExecution&gt;(false,"未注册"); &#125; try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125;catch (RepeatKillException e1) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125;catch (SeckillCloseException e2) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125; catch (Exception e) &#123; SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true,execution); &#125; &#125; //获取系统时间 @RequestMapping(value = "/time/now",method = RequestMethod.GET) @ResponseBody public SeckillResult&lt;Long&gt; time() &#123; Date now=new Date(); return new SeckillResult&lt;Long&gt;(true,now.getTime()); &#125;&#125;注意SpringMVC在处理Cookie时有个小问题：如果找不到对应的Cookie会报错，所以设置为required=false，将Cookie是否存在的逻辑判断放到代码中来判断。关于异常的捕捉Service层中的抛出异常是为了让Spring能够回滚，Controller层中捕获异常是为了将异常转换为对应的Json供前台使用，缺一不可。3.2 在dto包下新建一个SeckillResult123456789101112131415161718192021222324252627282930313233343536373839404142//将所有的ajax请求返回类型，全部封装成json数据public class SeckillResult&lt;T&gt; &#123; //请求是否成功 private boolean success; private T data; private String error; public SeckillResult(boolean success, T data) &#123; this.success = success; this.data = data; &#125; public SeckillResult(boolean success, String error) &#123; this.success = success; this.error = error; &#125; public boolean isSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public String getError() &#123; return error; &#125; public void setError(String error) &#123; this.error = error; &#125;&#125;注意SeckillResult是一个VO类(View Object)，属于DTO层，用来封装json结果，方便页面取值；在这里，将其设计成泛型，就可以和灵活地往里边封装各种类型的对象。这里的success属性不是指秒杀执行的结果，而是指页面是否发送请求成功，至于秒杀之后是否成功的这个结果则是封装到了data属性里。4. 基于Bootstrap开发页面由于项目的前端页面都是由Bootstrap开发的,所以需要先去下载Bootstrap或者是使用在线的CDN服务。而Bootstrap又是依赖于jQuery的，所以需要先引入jQuery。4.1 在webapp下建立resources目录，接着建立script目录，建立seckill.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//存放主要交互逻辑的js代码// javascript 模块化(package.类.方法)var seckill = &#123; //封装秒杀相关ajax的url URL: &#123; now: function () &#123; return '/seckill/seckill/time/now'; &#125;, exposer: function (seckillId) &#123; return '/seckill/seckill/' + seckillId + '/exposer'; &#125;, execution: function (seckillId, md5) &#123; return '/seckill/seckill/' + seckillId + '/' + md5 + '/execution'; &#125; &#125;, //验证手机号 validatePhone: function (phone) &#123; if (phone &amp;&amp; phone.length == 11 &amp;&amp; !isNaN(phone)) &#123; return true;//直接判断对象会看对象是否为空,空就是undefine就是false; isNaN 非数字返回true &#125; else &#123; return false; &#125; &#125;, //详情页秒杀逻辑 detail: &#123; //详情页初始化 init: function (params) &#123; //手机验证和登录,计时交互 //规划我们的交互流程 //在cookie中查找手机号 var userPhone = $.cookie('userPhone'); //验证手机号 if (!seckill.validatePhone(userPhone)) &#123; //绑定手机 控制输出 var killPhoneModal = $('#killPhoneModal'); killPhoneModal.modal(&#123; show: true,//显示弹出层 backdrop: 'static',//禁止位置关闭 keyboard: false//关闭键盘事件 &#125;); $('#killPhoneBtn').click(function () &#123; var inputPhone = $('#killPhoneKey').val(); console.log("inputPhone: " + inputPhone); if (seckill.validatePhone(inputPhone)) &#123; //电话写入cookie(7天过期) $.cookie('userPhone', inputPhone, &#123;expires: 7, path: '/seckill'&#125;); //验证通过 刷新页面 window.location.reload(); &#125; else &#123; //todo 错误文案信息抽取到前端字典里 $('#killPhoneMessage').hide().html('&lt;label class="label label-danger"&gt;手机号错误!&lt;/label&gt;').show(300); &#125; &#125;); &#125; //已经登录 //计时交互 var startTime = params['startTime']; var endTime = params['endTime']; var seckillId = params['seckillId']; $.get(seckill.URL.now(), &#123;&#125;, function (result) &#123; if (result &amp;&amp; result['success']) &#123; var nowTime = result['data']; //时间判断 计时交互 seckill.countDown(seckillId, nowTime, startTime, endTime); &#125; else &#123; console.log('result: ' + result); alert('result: ' + result); &#125; &#125;); &#125; &#125;, handlerSeckill: function (seckillId, node) &#123; //获取秒杀地址,控制显示器,执行秒杀 node.hide().html('&lt;button class="btn btn-primary btn-lg" id="killBtn"&gt;开始秒杀&lt;/button&gt;'); $.get(seckill.URL.exposer(seckillId), &#123;&#125;, function (result) &#123; //在回调函数种执行交互流程 if (result &amp;&amp; result['success']) &#123; var exposer = result['data']; if (exposer['exposed']) &#123; //开启秒杀 //获取秒杀地址 var md5 = exposer['md5']; var killUrl = seckill.URL.execution(seckillId, md5); console.log("killUrl: " + killUrl); //绑定一次点击事件 $('#killBtn').one('click', function () &#123; //执行秒杀请求 //1.先禁用按钮 $(this).addClass('disabled');//,&lt;-$(this)===('#killBtn')-&gt; //2.发送秒杀请求执行秒杀 $.post(killUrl, &#123;&#125;, function (result) &#123; if (result &amp;&amp; result['success']) &#123; var killResult = result['data']; var state = killResult['state']; var stateInfo = killResult['stateInfo']; //显示秒杀结果 node.html('&lt;span class="label label-success"&gt;' + stateInfo + '&lt;/span&gt;'); &#125; &#125;); &#125;); node.show(); &#125; else &#123; //未开启秒杀(浏览器计时偏差) var now = exposer['now']; var start = exposer['start']; var end = exposer['end']; seckill.countDown(seckillId, now, start, end); &#125; &#125; else &#123; console.log('result: ' + result); &#125; &#125;); &#125;, countDown: function (seckillId, nowTime, startTime, endTime) &#123; console.log(seckillId + '_' + nowTime + '_' + startTime + '_' + endTime); var seckillBox = $('#seckill-box'); if (nowTime &gt; endTime) &#123; //秒杀结束 seckillBox.html('秒杀结束!'); &#125; else if (nowTime &lt; startTime) &#123; //秒杀未开始,计时事件绑定 var killTime = new Date(startTime + 1000);//todo 防止时间偏移 seckillBox.countdown(killTime, function (event) &#123; //时间格式 var format = event.strftime('秒杀倒计时: %D天 %H时 %M分 %S秒 '); seckillBox.html(format); &#125;).on('finish.countdown', function () &#123; //时间完成后回调事件 //获取秒杀地址,控制现实逻辑,执行秒杀 console.log('______fininsh.countdown'); seckill.handlerSeckill(seckillId, seckillBox); &#125;); &#125; else &#123; //秒杀开始 seckill.handlerSeckill(seckillId, seckillBox); &#125; &#125;&#125;;脚本文件的技巧使用Json来讲JavaScript模块化（类似于Java的package），不要将js都写成一堆，不易维护，页不方便阅读。特殊说明由于本人的Eclipse内嵌的Tomcat设置的原因，我需要在URL里的所有路径前加上/seckill（我的项目名）才可以正常映射到Controller里对应的方法，如下123456789101112//封装秒杀相关ajax的url URL: &#123; now: function () &#123; return '/seckill/seckill/time/now'; &#125;, exposer: function (seckillId) &#123; return '/seckill/seckill/' + seckillId + '/exposer'; &#125;, execution: function (seckillId, md5) &#123; return '/seckill/seckill/' + seckillId + '/' + md5 + '/execution'; &#125; &#125;,如果有同学在后边测试页面时找不到路径，可以将这里的路径里的/seckill删掉4.2 编写页面在WEB-INF目录下新建一个jsp目录，在这里存放我们的jsp页面，为了减少工作量，也为了方便，将每个页面都会使用到的头部文件和标签库分离出来，放到common目录下，在jsp页面中静态包含这两个公共页面就行了。关于jsp页面请从源码中拷贝，实际开发中前端页面由前端工程师完成，但是后端工程师也应该了解jQuery和ajax，想要了解本项目的页面是如何实现的请观看慕课网的Java高并发秒杀API之Web层。静态包含和动态包含的区别静态包含会直接将页面包含进来，最终只生成一个Servlet；而动态包含会先将要包含进来的页面生成Servlet后再包含进来，最终会生成多个Servlet。存在的坑在页面里不要写成&lt;script/&gt;，这样写会导致后边的js加载不了，所以要写成&lt;script&gt;&lt;/script&gt;。EL表达式startTime是Date类型的，通过${startTime.time}来将Date转换成long类型的毫秒值。4.3 测试页面先clean下Maven项目，接着编译Maven项目（-X compile命令），然后启动Tomcat，在浏览器输入http://localhost:8080/seckill/seckill/list，成功进入秒杀商品页面；输入http://localhost:8080/seckill/seckill/1000/detail成功进入详情页面。配置使用jquery countdown插件1.pom.xml123456789&lt;dependency&gt; &lt;groupId&gt;org.webjars.bower&lt;/groupId&gt; &lt;artifactId&gt;jquery.countdown&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt;2.页面1&lt;script src="$&#123;pageContext.request.contextPath&#125;/webjars/jquery.countdown/2.1.0/dist/jquery.countdown.min.js"&gt;&lt;/script&gt;其他问题关于显示NaN天 NaN时 NaN分 NaN秒的问题，原因是new Date(startTime + 1000)，startTime 被解释成一个字符串了。解决办法：new Date(startTime-0 + 1000);new Date(Number(startTime) + 1000);关于分布式环境下的几个问题以及慕课网张老师的回答根据系统标准时间判断，如果分布式环境下各机器时间不同步怎么办？同时发起的两次请求，可能一个活动开始，另一个提示没开始。后端服务器需要做NTP时间同步，如每5分钟与NTP服务同步保证时间误差在微妙级以下。时间同步在业务需要或者活性检查场景很常见(如hbase的RegionServer)如果判断逻辑都放到后端，遇到有刷子，后端处理这些请求扛不住了怎么办？可能活动没开始，服务器已经挂掉了。秒杀开启判断在前端和后端都有，后端的判断比较简单取秒杀单做判断，这块的IO请求是DB主键查询很快，单DB就可以抗住几万QPS,后面也会加入redis缓存为DB减负。负载均衡问题，比如根据地域在nginx哈希，怎样能较好的保证各机器秒杀成功的尽量分布均匀呢。负载均衡包括nginx入口端和后端upstream服务，在入口端一般采用智能DNS解析请求就近进入nginx服务器。后端upstgream不建议采用一致性hash，防止请求不均匀。后端服务无状态可以简单使用轮训机制。nginx负载均衡本身过于简单，可以使用openresty自己实现或者nginx之后单独架设负载均衡服务如Netflix的Zuul等。对于流量爆增的造成后端不可用情况，这门课程(Java高并发秒杀API)并没有做动态降级和弹性伸缩架构上的处理，后面受慕课邀请会做一个独立的实战课，讲解分布式架构，弹性容错，微服务相关的内容，到时会加入这方面的内容。本节结语至此，关于Java高并发秒杀API的Web层的开发与测试已经完成，接下来进行对该秒杀系统进行高并发优化，详情可以参考下一篇文章。上一篇文章：Java高并发秒杀API(二)之Service层下一篇文章：Java高并发秒杀API(四)之高并发优化]]></content>
      <categories>
        <category>项目笔记</category>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
        <tag>Java Web</tag>
        <tag>SSM框架</tag>
        <tag>高并发</tag>
        <tag>seckill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发秒杀API(二)之Service层]]></title>
    <url>%2Fposts%2F18357.html</url>
    <content type="text"><![CDATA[1. 设计前的分析分层的必要性DAO层工作演变为:接口设计+SQL编写（不需要其他杂七杂八的功能）代码和SQL的分离,方便review（浏览）DAO拼接等逻辑在Service层完成（DAO只需负责SQL语句，其他都由Service层完成）一些初学者容易出现的错误，就是喜欢在DAO层进行逻辑的编写，其实DAO就是数据访问的缩写，它只进行数据的访问操作。业务接口的编写初学者总是关注细节，关注接口如何去实现，这样设计出来的接口往往比较冗余。业务接口的编写要站在“使用者”的角度定义，三个方面：方法定义的粒度、参数、返回值。方法定义粒度：关注接口的功能本身，至于这个功能需要包含哪些步骤那是具体的实现，也就是说，功能明确而且单一。参数：方法所需要的数据，供使用者传入，明确方法所需要的数据，而且尽可能友好，简练。返回值：一般情况下，entity数据不够，需要自定义DTO,也有可能抛出异常，需要自定义异常，不管是DTO还是异常，尽可能将接口调用的信息返回给使用者，哪怕是失败信息。DTO与entity的区别DTO数据传输层：用于Web层和Service层之间传递的数据封装。entity：用于业务数据的封装，比如数据库中的数据。关于秒杀地址的暴露需要有专门一个方法实现秒杀地址输出，避免人为因素提前知道秒杀地址而出现漏洞。获取秒杀url时，如果不合法，则返回当前时间和秒杀项目的时间；如果合法，才返回md5加密后url，以避免url被提前获知。使用md5将url加密、校验，防止秒杀的url被篡改。MD5加密Spring提供了MD5生成工具。代码如下：1DigestUtils.md5DigestAsHex();MD5盐值字符串（salt），用于混淆MD5，添加MD5反编译难度2. Service层的接口设计在src/main/java包下建立com.lewis.service包，用来存放Service接口；在src/main/java包下建立com.lewis.exception包，用来存放Service层出现的异常类：比如重复秒杀异常、秒杀已关闭异常；在src/main/java包下建立com.lewis.dto包，用来封装Web层和Service层之间传递的数据。定义SeckillService接口123456789101112131415161718192021222324252627282930313233343536373839404142/** * 业务接口:站在使用者(程序员)的角度设计接口 三个方面:1.方法定义粒度，方法定义的要非常清楚2.参数，要越简练越好 3.返回类型(return * 类型一定要友好/或者return异常，我们允许的异常) */public interface SeckillService &#123; /** * 查询全部的秒杀记录 * * @return */ List&lt;Seckill&gt; getSeckillList(); /** * 查询单个秒杀记录 * * @param seckillId * @return */ Seckill getById(long seckillId); // 再往下，是我们最重要的行为的一些接口 /** * 在秒杀开启时输出秒杀接口的地址，否则输出系统时间和秒杀时间 * * @param seckillId 秒杀商品Id * @return 根据对应的状态返回对应的状态实体 */ Exposer exportSeckillUrl(long seckillId); /** * 执行秒杀操作，有可能失败，有可能成功，所以要抛出我们允许的异常 * * @param seckillId 秒杀的商品ID * @param userPhone 手机号码 * @param md5 md5加密值 * @return 根据不同的结果返回不同的实体信息 */ SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException;&#125;在dto包中创建Exposer.java，用于封装秒杀的地址信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 暴露秒杀地址(接口)DTO */public class Exposer &#123; // 是否开启秒杀 private boolean exposed; // 加密措施 private String md5; //id为seckillId的商品的秒杀地址 private long seckillId; // 系统当前时间(毫秒) private long now; // 秒杀的开启时间 private long start; // 秒杀的结束时间 private long end; public Exposer(boolean exposed, String md5, long seckillId) &#123; this.exposed = exposed; this.md5 = md5; this.seckillId = seckillId; &#125; public Exposer(boolean exposed, long seckillId, long now, long start, long end) &#123; this.exposed = exposed; this.seckillId = seckillId; this.now = now; this.start = start; this.end = end; &#125; public Exposer(boolean exposed, long seckillId) &#123; this.exposed = exposed; this.seckillId = seckillId; &#125; public boolean isExposed() &#123; return exposed; &#125; public void setExposed(boolean exposed) &#123; this.exposed = exposed; &#125; public String getMd5() &#123; return md5; &#125; public void setMd5(String md5) &#123; this.md5 = md5; &#125; public long getSeckillId() &#123; return seckillId; &#125; public void setSeckillId(long seckillId) &#123; this.seckillId = seckillId; &#125; public long getNow() &#123; return now; &#125; public void setNow(long now) &#123; this.now = now; &#125; public long getStart() &#123; return start; &#125; public void setStart(long start) &#123; this.start = start; &#125; public long getEnd() &#123; return end; &#125; public void setEnd(long end) &#123; this.end = end; &#125; @Override public String toString() &#123; return "Exposer&#123;" + "exposed=" + exposed + ", md5='" + md5 + '\'' + ", seckillId=" + seckillId + ", now=" + now + ", start=" + start + ", end=" + end + '&#125;'; &#125;&#125;在dto包中创建SeckillExecution.java，用于封装秒杀是否成功的结果（该对象用来返回给页面）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 封装执行秒杀后的结果:是否秒杀成功 */public class SeckillExecution &#123; private long seckillId; //秒杀执行结果的状态 private int state; //状态的明文标识 private String stateInfo; //当秒杀成功时，需要传递秒杀成功的对象回去 private SuccessKilled successKilled; //秒杀成功返回所有信息 public SeckillExecution(long seckillId, int state, String stateInfo, SuccessKilled successKilled) &#123; this.seckillId = seckillId; this.state = state; this.stateInfo = stateInfo; this.successKilled = successKilled; &#125; //秒杀失败 public SeckillExecution(long seckillId, int state, String stateInfo) &#123; this.seckillId = seckillId; this.state = state; this.stateInfo = stateInfo; &#125; public long getSeckillId() &#123; return seckillId; &#125; public void setSeckillId(long seckillId) &#123; this.seckillId = seckillId; &#125; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; &#125; public String getStateInfo() &#123; return stateInfo; &#125; public void setStateInfo(String stateInfo) &#123; this.stateInfo = stateInfo; &#125; public SuccessKilled getSuccessKilled() &#123; return successKilled; &#125; public void setSuccessKilled(SuccessKilled successKilled) &#123; this.successKilled = successKilled; &#125;&#125;在exception包中创建秒杀过程中可能出现的异常类定义一个基础的异常类SeckillException，继承自RuntimeException123456789101112/** * 秒杀相关的所有业务异常 */public class SeckillException extends RuntimeException &#123; public SeckillException(String message) &#123; super(message); &#125; public SeckillException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125;重复秒杀异常，继承自SeckillException1234567891011121314/** * 重复秒杀异常，是一个运行期异常，不需要我们手动try catch * Mysql只支持运行期异常的回滚操作 */public class RepeatKillException extends SeckillException &#123; public RepeatKillException(String message) &#123; super(message); &#125; public RepeatKillException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125;秒杀已关闭异常，继承自SeckillException123456789101112/** * 秒杀关闭异常，当秒杀结束时用户还要进行秒杀就会出现这个异常 */public class SeckillCloseException extends SeckillException&#123; public SeckillCloseException(String message) &#123; super(message); &#125; public SeckillCloseException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125;3. Service层接口的实现在com.lewis.service包下再建立impl包，用来存放接口的实现类SeckillServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class SeckillServiceImpl implements SeckillService&#123; //日志对象 private Logger logger= LoggerFactory.getLogger(this.getClass()); //加入一个混淆字符串(秒杀接口)的salt，为了我避免用户猜出我们的md5值，值任意给，越复杂越好 private final String salt="aksehiucka24sf*&amp;%&amp;^^#^%$"; //注入Service依赖 @Autowired //@Resource private SeckillDao seckillDao; @Autowired //@Resource private SuccessKilledDao successKilledDao; public List&lt;Seckill&gt; getSeckillList() &#123; return seckillDao.queryAll(0,4); &#125; public Seckill getById(long seckillId) &#123; return seckillDao.queryById(seckillId); &#125; public Exposer exportSeckillUrl(long seckillId) &#123; Seckill seckill=seckillDao.queryById(seckillId); if (seckill==null) //说明查不到这个秒杀产品的记录 &#123; return new Exposer(false,seckillId); &#125; //若是秒杀未开启 Date startTime=seckill.getStartTime(); Date endTime=seckill.getEndTime(); //系统当前时间 Date nowTime=new Date(); if (startTime.getTime()&gt;nowTime.getTime() || endTime.getTime()&lt;nowTime.getTime()) &#123; return new Exposer(false,seckillId,nowTime.getTime(),startTime.getTime(),endTime.getTime()); &#125; //秒杀开启，返回秒杀商品的id、用给接口加密的md5 String md5=getMD5(seckillId); return new Exposer(true,md5,seckillId); &#125; private String getMD5(long seckillId) &#123; String base=seckillId+"/"+salt; String md5= DigestUtils.md5DigestAsHex(base.getBytes()); return md5; &#125; //秒杀是否成功，成功:减库存，增加明细；失败:抛出异常，事务回滚 public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException &#123; if (md5==null||!md5.equals(getMD5(seckillId))) &#123; throw new SeckillException("seckill data rewrite");//秒杀数据被重写了 &#125; //执行秒杀逻辑:减库存+增加购买明细 Date nowTime=new Date(); try&#123; //减库存 int updateCount=seckillDao.reduceNumber(seckillId,nowTime); if (updateCount&lt;=0) &#123; //没有更新库存记录，说明秒杀结束 throw new SeckillCloseException("seckill is closed"); &#125;else &#123; //否则更新了库存，秒杀成功,增加明细 int insertCount=successKilledDao.insertSuccessKilled(seckillId,userPhone); //看是否该明细被重复插入，即用户是否重复秒杀 if (insertCount&lt;=0) &#123; throw new RepeatKillException("seckill repeated"); &#125;else &#123; //秒杀成功,得到成功插入的明细记录,并返回成功秒杀的信息 SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone); return new SeckillExecution(seckillId,1,"秒杀成功",successKilled); &#125; &#125; &#125;catch (SeckillCloseException e1) &#123; throw e1; &#125;catch (RepeatKillException e2) &#123; throw e2; &#125;catch (Exception e) &#123; logger.error(e.getMessage(),e); //将编译期异常转化为运行期异常 throw new SeckillException("seckill inner error :"+e.getMessage()); &#125; &#125;&#125;在以上代码中，我们捕获了运行时异常，原因是Spring的事务默认是发生了RuntimeException才会回滚，发生了其他异常不会回滚，所以在最后的catch块里通过throw new SeckillException(&quot;seckill inner error :&quot;+e.getMessage());将编译期异常转化为运行期异常。另外，在代码里还存在着硬编码的情况，比如秒杀结果返回的state和stateInfo参数信息是输出给前端的，这些字符串应该考虑用常量枚举类封装起来，方便重复利用，也易于维护。在src/main/java包下新建一个枚举包com.lewis.enums包，在该包下创建一个枚举类型SeckillStatEnum123456789101112131415161718192021222324252627282930313233public enum SeckillStatEnum &#123; SUCCESS(1,"秒杀成功"), END(0,"秒杀结束"), REPEAT_KILL(-1,"重复秒杀"), INNER_ERROR(-2,"系统异常"), DATE_REWRITE(-3,"数据篡改"); private int state; private String info; SeckillStatEnum(int state, String info) &#123; this.state = state; this.info = info; &#125; public int getState() &#123; return state; &#125; public String getInfo() &#123; return info; &#125; public static SeckillStatEnum stateOf(int index) &#123; for (SeckillStatEnum state : values()) &#123; if (state.getState()==index) &#123; return state; &#125; &#125; return null; &#125;&#125;创建了枚举类型后，就需要修改之前硬编码的地方，修改SeckillExecution涉及到state和stateInfo参数的构造方法1234567891011121314//秒杀成功返回所有信息 public SeckillExecution(long seckillId, SeckillStatEnum statEnum, SuccessKilled successKilled) &#123; this.seckillId = seckillId; this.state = statEnum.getState(); this.stateInfo = statEnum.getInfo(); this.successKilled = successKilled; &#125; //秒杀失败 public SeckillExecution(long seckillId, SeckillStatEnum statEnum) &#123; this.seckillId = seckillId; this.state = statEnum.getState(); this.stateInfo = statEnum.getInfo(); &#125;接着把SeckillServiceImpl里返回的秒杀成功信息的return new SeckillExecution(seckillId,1,&quot;秒杀成功&quot;,successKilled);改成return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);4. 使用Spring进行Service层的配置在之前创建的spring包下创建spring-service.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.lewis.service" /&gt; &lt;!--配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!--注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!--配置基于注解的声明式事务 默认使用注解来管理事务行为 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt;事务管理器MyBatis采用的是JDBC的事务管理器Hibernate采用的是Hibernate的事务管理器通过注解的方式将Service的实现类（注意，不是Service接口）加入到Spring IoC容器中12@Servicepublic class SeckillServiceImpl implements SeckillService;在需要进行事务声明的方法上加上事务的注解@Transactional123@Transactionalpublic SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException &#123;&#125;Spring的声明式事务管理异常捕获机制Java异常分编译期异常和运行期异常，运行期异常不需要手工try-catch，Spring的的声明式事务只接收运行期异常回滚策略，非运行期异常不会帮我们回滚。事务传播行为Spring一共有7个事务传播行为，默认的事务传播行为是PROPAGATION_REQUIRED，详情可以参考这篇文章使用注解控制事务方法的优点（对于秒杀这种对事务延迟要求高的业务场景尤为重要）1.开发团队达成一致约定，明确标注事务方法的编程风格2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部（保证事务方法里面是很干净的/效率的）3.不是所有的方法都需要事务，如只有一条修改操作、只读操作不要事务控制（MYSQL 表级锁、行级锁）为什么使用IoC（控制反转）对象创建统一托管。规范的生命周期管理。灵活的依赖注入。一致的对象获取方式。Spring基于注解的事务操作在Spring早期版本中是使用ProxyFactoryBean+XMl方式来配置事务。在Spring配置文件使用tx:advice+aop命名空间，好处就是一次配置永久生效，你无须去关心中间出的问题，不过出错了你很难找出来在哪里出了问题。注解@Transactional的方式，注解可以在方法定义、接口定义、类定义、public方法上，但是不能注解在private、final、static等方法上，因为Spring的事务管理默认是使用Cglib动态代理的：private方法因为访问权限限制，无法被子类覆盖final方法无法被子类覆盖static是类级别的方法，无法被子类覆盖protected方法可以被子类覆盖，因此可以被动态字节码增强不能被Spring AOP事务增强的方法序号动态代理策略不能被事务增强的方法1基于接口的动态代理除了public以外的所有方法，并且public static的方法也不能被增强2基于Cglib的动态代理private、static、final的方法关于Spring的组件注解、注入注解@Component：标识一个组件，当不知道是什么组件，或者该组件不好归类时使用该注解@Service：标识业务层组件@Repository：标识DAO层组件@Controller：标识控制层组件通过Spring提供的组件自动扫描机制，可以在类路径下寻找标注了上述注解的类，并把这些类纳入进spring容器中管理，这些注解的作用和在xml文件中使用bean节点配置组件时一样的。1&lt;context:component-scan base-package=”xxx.xxx.xxx”&gt;component-scan标签默认情况下自动扫描指定路径下的包(含所有子包)，将带有@Component、@Repository、@Service、@Controller标签的类自动注册到spring容器。getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定。这种bean默认是“singleton”的，如果想改变，可以使用@Scope(“prototype”)来改变。当使用&lt;context:component-scan/&gt;后，就可以将&lt;context:annotation-config/&gt;移除了，前者包含了后者。另外，@Resource，@Inject 是J2EE规范的一些注解@Autowired是Spring的注解，可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过 @Autowired的使用来消除setter/getter方法，默认按类型装配，如果想使用名称装配可以结合@Qualifier注解进行使用，如下：12@Autowired() @Qualifier("baseDao") private BaseDao baseDao;与@Autowired类似的是@Resource，@Resource属于J2EE规范，默认安照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。12@Resource(name="baseDao") private BaseDao baseDao;而@Inject与@Autowired类似，也是根据类型注入，也可以通过@Named注解来按照name注入，此时只会按照名称进行装配。12@Inject @Named("baseDao")private BaseDao baseDao;5. 进行Service层的集成测试使用logback来输出日志信息，在resources包下创建logback.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt;通过IDE工具快速生成Junit单元测试，然后在各个方法里写测试代码。12345678910111213141516171819202122232425@RunWith(SpringJUnit4ClassRunner.class)//告诉junit spring的配置文件@ContextConfiguration(&#123;"classpath:spring/spring-dao.xml", "classpath:spring/spring-service.xml"&#125;)public class SeckillServiceTest &#123; private final Logger logger= LoggerFactory.getLogger(this.getClass()); @Autowired private SeckillService seckillService; @Test public void testGetSeckillList() throws Exception &#123; List&lt;Seckill&gt; list=seckillService.getSeckillList(); logger.info("list=&#123;&#125;", list); &#125; @Test public void testGetById() throws Exception &#123; long seckillId=1000; Seckill seckill=seckillService.getById(seckillId); logger.info("seckill=&#123;&#125;", seckill); &#125;&#125;在测试通过了这两个方法后，开始对后两个业务逻辑方法的测试，首先测试testExportSeckillUrl()123456@Testpublic void testExportSeckillUrl() throws Exception &#123; long seckillId=1000; Exposer exposer=seckillService.exportSeckillUrl(seckillId); logger.info("exposer=&#123;&#125;", exposer);&#125;会发现没有返回商品的秒杀地址，因为我们数据库的秒杀时间和结束秒杀时间没有修改，所以判断当前商品的秒杀已结束。将数据库中的秒杀时间和结束秒杀时间修改成满足我们当前的时间的范围，重新测试该方法，可以获取到该商品的秒杀地址。而第四个方法的测试需要使用到该地址（md5），将该值传入到testExecuteSeckill()中进行测试：123456789@Testpublic void testExecuteSeckill() throws Exception &#123; long seckillId=1000; long userPhone=13476191876L; String md5="70b9564762568e9ff29a4a949f8f6de4"; SeckillExecution execution=seckillService.executeSeckill(seckillId,userPhone,md5); logger.info("result=&#123;&#125;", execution);&#125;需要注意的是，该方法是会产生异常的，比如我们重复运行该方法，会报错，因为用户进行了重复秒杀，所以我们需要手动try-catch，将程序允许的异常包起来而不去向上抛给junit，更改测试代码如下:1234567891011121314151617@Testpublic void testExecuteSeckill() throws Exception &#123; long seckillId=1000; long userPhone=13476191876L; String md5="70b9564762568e9ff29a4a949f8f6de4"; try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); logger.info("result=&#123;&#125;", execution); &#125;catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125;catch (SeckillCloseException e1) &#123; logger.error(e1.getMessage()); &#125;&#125;在测试过程中，第四个方法使用到了第三个方法返回的秒杀地址，在实际开发中，我们需要将第三个和第四个方法合并成一个完整逻辑的方法：1234567891011121314151617181920212223242526//集成测试代码完整逻辑，注意可重复执行@Test public void testSeckillLogic() throws Exception &#123; long seckillId=1000; Exposer exposer=seckillService.exportSeckillUrl(seckillId); if (exposer.isExposed()) &#123; logger.info("exposer=&#123;&#125;", exposer); long userPhone=13476191876L; String md5=exposer.getMd5(); try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); logger.info("result=&#123;&#125;", execution); &#125;catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125;catch (SeckillCloseException e1) &#123; logger.error(e1.getMessage()); &#125; &#125;else &#123; //秒杀未开启 logger.warn("exposer=&#123;&#125;", exposer); &#125; &#125;我们可以在SeckillServiceTest类里面加上@Transational注解，原因是：@Transactional注解是表明此测试类的事务启用，这样所有的测试方案都会自动的 rollback，即不用自己清除自己所做的任何对数据库的变更了。日志无法打印的问题在pom.xml中加上123456789&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt;存在的坑关于同类中调用事务方法的时候有个坑，同学们需要注意下AOP切不到调用事务方法。事务不会生效，解决办法有几种，可以搜一下，找一下适合自己的方案。本质问题是类内部调用时AOP不会用代理调用内部方法。没有引入AOP的xsd会报错12345xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance http://www.springmodules.org/schema/cache/springmodules-cache.xsd http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd"相关链接Spring事务异常回滚，捕获异常不抛出就不会回滚本节结语至此，关于Java高并发秒杀API的Service层的开发与测试已经完成，接下来进行Web层的开发，详情请参考下一篇文章。上一篇文章：Java高并发秒杀API(一)之业务分析与DAO层下一篇文章：Java高并发秒杀API(三)之Web层]]></content>
      <categories>
        <category>项目笔记</category>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
        <tag>Java Web</tag>
        <tag>SSM框架</tag>
        <tag>高并发</tag>
        <tag>seckill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发秒杀API(一)之业务分析与DAO层]]></title>
    <url>%2Fposts%2F56225.html</url>
    <content type="text"><![CDATA[本SSM实战项目使用了Maven进行依赖管理，如果有不清楚Maven是什么的可以参考这篇文章1. 创建Maven项目和依赖1.1 创建项目前需要先安装Maven，并设置好环境变量Maven下载设置环境变量新建变量MAVEN_HOME，值为Maven的目录X:\XXX\apache-maven-XXX将%MAVEN_HOME%\bin添加到Path变量下运行CMD，输入mvn -v后可以看到Maven的版本信息等则表示安装成功1.2 创建Maven项目有两种方式，如下第一种创建方式：使用命令行手动创建1mvn archetype:generate -DgroupId=com.lewis.seckill -DartifactId=seckill -Dpackage=com.lewis.seckill -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp在视频中使用的是archetype:create，该方法已被废弃，请使用archetype:generate来创建。命令行执行后会创建一个maven-archetype-webapp骨架的Maven项目，其中groupId是项目组织唯一的标识符，实际对应JAVA的包的结构；artifactId是项目的唯一的标识符，实际对应项目的名称；package一般是groupId+artifactId，是自动生成的，可以修改第二种创建方式：借助IDE工具的Maven插件来创建项目Eclipse安装Maven插件不知道怎么Maven插件的请参考该博文，推荐使用link方式手工安装的方式如果是手工安装Maven插件的，可能会缺少pom.xml 图形化编辑工具，请另外添加进去，具体情况请参考该博文已经安装了Maven插件的请走下一个步骤File→New→Other...→Maven Project→Next,进入如下界面点击Next，选择要构建的骨架maven-archetype-webapp，如下图点击Next，填写groupId=com.lewis.seckill，DartifactId=seckill，package=com.lewis.seckill（根据实际情况填写），然后Finish如果是第一次使用Eclipse的Maven插件来创建Maven项目的可能会遇到一些问题，可以参考该博文1.3 修改pom.xml文件当创建完Maven项目后会在根目录下有一个pom.xml文件，Maven项目通过pom.xml进行项目依赖的管理，如果没有该xml文件，Eclipse不会将该项目当作一个Maven项目添加项目需要的jar包依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lewis&lt;/groupId&gt; &lt;artifactId&gt;seckill&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;seckill Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--补全项目依赖 --&gt; &lt;!--1.日志 java日志有:slf4j,log4j,logback,commons-logging slf4j,commons-logging:是规范/接口 日志实现:log4j,logback 使用:slf4j+logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--2.数据库相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--3.dao框架:MyBatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis自身实现的spring整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--4.Servlet web相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--5:spring依赖 --&gt; &lt;!--1)spring核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--2)spring dao层依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--3)springweb相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--4)spring test相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加redis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--prostuff序列化依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;seckill&lt;/finalName&gt; &lt;resources&gt; &lt;!--打包时包含源代码包下的资源文件 默认情况下只会打包src/main/java下的源代码 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt;关于maven依赖的简化写法教学视频中老师写了很多的依赖，但其实这里面有一些是可以省略不写的，因为有些包会自动依赖其它的包（Maven的传递性依赖）。这里面可以省略的依赖有：spring-core;spring-beans（上面这两个spring-context会自动依赖）;spring-context，spring-jdbc（mybatis-spring会依赖）；spring-web（spring-webmvc会依赖）；logback-core（logback-classic会依赖）有想要了解Maven的依赖范围与传递性依赖的请参考该博文2. 秒杀业务分析2.1 业务分析秒杀业务的核心是对库存的处理，其业务流程如下图用户针对库存业务分析当用户执行秒杀成功时，应该发生以下两个操作：减库存记录购买明细这两个操作属于一个完整事务，通过事务来实现数据落地为什么需要事务？减库存却没有记录购买明细，会导致商品少卖记录购买明细却没有减库存，会导致商品超卖在实际中，以上都是很严重的事故，会给商家或买家带来损失，这是不能被允许的。一旦发生这种事故，事故责任很自然的就会去找设计实现业务的程序员如何实现数据落地？有MySQL与NoSQL两种数据落地的方案MySQL属于关系型数据库，而MySQL内置的事务机制来可以准确的帮我们完成减库存和记录购买明细的过程。MySQL有多种存储引擎，但只有InnoDB存储引擎支持事务。InnoDB支持行级锁和表级锁，默认使用行级锁NoSQL属于非关系型数据库，近些年来在数据存储方面承担了很大的职责，但是对于事务的支持做的并不是很好，更多追求的是性能、高复用、分布式。事务机制依然是目前最可靠的数据落地方案。数据落地与不数据落地落地数据：就是被持久化的数据，这种数据一般放在硬盘或是其他的持久化存储设备里，例如：图片、系统日志、在页面上显示的数据以及保存在关系数据库里的数据等等，落地数据一定会有一个固定的载体，他们不会瞬时消失的。不落地数据：一般指存储在内存或者是网络传输里的数据，这些数据是瞬时，使用完毕就会消失，例如：我们在浏览器发送给服务器的请求；从数据库读取出来的一直到页面展示前的数据等等。“不落地”传输能够满足用户在性能上的要求。2.2 使用MySQL实现秒杀的难点分析难点问题：如何高效地处理竞争？当一个用户在执行秒杀某件商品时，其他也想要秒杀该商品的用户就只能等待，直到上一个用户提交或回滚了事务，他才能够得到该商品的锁执行秒杀操作。这里就涉及到了锁的竞争。对于MySQL来说，竞争反应到背后的技术是就是事务+行级锁：start transaction（开启事务）→ update库存数量 → insert购买明细 → commit（提交事务）在秒杀系统中，在同一时刻会有很多用户在秒杀同一件商品，那么如何高效低处理这些竞争？如何高效地提交事务？这些将在Java高并发秒杀API(四)之高并发优化进行分析总结。实现哪些秒杀功能？下面先以天猫的秒杀库存系统为例，如下图可以看到，天猫的秒杀库存系统是很复杂的，需要很多工程师共同开发。在这里，我们只实现秒杀相关的功能秒杀接口暴露执行秒杀相关查询为什么要进行秒杀接口暴露的操作？现实中有的用户回通过浏览器插件提前知道秒杀接口，填入参数和地址来实现自动秒杀，这对于其他用户来说是不公平的，我们也不希望看到这种情况3. DAO层设计3.1 创建数据库源码里有个sql文件夹，可以给出了sql语句；也可以选择自己手写。数据库一共就两个表：秒杀库存表、秒杀成功明细表。12345678910111213141516171819202122232425262728293031323334353637-- 数据库初始化脚本-- 创建数据库CREATE DATABASE seckill;-- 使用数据库use seckill;CREATE TABLE seckill( `seckill_id` BIGINT NOT NUll AUTO_INCREMENT COMMENT '商品库存ID', `name` VARCHAR(120) NOT NULL COMMENT '商品名称', `number` int NOT NULL COMMENT '库存数量', `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `start_time` TIMESTAMP NOT NULL COMMENT '秒杀开始时间', `end_time` TIMESTAMP NOT NULL COMMENT '秒杀结束时间', PRIMARY KEY (seckill_id), key idx_start_time(start_time), key idx_end_time(end_time), key idx_create_time(create_time))ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT='秒杀库存表';-- 初始化数据INSERT into seckill(name,number,start_time,end_time)VALUES ('1000元秒杀iphone6',100,'2016-01-01 00:00:00','2016-01-02 00:00:00'), ('800元秒杀ipad',200,'2016-01-01 00:00:00','2016-01-02 00:00:00'), ('6600元秒杀mac book pro',300,'2016-01-01 00:00:00','2016-01-02 00:00:00'), ('7000元秒杀iMac',400,'2016-01-01 00:00:00','2016-01-02 00:00:00');-- 秒杀成功明细表-- 用户登录认证相关信息(简化为手机号)CREATE TABLE success_killed( `seckill_id` BIGINT NOT NULL COMMENT '秒杀商品ID', `user_phone` BIGINT NOT NULL COMMENT '用户手机号', `state` TINYINT NOT NULL DEFAULT -1 COMMENT '状态标识:-1:无效 0:成功 1:已付款 2:已发货', `create_time` TIMESTAMP NOT NULL COMMENT '创建时间', PRIMARY KEY(seckill_id,user_phone),/*联合主键*/ KEY idx_create_time(create_time))ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='秒杀成功明细表';秒杀成功明细表为何使用联合主键之所以使用联合主键，是为了能够过滤重复插入，可以通过insert ignore into语句来避免用户重复秒杀同一件商品。这样当有重复记录就会忽略，语句执行后返回数字0。可能存在的问题安装视频里的建表过程，可能会出现建表失败的情况。原因是当你给一个timestamp设置为on update current_timestamp的时候，其他的timestamp字段需要显式设定default值。但是如果你有两个timestamp字段，但是只把第一个设定为current_timestamp而第二个没有设定默认值，MySQL也能成功建表,但是反过来就不行。这是mysql5.5版本对timestamp的处理。为了解决这个问题，将create_time放到start_time和end_time的前面，还有的mysql版本需要将三个时间戳都设置默认值。3.2 创建数据表对应的实体类在src/main/java包下创建com.lewis.entity包，接着建立Seckill实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Seckill &#123; private Long seckillId; private String name; private Integer number; private Date createTime; private Date startTime; private Date endTime; public Long getSeckillId() &#123; return seckillId; &#125; public void setSeckillId(Long seckillId) &#123; this.seckillId = seckillId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public Integer getNumber() &#123; return number; &#125; public void setNumber(Integer number) &#123; this.number = number; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Date getStartTime() &#123; return startTime; &#125; public void setStartTime(Date startTime) &#123; this.startTime = startTime; &#125; public Date getEndTime() &#123; return endTime; &#125; public void setEndTime(Date endTime) &#123; this.endTime = endTime; &#125; @Override public String toString() &#123; return "Seckill [seckillId=" + seckillId + ", name=" + name + ", number=" + number + ", createTime=" + createTime + ", startTime=" + startTime + ", endTime=" + endTime + "]"; &#125;&#125;在com.lewis.entity包下，接着建立SuccessKilled实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class SuccessKilled &#123; private Byte state; private Date createTime; private Long seckillId; private Long userPhone; // 多对一,因为一件商品在库存中有很多数量，对应的购买明细也有很多。 private Seckill seckill; public Seckill getSeckill() &#123; return seckill; &#125; public void setSeckill(Seckill seckill) &#123; this.seckill = seckill; &#125; public Long getSeckillId() &#123; return seckillId; &#125; public void setSeckillId(Long seckillId) &#123; this.seckillId = seckillId; &#125; public Long getUserPhone() &#123; return userPhone; &#125; public void setUserPhone(Long userPhone) &#123; this.userPhone = userPhone; &#125; public Byte getState() &#123; return state; &#125; public void setState(Byte state) &#123; this.state = state; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return "SuccessKilled [state=" + state + ", createTime=" + createTime + ", seckillId=" + seckillId + ", userPhone=" + userPhone + "]"; &#125;&#125;3.3 创建实体类对应的DAO层接口（也就是Mapper接口，DAO针对的是具体实体来操作的“实体的增删改查”）在src/main/java下建立com.lewis.dao包，在包下建立SeckillDao接口12345678910111213141516171819202122232425262728public interface SeckillDao &#123; /** * 减库存 * * @param seckillId * @param killTime * @return 更新的记录行数，如果返回值&lt;1则表示更新失败 */ int reduceNumber(@Param("seckillId") long seckillId, @Param("killTime") Date killTime); /** * 根据id查询秒杀商品 * * @param seckillId * @return */ Seckill queryById(long seckillId); /** * 根据偏移量查询秒杀商品列表 * * @param offset * @param limit * @return */ List&lt;Seckill&gt; queryAll(@Param("offset") int offset, @Param("limit") int limit);&#125;在com.lewis.dao包下建立SuccessKilledDao接口12345678910111213141516171819public interface SuccessKilledDao &#123; /** * 插入购买明细，可过滤重复 * * @param seckillId * @param userphone * @return 插入的行数，如果返回值&lt;1则表示插入失败 */ int insertSuccessKilled(@Param("seckillId") long seckillId, @Param("userPhone") long userPhone); /** * 根据id查询SuccessKilled并携带秒杀商品对象实体 * * @param seckillId * @return */ SuccessKilled queryByIdWithSeckill(@Param("seckillId") long seckillId, @Param("userPhone") long userPhone);&#125;为什么有的方法形参前有@Param，有的却没有？从上面的代码可以发现，当方法的形参在两个及两个以上时，需要在参数前加上@Param，如果不加上该注解会在之后的测试运行时报错。这是Sun提供的默认编译器（javac）在编译后的Class文件中会丢失参数的实际名称，方法中的形参会变成无意义的arg0、arg1等，在只有一个参数时就无所谓，但当参数在两个和两个以上时，传入方法的参数就会找不到对应的形参。因为Java形参的问题，所以在多个基本类型参数时需要用@Param注解区分开来。3.4 基于MyBatis实现DAO接口MyBatis怎么用？SQL写在哪里？Mybatis有两种提供SQL的方式：XML提供SQL、注解提供SQL（注解是java5.0之后提供的一个新特性）。对于实际的使用中建议使用XML文件的方式提供SQL。如果通过注解的方式提供SQL，由于注解本身还是java源码，这对于修改和调整SQL其实是非常不方便的，一样需要重新编译类，当我们写复杂的SQL尤其拼接逻辑时，注解处理起来就会非常繁琐。而XML提供了很多的SQL拼接和处理逻辑的标签，可以非常方便的帮我们去做封装。如何去实现DAO接口？Mapper自动实现DAO（也就是DAO只需要设计接口，不需要去写实现类，MyBatis知道我们的参数、返回类型是什么，同时也有SQL文件，它可以自动帮我们生成接口的实现类来帮我们执行参数的封装，执行SQL，把我们的返回结果集封装成我们想要的类型） 。第二种是通过API编程方式实现DAO接口（MyBatis通过给我们提供了非常多的API，跟其他的ORM和JDBC很像）在实际开发中建议使用Mapper自动实现DAO，这样可以直接只关注SQL如何编写，如何去设计DAO接口，帮我们节省了很多的维护程序，所有的实现都是MyBatis自动完成。创建一个目录存放Mybatis的SQL映射按照Maven的规范，SQL映射文件应该放在src/main/resources包下，在该包下建立mapper目录，用来存放映射DAO接口的XML文件。这样Maven在编译时就会自动将src/main/resources下的这些配置文件编译进来。我们也可以按照原本的习惯，在src/main/java下建立com.lewis.mapper包，将这些SQL映射存放到这里。由于Maven默认不会编译src/main/java下除源码以外的文件，所以需要在pom.xml中进行额外的配置。12345678910111213141516&lt;build&gt; &lt;finalName&gt;seckill&lt;/finalName&gt; &lt;resources&gt; &lt;!--打包时包含源代码包下的资源文件，默认情况下只会打包src/main/java下的源代码 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;在本项目中，我是采用的第二种方式存放Mybatis的SQL映射。（只是将映射DAO的mapper文件放在java包下，其他的关于Spring、MyBatis等的配置文件还是放在resources包下）在src/main/resources目录下配置mybatis-config.xml（配置MyBatis的全局属性）打开MyBatis的官方文档（MyBatis的官方文档做的非常友好，提供了非常多版本的国际化支持），选择入门，找到MyBatis全局配置，里面有XML的规范（XML的标签约束dtd文件），拷入到项目的MyBatis全局配置文件中，开始配置MyBatis，如下：12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置全局属性 --&gt; &lt;settings&gt; &lt;!--使用jdbc的getGeneratekeys获取自增主键值，默认是false 当inert一条记录时我们是不插入id的，id是通过自增去赋值的 当插入完后想得到该插入记录的id时可以调用jdbc的getGeneratekeys --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!--使用列别名替换列名 默认值为true（可以不用写出来，这里写出来只是为了讲解该配置的作用） select name as title(实体中的属性名是title) form table; 开启后mybatis会自动帮我们把表中name的值赋到对应实体的title属性中 --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!--开启驼峰命名转换Table:create_time到 Entity(createTime) --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt;&lt;/configuration&gt;在src/main/java目录下的com.lewis.mapper包里创建SeckillDao.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:指定为哪个接口提供配置 --&gt; &lt;mapper namespace="com.lewis.dao.SeckillDao"&gt; &lt;!--目的:为dao接口方法提供sql语句配置， 即针对dao接口中的方法编写我们的sql语句 --&gt; &lt;!-- int reduceNumber(long seckillId, Date killTime);--&gt; &lt;!-- 这里id必须和对应的DAO接口的方法名一样 --&gt; &lt;update id="reduceNumber"&gt; UPDATE seckill SET number = number-1 WHERE seckill_id=#&#123;seckillId&#125; AND start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; AND end_time &gt;= #&#123;killTime&#125; AND number &gt; 0; &lt;/update&gt; &lt;!-- parameterType:使用到的参数类型 正常情况java表示一个类型的包名+类名，这直接写类名，因为后面有一个配置可以简化写包名的过程 --&gt; &lt;select id="queryById" resultType="Seckill" parameterType="long"&gt; &lt;!-- 可以通过别名的方式列明到java名的转换，如果开启了驼峰命名法就可以不用这么写了 select seckill_id as seckillId --&gt; SELECT seckill_id,name,number,create_time,start_time,end_time FROM seckill WHERE seckill_id=#&#123;seckillId&#125; &lt;/select&gt; &lt;select id="queryAll" resultType="Seckill"&gt; SELECT * FROM seckill ORDER BY create_time DESC limit #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt;&lt;/mapper&gt;在src/main/java目录下的com.lewis.mapper包里创建SuccessKilledDao.xml12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.lewis.dao.SuccessKilledDao"&gt; &lt;insert id="insertSuccessKilled"&gt; &lt;!--当出现主键冲突时(即重复秒杀时)，会报错;不想让程序报错，加入ignore--&gt; INSERT ignore INTO success_killed(seckill_id,user_phone,state) VALUES (#&#123;seckillId&#125;,#&#123;userPhone&#125;,0) &lt;/insert&gt; &lt;select id="queryByIdWithSeckill" resultType="SuccessKilled"&gt; &lt;!--根据seckillId查询SuccessKilled对象，并携带Seckill对象--&gt; &lt;!--如何告诉mybatis把结果映射到SuccessKill属性同时映射到Seckill属性--&gt; &lt;!--可以自由控制SQL语句--&gt; SELECT sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id "seckill.seckill_id", s.name "seckill.name", s.number "seckill.number", s.start_time "seckill.start_time", s.end_time "seckill.end_time", s.create_time "seckill.create_time" FROM success_killed sk INNER JOIN seckill s ON sk.seckill_id=s.seckill_id WHERE sk.seckill_id=#&#123;seckillId&#125; and sk.user_phone=#&#123;userPhone&#125; &lt;/select&gt;&lt;/mapper&gt;注：上面的s.seckill_id “seckill.seckill_id”表示s.seckill_id这一列的数据是Success_killed实体类里的seckill属性里的seckill_id属性，是一个级联的过程，使用的就是别名只是忽略了as关键字，别名要加上双引号。为什么要用&lt;![CDATA[]]&gt;把&lt;=给包起来CDATA指的是不应由 XML 解析器进行解析的文本数据，在XML元素中，&lt;和&amp;是非法的：&lt;会产生错误，因为解析器会把该字符解释为新元素的开始。&amp;也会产生错误，因为解析器会把该字符解释为字符实体的开始。（字符实体：比如&amp;nbsp;表示一个空格）所以在这里我们需要使用&lt;![CDATA[ &lt;= ]]&gt;来告诉XML&lt;=不是XML的语言。3.5 整合Spring和MyBatis在resources目录下创建一个新的目录spring(存放所有Spring相关的配置)在resources包下创建jdbc.properties，用于配置数据库的连接信息1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/seckill?useUnicode=true&amp;characterEncoding=utf-8jdbc.username=rootpassword=123在resources/spring目录下创建Spring关于DAO层的配置文件spring-dao.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--配置整合mybatis过程 1.配置数据库相关参数--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!--2.数据库连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--配置连接池属性--&gt; &lt;property name="driverClass" value="$&#123;driver&#125;" /&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="jdbcUrl" value="$&#123;url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!--c3p0私有属性--&gt; &lt;property name="maxPoolSize" value="30"/&gt; &lt;property name="minPoolSize" value="10"/&gt; &lt;!--关闭连接后不自动commit--&gt; &lt;property name="autoCommitOnClose" value="false"/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name="checkoutTimeout" value="1000"/&gt; &lt;!--当获取连接失败重试次数--&gt; &lt;property name="acquireRetryAttempts" value="2"/&gt; &lt;/bean&gt; &lt;!--约定大于配置--&gt; &lt;!--３.配置SqlSessionFactory对象--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--往下才是mybatis和spring真正整合的配置--&gt; &lt;!--注入数据库连接池--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--配置mybatis全局配置文件:mybatis-config.xml--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt; &lt;!--扫描entity包,使用别名,多个用;隔开--&gt; &lt;property name="typeAliasesPackage" value="com.lewis.entity"/&gt; &lt;!--扫描sql配置文件:mapper需要的xml文件--&gt; &lt;property name="mapperLocations" value="classpath:com/lewis/mapper/*.xml"/&gt; &lt;/bean&gt; &lt;!--４:配置扫描Dao接口包,动态实现DAO接口,注入到spring容器--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--注入SqlSessionFactory--&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描的Dao接口--&gt; &lt;property name="basePackage" value="com.lewis.dao"/&gt; &lt;/bean&gt; &lt;!--redisDao--&gt; &lt;!-- &lt;bean id="redisDao" class="com.lewis.dao.cache.RedisDao"&gt; &lt;constructor-arg index="0" value="localhost"/&gt; &lt;constructor-arg index="1" value="6379"/&gt; &lt;/bean&gt; --&gt;&lt;/beans&gt;关于数据库连接池的配置可能出现的问题在jdbc.properties里使用的是jdbc.username，而不是username或者name，这是因为后两个属性名可能会与全局变量冲突，导致连接的数据库用户名变成了电脑的用户名，所以使用了jdbc.username。相关链接关于Spring的XML配置文件的头部文件的说明可以参考这篇文章3.6 DAO层单元测试有不知道Eclipse如何直接进行生成快速的测试单元的，可以看看这篇文章使用Eclipse工具直接生成测试单元，这些测试代码按照Maven规范放到src/test/java包下。在生成的测试代码里测试我们的方法，测试的具体代码如下：SeckillDaoTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.lewis.dao;import static org.junit.Assert.*;import java.util.Date;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.lewis.entity.Seckill;/** * 配置Spring和Junit整合,junit启动时加载springIOC容器 spring-test,junit */@RunWith(SpringJUnit4ClassRunner.class)// 告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring/spring-dao.xml" &#125;)public class SeckillDaoTest &#123; // 注入Dao实现类依赖 @Resource private SeckillDao seckillDao; @Test public void testQueryById() &#123; long seckillId = 1000; Seckill seckill = seckillDao.queryById(seckillId); System.out.println(seckill.getName()); System.out.println(seckill); &#125; @Test public void testQueryAll() &#123; List&lt;Seckill&gt; seckills = seckillDao.queryAll(0, 100); for (Seckill seckill : seckills) &#123; System.out.println(seckill); &#125; &#125; @Test public void testReduceNumber() &#123; long seckillId = 1000; Date date = new Date(); int updateCount = seckillDao.reduceNumber(seckillId, date); System.out.println(updateCount); &#125;&#125;测试说明先左键单击要测试的那个方法名，再右键点击选择Debug As可以单独对该方法进行单元测试。三个方法都测试通过，但是对于最后一个方法会发现数据库中该商品数量并没有减少，这是因为我们设置了秒杀时间，当前时间不满足秒杀时间，所以不会秒杀成功减少数量。如果之前没有在DAO接口的多参数方法里在形参前加上@Param注解，那么在这里进行单元测试时，MyBatis会报绑定参数失败的错误，因为无法找到参数。这是因为Java没有保存行参的记录，Java在运行的时候会把queryAll(int offset,int limit)中的参数变成这样queryAll(int arg0,int arg1)，导致MyBatis无法识别这两个参数。SuccessKilledDaoTest.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.lewis.dao;import static org.junit.Assert.*;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.lewis.entity.SuccessKilled;@RunWith(SpringJUnit4ClassRunner.class)// 告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring/spring-dao.xml" &#125;)public class SuccessKilledDaoTest &#123; @Resource private SuccessKilledDao successKilledDao; @Test public void testInsertSuccessKilled() &#123; long seckillId = 1000L; long userPhone = 13476191877L; int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); System.out.println("insertCount=" + insertCount); &#125; @Test public void testQueryByIdWithSeckill() &#123; long seckillId = 1000L; long userPhone = 13476191877L; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); System.out.println(successKilled); System.out.println(successKilled.getSeckill()); &#125;&#125;测试说明测试方法同上，测试结果通过，另外由于我们使用了联合主键，在insert时使用了ignore关键字，所以对于testInsertSuccessKilled()重复插入同一条数据是无效的，会被过滤掉，确保了一个用户不能重复秒杀同一件商品。本节结语至此，关于Java高并发秒杀API的DAO层的开发与测试已经完成，接下来进行Service层的开发、测试，详情可以参考Java高并发秒杀API(二)之Service层。]]></content>
      <categories>
        <category>项目笔记</category>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
        <tag>Java Web</tag>
        <tag>SSM框架</tag>
        <tag>高并发</tag>
        <tag>seckill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM实战项目 - Java高并发秒杀API]]></title>
    <url>%2Fposts%2F65067.html</url>
    <content type="text"><![CDATA[前言本文包括了项目的完整流程+开发过程中遇到的各种坑的总结+学习笔记和问题扩展项目截图秒杀列表秒杀详情页错误提示开始秒杀秒杀成功重复秒杀秒杀倒计时秒杀结束项目介绍何为秒杀？所谓“秒杀”，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。为何选择Java高并发秒杀作为实战项目？秒杀业务场景具有典型事务特性秒杀/红包类需求越来越常见为何使用SpringMVC+Spring+MyBatis框架框架易于使用和轻量级低代码侵入性成熟的社区和用户群能从该项目得到什么收获？框架的使用和整合技巧秒杀分析过程与优化思路项目来源这是慕课网上的一个免费项目教学视频，名为Java高并发秒杀API，一共有如下四节课程，附带视频传送门（在视频中老师是用IDEA，本文用的是Eclipse）Java高并发秒杀API之业务分析与DAO层Java高并发秒杀API之Service层Java高并发秒杀API之Web层Java高并发秒杀API之高并发优化相关技术介绍MySQL表设计SQL技巧事务和行级锁MyBatisDAO层设计与开发MyBatis合理使用与Spring整合SpringSpring IOC整合Service声明式事务运用SpringMVCRestful借口设计和使用框架运作流程Controller开发技巧前端交互设计BootstrapjQuery高并发高并发点和高并发分析优化思路并实现开发环境操作系统：Windows 8IDE工具：EclipseJDK：JDK1.7中间件：Tomcat 7.0数据库：MySQL 5.0构建工具：Maven框架：SSM项目总结本文根据慕课网的视频教学进行了相应的学习总结，全文较长，分为四节，附带CSDN传送门Java高并发秒杀API(一)之业务分析与DAO层Java高并发秒杀API(二)之Service层Java高并发秒杀API(三)之Web层Java高并发秒杀API(四)之高并发优化项目源码源码下载GitHub地址]]></content>
      <categories>
        <category>项目笔记</category>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
        <tag>Java Web</tag>
        <tag>SSM框架</tag>
        <tag>高并发</tag>
        <tag>seckill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven - 依赖范围和传递性依赖]]></title>
    <url>%2Fposts%2Fa658ba27.html</url>
    <content type="text"><![CDATA[Maven的依赖范围在pom.xml文件中，有个节点是scope，用来表示依赖的范围。之所以会有依赖范围，是因为Maven在编译、测试和运行项目时会各自使用一套classpath，依赖范围就是用来控制这三种classpath的。简单来说，就是通过scope节点来控制项目的依赖是在编译时导入，还是在测试或运行项目时才导入。scope的值compile编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译，测试和运行的时候都需要使用该依赖。provided已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。runtime运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。test测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译、运行时无效。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。system系统依赖范围。该依赖范围与provided所表示的依赖范围一致，对于编译和测试classpath有效，但在运行时无效。只是使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用，systemPath元素可以引用环境变量。Maven的传递性依赖什么是传递性依赖有时候我们在pom.xml文件中引入的依赖，其本身就需要依赖于其他的依赖，这时候我们不需要去考虑这些依赖，Maven会解析各个直接依赖的pom，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。通过传递性依赖，我们可以在pom.xml文件中少写不少的依赖配置传递性依赖的依赖范围假如当前项目为A，A依赖于B，B依赖于C。此时称A对于B是第一直接依赖，B对于C是第二直接依赖，而A对于C是传递性依赖。只要知道B在A项目中的scope，就可以知道C在A中的scope。其依赖范围如下：表格的第一列是B在A中的依赖范围，第一行是C在B中的依赖范围，交叉的格子是C在A中的依赖范围；下表中的-表示不传递依赖。&nbsp;compileprovidedtestruntimecompilecompile--runtimeprovidedprovidedprovided-providedruntimeruntime--runtimetesttest--test总结当C在B中的scope为test时，A不依赖C，C直接被丢弃当C在B中的scope为provided时，只有当B在A中的scope也是provided时，A才会依赖C，这时候C在A的scope是provided当C在B中的scope为compile或runtime时，A依赖C，此时C在A中的scope继承自B在A的scope。注意，如果C的scope是runtime，B的scope是compile，此时C在A的scope是runtime，而不是compile参考链接Maven依赖规则和依赖范围]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 如何在新的工作空间使用原来的配置(编码、视图、快捷键、插件设置等)]]></title>
    <url>%2Fposts%2F3084e42f.html</url>
    <content type="text"><![CDATA[情景Eclipse如果更换一个新的工作空间，需要重新设置视图、配置等一系列东西，算是想到麻烦的一件事情，其实我们完全可以将旧的工作空间里的配置拷贝到新的工作空间里，这样就可以省去重新配置的麻烦了~具体操作如下：在${workspace(你电脑里原本的工作空间目录)}/.metadata/.plugins里有这样两个文件夹：org.eclipse.core.runtime和org.eclipse.ui.workbench，将新的工作空间里的同名文件夹删了，再将这两个文件夹复制到新的工作空间就行了！org.eclipse.core.runtime：保存着Eclipse的用户配置，包括视图、编码、各种插件的配置(window下的preference里边的插件配置)等org.eclipse.ui.workbench：保持着ui上的配置，包括上方的快捷工具栏和下方的view窗口等如果不知道自己正在使用的工作空间在哪个目录下，请点击Eclipse左上角的File→switch workspace→other，显示的就是当前工作空间的目录。另外，在这里有个copy setting，可以选择转换到新的工作空间时拷贝原本的配置，但这里拷贝的其实只是org.eclipse.ui.workbench，缺少了org.eclipse.core.runtime，所以这种方法会丢失部分配置。另外不要没事就随便转换工作空间，Eclipse容易崩溃(:3」∠)]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 修改默认编码为utf-8]]></title>
    <url>%2Fposts%2Fc23cad48.html</url>
    <content type="text"><![CDATA[配置方式一共需要设置三个地方：Window-&gt;Preferences-&gt;General -&gt;Content Type-&gt;Text-&gt;JSP，在 最下面设置为UTF-8Window-&gt;Preferences-&gt;General-&gt;Workspace，将Text file encoding 设置UTF-8Window-&gt;Preferences-&gt;Web-&gt;JSP Files，设置为 ISO 10646/Unicode(UTF-8)]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven - 使用阿里云国内镜像提高jar包下载速度]]></title>
    <url>%2Fposts%2F83b08349.html</url>
    <content type="text"><![CDATA[转载自：maven(八)，阿里云国内镜像，提高jar包下载速度镜像由于Maven默认是从中央仓库去下载的jar包，该仓库在国外，且全世界都从该仓库下载，所以下载速度会很慢。镜像就相当于中央仓库的一个副本，内容和中央仓库完全一样，目前有不少国内镜像，其中阿里云算是比较稳定的，同时也能保证下载速度。配置方法在Maven的安装目录下找到conf/settings.xml，打开该文件，找到mirrors节点，添加一个国内镜像。12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;添加之后，如果使用了Eclipse的话需要重启才能生效。使用了阿里云镜像后，jar包的下载速度会快很多。Nexus私服在阿里云下载路径中，可以看到有一个Nexus，它实际上是一个Nexus私服。我们也可以在公司内网中部署一个这样的Nexus私服，项目成员可以直接从内网下载jar包，内网通常比从镜像下载速度更快，而且不用连外网。]]></content>
      <categories>
        <category>依赖管理工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse - 修改properties文件的编码]]></title>
    <url>%2Fposts%2F9cdb7e13.html</url>
    <content type="text"><![CDATA[配置方法Eclipse的properties文件是默认ISO-8859-1编码的，如果在properties里输入中文会导致乱码，此时需要修改其编码为utf-8，具体步骤如下：Window→Preferences→General→Content Types→Text，然后单击Java Properties Files，选定下方的*.properties(locked)，接着将最下方的ISO-8859-1改为utf-8，然后点击旁边的 Update，最后点击OK。]]></content>
      <categories>
        <category>IDE工具</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>IDE工具</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
