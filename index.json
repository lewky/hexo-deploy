[{"categories":["饮食"],"content":"食材 适量面条，3颗鲜香菇，1个番茄，1根火腿，1-2个鸡蛋，一把青菜 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:1:0","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"调料 生抽、老抽、香油（芝麻油）、白糖、番茄酱、葱姜蒜 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:2:0","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"步骤 开水下锅，面条煮到八分熟（想煮快点可以在水开时加入小部分冷水） 准备凉开水或冰水，用来浸泡面条以提升口感 准备调料： 1勺生抽 半勺老抽 半勺香油 半勺白糖提鲜 1勺番茄酱 面条里加入调料并拌匀 3颗鲜香菇切片、一根火腿切片、葱姜蒜切碎、一个番茄切块（无需去皮） 用1-2个鸡蛋打成液，热锅加油，用小火炒成鸡蛋碎，备用 煎炸火腿，炒熟备用，留下底油 葱姜蒜爆香，加入番茄炒软，加入1勺生抽和1勺耗油，再加入鲜香菇片炒软 接着放拌好的面条，放入炒好的鸡蛋碎、青菜、煎好的火腿，再炒匀即可 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:3:0","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"电磁炉做法 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:4:0","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"个人心得 上面的步骤是家庭小灶的做法，下面是博主个人用电磁炉的做法心得： 凉开水不能泡太久面条，简单过一遍就行，否则面条会过度发胀变软。 个人不喜欢双汇火腿，虽然很容易剥开包装，但是会有一股扑面而来的淀粉味，直接水煮的话感觉味道并不好，煎炸才会味道好些。 炒鸡蛋碎的时候还是要在搅拌鸡蛋液时加点盐，不然没味道。 番茄不能炒太久，否则会变得更酸。炒之前先用热水泡一会，炒番茄的时候建议加一些番茄酱和白糖中和酸味。 青菜要先炒熟，在电磁炉锅里开水加盐30秒后再下青菜炒熟（煮熟）。考虑到装盘问题，炒青菜这一步要在葱姜蒜爆香和炒番茄之前。 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:4:1","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"步骤 下面是改良后的电磁炉做法步骤： 开水下锅，面条煮到八分熟 热水泡下洗净后的番茄 准备凉开水或冰水，简单过一下面条 准备调料： 1勺生抽 半勺老抽 半勺香油 半勺白糖提鲜 1勺番茄酱 面条里加入调料并拌匀 3颗鲜香菇切片、一根火腿切片、葱姜蒜切碎、一个番茄切块（无需去皮） 电磁炉锅里开水加油加盐30秒后再下青菜炒熟（煮熟），装盘备用 用1-2个鸡蛋打成液，加入少量盐搅拌均匀，热锅加油，用小火炒成鸡蛋碎，备用 煎炸火腿，炒熟备用，留下底油 葱姜蒜爆香，加入番茄炒软，加入1勺生抽、1勺耗油、1勺番茄酱，再加入鲜香菇片炒软 接着放拌好的面条，放入炒好的鸡蛋碎和青菜、煎好的火腿，再炒匀即可 切记全程要控制油温，如果温度太高，油遇水会溅射，关键在于水是否沸腾了，水一旦沸腾就会气化造成油飞溅。 ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:4:2","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["饮食"],"content":"参考链接 吃一次就上瘾的的番茄炒面！！我吃哭了 心目中懒人炒面排行第一！ ","date":"2020-10-13","objectID":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/:5:0","tags":["做菜","面食"],"title":"小白学做菜(1) - 番茄炒面","uri":"/posts/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%81%9A%E8%8F%9C1-%E7%95%AA%E8%8C%84%E7%82%92%E9%9D%A2.html/"},{"categories":["Hugo系列"],"content":"背景 本文基于LoveIt主题【v0.2.10】，且所使用的Hugo版本如下，不同版本且不同主题可能无法适用某些属性： \u003ehugo version Hugo Static Site Generator v0.74.2-48565DE6 windows/amd64 BuildDate: 2020-07-17T17:22:50Z ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:1:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"配置文件 Hugo默认使用根目录下的config.toml、config.yaml或config.json中的某一个作为站点的配置文件，可以通过--config来配置读取一个或多个配置文件，如下： hugo --config debugconfig.toml hugo --config a.toml,b.toml,c.toml ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:2:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"配置文件的目录 除了使用单一的站点配置文件，还可以通过使用configDir变量（默认值为config/）来维护不同环境下的各组件的配置文件： 每个文件各自对应配置文件的根对象，比如Params, Menus, Languages等。 每个子目录对应不同的环境配置，类似于Maven的Profile功能。 这些文件可以应用国际化功能，即区分不同的语言版本。 下面是一个简单的例子： ├── config │ ├── _default │ │ ├── config.toml │ │ ├── languages.toml │ │ ├── menus.en.toml │ │ ├── menus.zh.toml │ │ └── params.toml │ ├── production │ │ ├── config.toml │ │ └── params.toml │ └── staging │ ├── config.toml │ └── params.toml 可以发现上述的结构中，存在着三种不同的环境配置：_default默认环境、production生成环境、staging演示环境。_default下的配置是通用配置，Hugo每次生成站点时都会读取。如果运行hugo --environment staging，则还会额外合并staging的配置（会替换_default下冲突的配置）。 一般情况下我们用不到多环境的功能，只需要在站点根目录下存放一个config.toml文件，直接在该配置文件中指定各种属性，就可以实现相当程度的个性化了。下面是一些常用的配置文件的属性的用法，这些属性都是配置在站点配置文件里的。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:3:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"theme主题属性 配置你的Hugo主题款式，本文基于LoveIt主题【v0.2.10】，所以配置是： theme = \"LoveIt\" ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:4:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"网站路径相关的属性 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:5:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"baseURL 网站的根路径，用法如下： baseURL = \"https://mySite.com/\" ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:5:1","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"disablePathToLower 是否禁止将网站路径转换成小写，建议设置成true： disablePathToLower = true ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:5:2","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"permalinks 生成的文章的路径，默认配置如下： [permalinks] posts = \"/:year/:month/:title/\" 这里可以使用的变量如下： :year：4位数的年份 :month：2位数的月份 :monthname：月份名字 :day：2位数的日期 :weekday：1位数，每周的第几天，星期日对应0 :weekdayname：星期几 :yearday：1到3位数，每年的第几天 :section：当前文章对应的section分类 :sections：当前文章对应的完整的section分类层次 :title：文章的标题 :slug：文章的slug，和title一样是定义在文件头里的属性，当没有定义slug时会使用title作为url :filename：文章的文件名，不包括文件扩展名。 出于seo考虑，不建议在url里加上年月日之类的，由于标题大多有中文或者特殊字符，所以也不建议直接使用标题作为url的一部分。这里建议使用slug的方式，自己手动给每篇文章提取若干个关键词作为slug，以此作为url的一部分，如下： [permalinks] posts = \"/posts/:slug.html\" 然后文章的slug可以这样配置**（permalinks是配置在站点配置文件里的，slug是配置在每篇文章的文件头里的）**： --- title: 建站日志 slug: e62c38c45 --- 我这里是因为文章是从hexo迁移过来的，hexo那边使用了abbrlink插件来生成随机且不重复的名字，为了和之前的文章url对齐就这样配置了。而hugo没有找到类似的插件，所以选择了slug来自定义url，这个功能倒是和博客园的自定义博文的url类似。 另外值得一提的是，默认用的是pretty Url的配置，所有url的末尾都有个/，而Hexo那边url末尾是没有这个/的，算是一点小小的不同。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:5:3","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"uglyurls 这个属性针对默认的pretty Url，比如有个url是/posts/e62c38c45/。如果设置了uglyurls = true，则会把末尾的/改成.html，新的url就变成了/posts/e62c38c45.html。但是这个属性有个问题，它会把文章以外的url也变成这种“丑陋”的格式，比如分类、标签等url，这样就不美观了。 所以不推荐使用该属性，如果希望文章的url不是纯目录格式的，可以像上文的permalinks那样配置。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:5:4","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"markup标记属性 配置markdown解析器、代码块高亮、文章目录等。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:6:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"markdown解析器 Hugo提供了asciidocExt、blackFriday和goldmark三种markdown解析器，默认使用goldmark来解析markdown，如下： markup: asciidocExt: attributes: {} backend: html5 extensions: [] failureLevel: fatal noHeaderOrFooter: true safeMode: unsafe sectionNumbers: false trace: false verbose: false workingFolderCurrent: false blackFriday: angledQuotes: false extensions: null extensionsMask: null footnoteAnchorPrefix: \"\" footnoteReturnLinkContents: \"\" fractions: true hrefTargetBlank: false latexDashes: true nofollowLinks: false noreferrerLinks: false plainIDAnchors: true skipHTML: false smartDashes: true smartypants: true smartypantsQuotesNBSP: false taskLists: true defaultMarkdownHandler: goldmark goldmark: extensions: definitionList: true footnote: true linkify: true strikethrough: true table: true taskList: true typographer: true parser: attribute: true autoHeadingID: true autoHeadingIDType: github renderer: hardWraps: false unsafe: false xhtml: false ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:6:1","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"Highlight代码高亮 hugo默认的配置如下： markup: highlight: anchorLineNos: false codeFences: true guessSyntax: false hl_Lines: \"\" lineAnchors: \"\" lineNoStart: 1 lineNos: false lineNumbersInTable: true noClasses: true style: monokai tabWidth: 4 guessSyntax：自动推断代码属于某种语言。 hl_Lines：仅在使用goldmark解析器时该属性才起效，表示对某几行代码进行高亮处理，比如： lineAnchors: \"2\"表示第二行代码高亮； lineAnchors: \"1-8\"表示第一到八行代码高亮； lineAnchors: \"1 3\"表示第一行和第三行代码高亮。 lineNoStart：表示行数从多少开始计数。 lineNos：配置行数，false表示不显示行数。 lineNumbersInTable：值为true时可以在显示行数时提供友好的代码块复制黏贴功能。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:6:2","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"Table Of Contents文章目录 配置如下： markup: tableOfContents: endLevel: 3 ordered: false startLevel: 2 startLevel：从几级标题开始生成目录，值为2表示从h2开始生成目录。 endLevel：到几级标题为止生成目录，值为3表示大于h3的标题就不再生成目录。 ordered：是否生成排序目录，建议启用该功能，生成的目录会更为美观。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:6:3","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"补充一个完整的toml格式的markup配置 上面分别给出了yaml格式的3种配置，下面是对应toml格式的完整配置： [markup] defaultMarkdownHandler = \"goldmark\" [markup.asciidocExt] backend = \"html5\" extensions = [] failureLevel = \"fatal\" noHeaderOrFooter = true safeMode = \"unsafe\" sectionNumbers = false trace = false verbose = false workingFolderCurrent = false [markup.asciidocExt.attributes] [markup.blackFriday] angledQuotes = false footnoteAnchorPrefix = \"\" footnoteReturnLinkContents = \"\" fractions = true hrefTargetBlank = false latexDashes = true nofollowLinks = false noreferrerLinks = false plainIDAnchors = true skipHTML = false smartDashes = true smartypants = true smartypantsQuotesNBSP = false taskLists = true [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.parser] attribute = true autoHeadingID = true autoHeadingIDType = \"github\" [markup.goldmark.renderer] hardWraps = false unsafe = false xhtml = false [markup.highlight] anchorLineNos = false codeFences = true guessSyntax = false hl_Lines = \"\" lineAnchors = \"\" lineNoStart = 1 lineNos = false lineNumbersInTable = true noClasses = true style = \"monokai\" tabWidth = 4 [markup.tableOfContents] endLevel = 3 ordered = false startLevel = 2 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:6:4","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"menu菜单属性 侧边栏菜单是在配置文件里配置的，如下： [menu] [[menu.main]] identifier = \"about\" name = \"\u003ci class='fa fa-heart'\u003e\u003c/i\u003eabout hugo\" url = \"/about/\" weight = -110 [[menu.main]] identifier = \"start\" name = \"getting started\" post = \"\u003cspan class='alert'\u003eNew!\u003c/span\u003e\" pre = \"\u003ci class='fa fa-road'\u003e\u003c/i\u003e\" url = \"/getting-started/\" weight = -100 identifier的值不能重复。 weight是比重，值越小则该菜单的位置越靠上面。 name是菜单名字。 pre和post分别对应当前菜单的前缀和后缀，可以定义fontawesome等图标。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:7:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"languages语言属性 该属性可以提高站点的国际化功能，即区分多语言版本的站点，比如若设定了en、zh两个语言，设定默认语言是zh；则默认的站点url的根目录后会加上/zh/，并可以通过站点首页的切换语言下拉框来切换到其他语音，如：/en/。 languages一般用来跟上面的menu一起配合使用，如下： [Languages] [Languages.en] title = \"Yulin Lewis' Blog\" weight = 1 languageName = \"English\" [[Languages.en.menu.main]] name = \"\u003ci class='fab fa-fw fa-github'\u003e\u003c/i\u003e GitHub\" identifier = \"github\" url = \"https://github.com/lewky\" weight = 1 [Languages.zh] title = \"雨临Lewis的博客\" weight = 2 languageName = \"简体中文\" [[Languages.zh.menu.main]] name = \"\u003ci class='fab fa-fw fa-github'\u003e\u003c/i\u003e GitHub\" identifier = \"github\" url = \"https://github.com/lewky\" weight = 1 此外，也可以将languages和params搭配使用，用法和上面类似，其实就是在这些属性的前面加上languages前缀而已。但是不知道为什么，在本文背景里提及的hugo和LoveIt版本下，站点无法正常读取到多语言参数，比如[languages.zh-cn.params]这种属性会读取不了。 ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:8:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"minify压缩属性 该属性用于压缩站点的各种静态资源，比如html、css、json、xml等，官方的默认配置如下： [minify] disableCSS = false disableHTML = false disableJS = false disableJSON = false disableSVG = false disableXML = false minifyOutput = false [minify.tdewolff] [minify.tdewolff.css] decimals = -1 keepCSS2 = true [minify.tdewolff.html] keepConditionalComments = true keepDefaultAttrVals = true keepDocumentTags = true keepEndTags = true keepQuotes = false keepWhitespace = false [minify.tdewolff.js] [minify.tdewolff.json] [minify.tdewolff.svg] decimals = -1 [minify.tdewolff.xml] keepWhitespace = false 但实际上在配置文件中加入上述的配置并没有效果，也无法进行修改，这可能是个bug，因为和启用压缩的命令参数冲突了。不过从上面的配置可以看出，hugo自带的压缩功能是默认会压缩CSS、HTML、JS、JSON、SVG、XML；并且在压缩HTML的时候会保留注释、属性、文档标签和闭合标签，但是会去掉引号和空格。 如果想启用压缩功能，可以运行如下命令（记得运行前要先删掉public目录）： hugo --minify 也可以直接把这个参数配置到配置文件中，这样就可以不在运行命令时指定压缩参数： minify = true ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:9:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"参考链接 Configure Hugo Syntax Highlighting Menus Multilingual Mode ","date":"2020-10-10","objectID":"/posts/hugo-3.html/:10:0","tags":["Hugo","个性化配置"],"title":"Hugo系列(3) - 通过配置文件来定制个人站点","uri":"/posts/hugo-3.html/"},{"categories":["Hugo系列"],"content":"背景 使用Hexo搭建个人博客也有两年多时间了，当文章数量达到上百篇之后，开始发现Hexo生成文章的效率越来越慢，直到每次生成都需要至少五分钟的时间。我发现生成效率和文章涉及到的分类和标签有很大关系，由于文章数量多，每篇文章又都关联了若干个分类和标签，再加上我使用了压缩样式的插件，最终导致极其低下的生成效率。 在经过一段时间的考量后，决定将Hexo博客迁移到Hugo。Hugo是用go语言开发的，在用法上和Hexo类似，可以简单地把Hugo当成go语言版的Hexo，但是它拥有更快的生成效率。下面是官网的原话： The world’s fastest framework for building websites Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:1:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"安装 和Hexo不同，Hugo安装非常简单，只需要去Hugo Release下载操作系统对应的二进制文件即可（hugo或者hugo.exe)。 对于Windows平台，一般是一个zip文件，解压后里面有个hugo.exe文件。将该文件所在目录添加到环境变量path里，即可在cmd里通过hugo version检测是否能正常运行hugo命令。 如下是我安装的hugo版本： \u003ehugo version Hugo Static Site Generator v0.74.2-48565DE6 windows/amd64 BuildDate: 2020-07-17T17:22:50Z 其他平台的安装方法可以参考官方文档：Install Hugo ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:2:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"创建站点 首先需要创建一个新的个人站点： hugo new site blog blog就是你的博客站点所在的目录，也是这个站点的根目录，创建站点后目录结构如下： archetypes/ content/ data/ layouts/ static/ themes/ config.toml 下面简单介绍下Hugo根目录下的各个文件目录的作用： archetypes存放创建文件时使用的模板，可以自定义front matter属性。 assets存放需要被Hugo Pipes处理的文件，且只有使用了.Permalink或者.RelPermalink的文件才能被发布到public目录。 注意，默认不会创建assets目录。 config是配置文件，可以有JSON、 YAML或者TOML三种格式，默认使用根目录下的config.toml、config.yaml或config.json中的某一个。可以通过--config来配置读取一个或多个配置文件，如：hugo --config a.toml,b.toml,c.toml。 注意，默认不会创建config目录。 content存放的各种md文件用于部署站点，该目录下可以自行创建若干个子目录来便于对文章进行分类，这些子目录被称为section。 data目录存放的是用于定义变量的模板文件，相当于Java里的常量类，这些文件有JSON、 YAML或者TOML三种格式，会在生成站点时被使用到。一般用不到该功能，具体用法可以参考：data templates layouts目录存放的模板文件用于渲染html页面，模板里可以定义不同页面的html代码。 static目录存放的是静态内容：图片、CSS、JavaScript等。 resources目录用于缓存某些文件来提高生成效率。 注意，默认不会创建resources目录。 ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:3:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"添加主题 为新站点添加一个主题，以我使用的LoveIt主题为例，先将主题代码放置到themes目录下： cd blog git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 接着修改config.toml： theme = \"LoveIt\" 这里的LoveIt对应themes目录下的主题的文件夹名字。 ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:4:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"新建文章 新建一篇文章： hugo new posts/first.md 该命令会在content/posts目录下生成first.md文件，打开进行编辑： --- title: \"First\" date: 2020-09-08T21:57:28+08:00 draft: true --- ## First First blog. 两行---里的属性是front matter，用来设置当前文章的属性配置。front matter的内容可以使用3种不同的格式来定义，两行---之间对应的是YAML格式，两行+++之间对应的是TOML格式，{和}之间对应的是JSON格式。 建议用YAML格式来定义，这样从Hexo迁移到Hugo的成本会更低。 下面是官方文档提供的3种不同格式的front matter的样例，有兴趣的可以了解下。 ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:5:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"TOML Example +++ title = \"spf13-vim 3.0 release and new website\" description = \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\" tags = [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ] date = \"2012-04-06\" categories = [ \"Development\", \"VIM\" ] slug = \"spf13-vim-3-0-release-and-new-website\" +++ Content of the file goes Here ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:5:1","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"YAML Example --- title: \"spf13-vim 3.0 release and new website\" description: \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\" tags: [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ] lastmod: 2015-12-23 date: \"2012-04-06\" categories: - \"Development\" - \"VIM\" slug: \"spf13-vim-3-0-release-and-new-website\" --- Content of the file goes Here ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:5:2","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"JSON Example { \"title\": \"spf13-vim 3.0 release and new website\", \"description\": \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\", \"tags\": [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ], \"date\": \"2012-04-06\", \"categories\": [ \"Development\", \"VIM\" ], \"slug\": \"spf13-vim-3-0-release-and-new-website\", } Content of the file goes Here ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:5:3","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"启动Hugo服务 输入命令： hugo server -D 在本地启动服务后可以在 http://localhost:1313/ 访问个人站点。该命令仅用于本地调试，支持热修改，也就是说在启动服务时修改文章会实时生效，但是该命令不会真正生成静态文件。 ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:6:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"生成静态页面 输入命令： hugo -D 默认会在站点根目录的public/目录下生成对应的静态页面，可以通过在命令行指定-d或者--destination参数来改变静态页面的存放路径，也可以通过在配置文件中设置publishDir来指定。 该命令生成的静态页面文件是用来部署到pages服务的，比如GitHub pages或者Coding pages等。 另外，hugo允许对生成的静态页面设置特殊的参数，比如在文章的front matter里设置参数：draft, publishdate和expirydate。如下： --- title: \"First\" date: 2020-09-08T21:57:28+08:00 draft: true publishdate: 2020-09-18T21:57:28+08:00 expirydate: 2020-09-28T21:57:28+08:00 --- draft: true表明该文章是草稿，如果在启用服务时不指定参数-D或--buildDrafts，或者在配置文件config.toml中配置buildDrafts = true，则会在生成文章时忽略草稿。如果不想指定该参数就生成文章，需要改为draft: false或者将其删去。 publishdate: 2020-09-18T21:57:28+08:00表示将来发布的时间，如果不指定参数-F或--buildFuture，或者在配置文件config.toml中配置buildFuture = true，则无法在规定的日期之前生成该文章。 expirydate: 2020-09-28T21:57:28+08:00表示过期时间，如果不指定参数-E或--buildExpired，或者在配置文件config.toml中配置buildExpired = true，则无法在规定的日期之后生成该文章。 ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:7:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["Hugo系列"],"content":"参考链接 Hugo Front Matter Hugo Quick Start Install Hugo Directory Structure Explained ","date":"2020-09-06","objectID":"/posts/hugo-1.html/:8:0","tags":["Hugo","简单入门"],"title":"Hugo系列(1) - 简单入门与搭建","uri":"/posts/hugo-1.html/"},{"categories":["SpringBoot"],"content":"问题与分析 某日忽然发现在用postman测试数据时报错如下： com.fasterxml.jackson.databind.JsonMappingException: could not initialize proxy [com.cbxsoftware.cbx.attachment.entity.RefAttachment#c109ec36e60c4a89a10eabc72416d984] - no Session (through reference chain: com.cbxsoftware.cbx.sampletracker.elasticsearch.entity.SampleTrackerDetailEstc[\"sampleTracker\"]-\u003ecom.cbxsoftware.cbx.sampletracker.elasticsearch.entity.SampleTrackerEstc[\"sampleTracker\"]-\u003ecom.cbxsoftware.cbx.sampletracker.entity.SampleTracker[\"item\"]-\u003ecom.cbxsoftware.cbx.item.entity.RefItem[\"image\"]-\u003ecom.cbxsoftware.cbx.image.entity.RefImage[\"propFormat\"]-\u003ecom.cbxsoftware.cbx.attachment.entity.RefAttachment$HibernateProxy$uNA5RwMT[\"revision\"]) at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:394) at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:353) at com.fasterxml.jackson.databind.ser.std.StdSerializer.wrapAndThrow(StdSerializer.java:316) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:727) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer.serialize(UnwrappingBeanSerializer.java:120) at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter.serializeAsField(UnwrappingBeanPropertyWriter.java:127) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319) at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3905) at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3219) ... Caused by: org.hibernate.LazyInitializationException: could not initialize proxy [com.cbxsoftware.cbx.attachment.entity.RefAttachment#c109ec36e60c4a89a10eabc72416d984] - no Session at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:169) at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:309) at org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45) at org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95) at com.cbxsoftware.cbx.attachment.entity.RefAttachment$HibernateProxy$uNA5RwMT.getRevision(Unknown Source) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Delegat","date":"2019-10-22","objectID":"/posts/742bbb45.html/:1:0","tags":["Java相关框架","SpringBoot","懒加载"],"title":"SpringBoot JPA懒加载异常 - JsonMappingException: could not initialize proxy","uri":"/posts/742bbb45.html/"},{"categories":["SpringBoot"],"content":"解决方法一 如果是spring继承的hibernate，根据上述的原因，可以延长session的生命周期，但是这里用的是SpringBoot的JPA，处理方法不同，需要在application.properties配置下懒加载相关的东西： spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true 进行该配置后，可以在session关闭时也能另外开启一个新的session和事务来访问db以取回懒加载对象的数据。 ","date":"2019-10-22","objectID":"/posts/742bbb45.html/:2:0","tags":["Java相关框架","SpringBoot","懒加载"],"title":"SpringBoot JPA懒加载异常 - JsonMappingException: could not initialize proxy","uri":"/posts/742bbb45.html/"},{"categories":["SpringBoot"],"content":"解决方法二 因为该懒加载异常是缺少session导致的，那么可以通过在方法前添加事务注解@Transactional的方式来解决，只要事务没有提交，session就不会关闭，自然就不会出现上述的懒加载异常。不过由于该事务注解是用Spring AOP实现的，存在着一些坑，比如类内直接调用无效或者对非public方法无效等，需要多加注意。 当使用了上述两种方法后，发现不再触发LazyInitializationException，但是却发生了另一个新的异常InvalidDefinitionException： com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.cbxsoftware.cbx.item.elasticsearch.entity.ItemEstc[\"mainEntity\"]-\u003ecom.cbxsoftware.cbx.item.entity.Item[\"image\"]-\u003ecom.cbxsoftware.cbx.image.entity.RefImage[\"propFormat\"]-\u003ecom.cbxsoftware.cbx.attachment.entity.RefAttachment$HibernateProxy$vTKSYzrN[\"hibernateLazyInitializer\"]) at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:77) at com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1191) at com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:313) at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:71) at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:33) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer.serialize(UnwrappingBeanSerializer.java:120) at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter.serializeAsField(UnwrappingBeanPropertyWriter.java:127) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:155) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319) at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3905) at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3219) ... 这个异常是由于hibernate在代理类里添加了一个属性hibernateLazyInitializer，当该对象转换成json的时候就会报错。解决方法是将该属性过滤掉，可以在对应的类名或者公共类前加上如下注解： @JsonIgnoreProperties(value = { \"hibernateLazyInitializer\" }) ","date":"2019-10-22","objectID":"/posts/742bbb45.html/:3:0","tags":["Java相关框架","SpringBoot","懒加载"],"title":"SpringBoot JPA懒加载异常 - JsonMappingException: could not initialize proxy","uri":"/posts/742bbb45.html/"},{"categories":["SpringBoot"],"content":"源码分析 因为对懒加载异常的发生有些好奇，所以看了下hibernate的源码，这里简单分析下，另外我看的是两个源码包如下： spring-orm-5.1.5.RELEASE.jar hibernate-core-5.3.7.Final.jar 首先是关于spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true的配置，前面半截是因为JPA集成了hibernate的配置，所以在hibernate中，这个配置应该是hibernate.enable_lazy_load_no_trans=true。 在hibernate的一个常量接口org.hibernate.cfg.AvailableSettings中定义了各种配置常量，其中就包括上述这个配置： String ENABLE_LAZY_LOAD_NO_TRANS = \"hibernate.enable_lazy_load_no_trans\"; 在启动项目的时候会读取配置文件，将其解析为一个HashMap\u003cK,V\u003e，这些参数在newEntityManagerFactoryBuilderImpl的时候被使用到，上面的常量会在org.hibernate.boot.internal.SessionFactoryOptionsBuilder里被拿来初始化： this.initializeLazyStateOutsideTransactions = cfgService.getSetting( ENABLE_LAZY_LOAD_NO_TRANS, BOOLEAN, false ); 因为在配置文件里配置了该变量的值为true，所以这里在初始化的时候就会把initializeLazyStateOutsideTransactions的值设置为true。该变量由一个方法来判断其值是否为true： @Override public boolean isInitializeLazyStateOutsideTransactionsEnabled() { return initializeLazyStateOutsideTransactions; } 接着在组装pojo时，会为懒加载对象创建对应的代理对象，当需要获取该代理对象除id以外的属性时，就会调用AbstractLazyInitializer#initialize()进行初始化，逻辑如下： @Override public final void initialize() throws HibernateException { if ( !initialized ) { if ( allowLoadOutsideTransaction ) { permissiveInitialization(); } else if ( session == null ) { throw new LazyInitializationException( \"could not initialize proxy [\" + entityName + \"#\" + id + \"] - no Session\" ); } else if ( !session.isOpen() ) { throw new LazyInitializationException( \"could not initialize proxy [\" + entityName + \"#\" + id + \"] - the owning Session was closed\" ); } else if ( !session.isConnected() ) { throw new LazyInitializationException( \"could not initialize proxy [\" + entityName + \"#\" + id + \"] - the owning Session is disconnected\" ); } else { target = session.immediateLoad( entityName, id ); initialized = true; checkTargetState(session); } } else { checkTargetState(session); } } 如果在配置文件中设置了spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true，那么上述的allowLoadOutsideTransaction变量值就为true，则可以进入permissiveInitialization()方法另起session和事务，最终避免懒加载异常LazyInitializationException。如果没有配置该参数，那么就会由于session已关闭（即为null）而抛出LazyInitializationException。 ","date":"2019-10-22","objectID":"/posts/742bbb45.html/:4:0","tags":["Java相关框架","SpringBoot","懒加载"],"title":"SpringBoot JPA懒加载异常 - JsonMappingException: could not initialize proxy","uri":"/posts/742bbb45.html/"},{"categories":["SpringBoot"],"content":"参考链接 springboot jpa 解决延迟加载问题 No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor springboot集成jpa返回Json报错 com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Hibernate和Spring整合出现懒加载异常：org.hibernate.LazyInitializationException: could not initialize proxy - no Session ","date":"2019-10-22","objectID":"/posts/742bbb45.html/:5:0","tags":["Java相关框架","SpringBoot","懒加载"],"title":"SpringBoot JPA懒加载异常 - JsonMappingException: could not initialize proxy","uri":"/posts/742bbb45.html/"},{"categories":["Spring"],"content":"问题与分析 在本地开发项目时发现报错如下： org.springframework.expression.spel.SpelEvaluationException: EL1030E: The operator 'ADD' is not supported between objects of type 'java.lang.String' and 'null' at org.springframework.expression.spel.ExpressionState.operate(ExpressionState.java:240) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:80) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:85) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) at org.springframework.expression.spel.standard.SpelExpression.getValue .... at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 从堆栈信息可以看出，该异常与spel有关。spel指的是Spring Expression Language，结合问题代码进行分析，可以认为该异常与spring表达式有关。而在我的代码里，只有@Cacheable注解里使用到了spel，如下： @Cacheable(key = \"#root.target.getCacheKeyPrefix() + '::' + + #root.target.getRootDomain() + '-' + #root.target.getLocale() + '-' + #searchLabelKey\") public String getFromRootDomain(final String labelId, final String locale, final String searchLabelKey) { // TODO return null; } 很显然，在使用到该注解时，由于这里的spring表达式有问题，最终在解析时抛出了异常。经过检查发现，这里犯了个很逗的错误，就是连续使用了两个+，导致解析无法通过，改正后如下： @Cacheable(key = \"#root.target.getCacheKeyPrefix() + '::' + #root.target.getRootDomain() + '-' + #root.target.getLocale() + '-' + #searchLabelKey\") 而之所以之前没能发现这个问题，是因为没有启用redis cache，导致避开了这个问题。目前刚开始了解spel这门表达式语言，在此记录下这个问题，方便日后回顾分析，下面顺便贴上官方的一篇中译文档。 ","date":"2019-09-16","objectID":"/posts/1ee001e8.html/:1:0","tags":["Java相关框架","Spring"],"title":"Spring异常 - SpelEvaluationException: EL1030E","uri":"/posts/1ee001e8.html/"},{"categories":["Spring"],"content":"参考链接 8. Spring 表达式语言 (SpEL) ","date":"2019-09-16","objectID":"/posts/1ee001e8.html/:2:0","tags":["Java相关框架","Spring"],"title":"Spring异常 - SpelEvaluationException: EL1030E","uri":"/posts/1ee001e8.html/"},{"categories":["日志框架"],"content":"为什么要使用isDebugEnabled() 之前在系统的代码中发现有时候会在打印日志的时候先进行一次判断，如下： if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Search parameters: \" + searchParams); } 我们使用的是Log4j2框架，框架自身提供了类似的许多api，比如isErrorEnabled()，isInfoEnabled()等，每个Level对有对应的一个判断Level是否启用的api，实际上这些api都是调用的另一个api：isEnabled。 在打印日志之前先进行Level的判断，是因为在执行打印语句时，首先会先将要打印的字符串信息作为参数传递给被调用的方法。如下代码： LOGGER.debug(\"Search parameters: \" + searchParams); 首先会执行字符串拼接的操作，会涉及到对象的toString()方法以及StringBuilder的创建，接着把拼接后的字符串传递给debug语句，这时候才会去判断打印日志的级别，来决定是否将这个字符串输入到对应的日志文件里。假如最终该语句并不会把字符串打印出来，那么这个拼接字符串的过程就属于毫无意义的操作，会增加系统性能的损耗。 因此，在一些必要的地方，我们会先进行一次日志Level的判断，来避免不必要的性能损耗。 ","date":"2019-08-10","objectID":"/posts/8b26a454.html/:1:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2 - 日志框架中isDebugEnabled()的作用","uri":"/posts/8b26a454.html/"},{"categories":["日志框架"],"content":"使用{}占位符来打印日志 Log4j在升级到Log4j2后提供了新的打印日志的方式：允许使用{}占位符来打印日志，如下： LOGGER.debug(\"Search parameters: {}\", searchParams); 通过占位符来打印日志有个好处，那就是不需要自己去预先判断日志的级别，其底层已经帮我们去实现这个步骤了。此外，使用占位符来打印日志，对于需要拼接大量变量的场景时，该方式也会更加地直观与优雅。如下： LOGGER.debug(\"Current item id is {}, size is {}, color is {}, pattern is {}.\", id, size, color, pattern); 注意：在Log4j2中，这种占位符打印的方式，最多只能支持到9个变量参数。 除了Log4j2，其它的日志框架同样支持占位符的写法，比如logback等。 ","date":"2019-08-10","objectID":"/posts/8b26a454.html/:2:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2 - 日志框架中isDebugEnabled()的作用","uri":"/posts/8b26a454.html/"},{"categories":["日志框架"],"content":"使用{}占位符可能产生的问题 虽然使用占位符来打印日志很方便，但是却有可能引发堆栈溢出的问题，有兴趣的话可以通过这篇文章来了解下。 ","date":"2019-08-10","objectID":"/posts/8b26a454.html/:3:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2 - 日志框架中isDebugEnabled()的作用","uri":"/posts/8b26a454.html/"},{"categories":["日志框架"],"content":"参考链接 Java日志框架中真的需要判断log.isDebugEnabled()吗？ ","date":"2019-08-10","objectID":"/posts/8b26a454.html/:4:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2 - 日志框架中isDebugEnabled()的作用","uri":"/posts/8b26a454.html/"},{"categories":["ELK"],"content":"问题与分析 在本地测试无误后将ELK部署到了测试环境，结果第二天发现Logstash挂掉了，一开始以为是自动部署之类导致的问题。之后几天时间里Logstash总是会down掉，查看了下日志文件，发现报错如下： [2019-06-28T07:56:13,148][FATAL][logstash.runner ] An unexpected error occurred! { : error=\u003e#\u003cErrno: : EPIPE: Brokenpipe-\u003cSTDOUT\u003e\u003e, : backtrace=\u003e[\"org/jruby/RubyIO.java:1457:in `write'\", \"org/jruby/RubyIO.java:1428:in `write'\", \"/home/cbx6/software/logstash-6.6.1/vendor/bundle/jruby/2.3.0/gems/logstash-output-stdout-3.1.4/lib/logstash/outputs/stdout.rb:43:in `block in multi_receive_encoded'\", \"org/jruby/RubyArray.java:1734:in `each'\", \"/home/cbx6/software/logstash-6.6.1/vendor/bundle/jruby/2.3.0/gems/logstash-output-stdout-3.1.4/lib/logstash/outputs/stdout.rb:42:in `multi_receive_encoded'\", \"/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/outputs/base.rb:87:in `multi_receive'\", \"org/logstash/config/ir/compiler/OutputStrategyExt.java:114:in `multi_receive'\", \"org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java:97:in `multi_receive'\", \"/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:390:in `block in output_batch'\", \"org/jruby/RubyHash.java:1343:in `each'\", \"/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:389:in `output_batch'\", \"/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:341:in `worker_loop'\", \"/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:304:in `block in start_workers'\"] } 从堆栈信息里可以看到关键字眼：block in multi_receive_encoded，block in output_batch；另外，还可以发现这些错误信息都是由logstash-output-stdout-3.1.4这个插件引发的。 简单分析来看，应该是由于测试环境下同一时间内太多message要经由logstash-output-stdout输出到控制台造成的某种未知的并发问题。下面是对应的Logstash的output的配置： output { stdout { codec =\u003e rubydebug } elasticsearch { hosts =\u003e [\"{{ cbx_logstash_es_server }}\"] index =\u003e \"%{indexName}\" action =\u003e \"index\" } } 根据配置，并结合堆栈信息来分析，可以认为是Logstash的stdout插件在高并发状态下使用rubydebug进行编解码时抛出了异常。 其实这里的stdout插件是不必要的，之前只是在本地测试使用到的。而在测试环境下，并发量远非本地测试能比，此外将大量的message输出到console上也会对性能产生影响。可以说，这种配置等同于在Java代码中频繁使用System.out.print()语句来输出信息，并不推荐这种做法。 ","date":"2019-08-08","objectID":"/posts/4d3f2358.html/:1:0","tags":["Java相关框架","ELK系列","Logstash"],"title":"ELK系列(7) - 测试环境下Logstash异常退出：block in multi_receive_encoded","uri":"/posts/4d3f2358.html/"},{"categories":["ELK"],"content":"解决方案 将配置文件里的stdout插件去掉，最终output的配置如下： output { elasticsearch { hosts =\u003e [\"{{ cbx_logstash_es_server }}\"] index =\u003e \"%{indexName}\" action =\u003e \"index\" } } 将stdout插件的配置去除后，在之后的一段时间里，测试环境的Logstash不再发生异常退出，证实该issue确实是由stdout的codec所引发的。注意，不要在正式环境使用该插件来输出信息到控制台，有可能会引发类似的并发异常问题或者性能问题。 ","date":"2019-08-08","objectID":"/posts/4d3f2358.html/:2:0","tags":["Java相关框架","ELK系列","Logstash"],"title":"ELK系列(7) - 测试环境下Logstash异常退出：block in multi_receive_encoded","uri":"/posts/4d3f2358.html/"},{"categories":["Hexo瞎折腾系列"],"content":"前言 本系列的所有修改均基于本系列第一篇中的新增文件(譬如custom.js)，请先自行阅读Hexo瞎折腾系列(1) - 准备工作与简单美化；并按照文章所说自行修改代码或文件。 ","date":"2019-05-26","objectID":"/posts/bdceb0a1.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(9) - 网页标题崩溃特效","uri":"/posts/bdceb0a1.html/"},{"categories":["Hexo瞎折腾系列"],"content":"为网页添加标题崩溃特效 该特效为：当用户离开站点相关的页面时，网页的标题会变成“已崩溃”，网站图标也会改变；当用户重新回到站点页面时才会恢复正常。 实现方式如下： 请在themes/next/source/js/src/custom.js里加入如下代码： /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function() { if(document.hidden) { $('[rel=\"icon\"]').attr('href', \"/failure.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/failure.ico\"); document.title = '喔唷，崩溃啦！'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon-32x32.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/favicon-32x32.ico\"); document.title = '咦，页面又好了！'; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 然后在站点根目录的/source目录下添加failure.ico，作为网站崩溃时显示的图标；如下： failure.ico \" failure.ico 这里的favicon-32x32.ico是你个人站点的图标，改成你自己的图标就好。 ","date":"2019-05-26","objectID":"/posts/bdceb0a1.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(9) - 网页标题崩溃特效","uri":"/posts/bdceb0a1.html/"},{"categories":["ELK"],"content":"问题 有时候我们想要在Logstash里对收集到的日志等信息进行分割，并且将分割后的字符作为新的字符来index到Elasticsearch里。假定需求如下： Logstash收集到的日志字段message的值是由多个字段拼接而成的，分隔符是;,;，如下： { \"message\": \"key_1=value_1;,;key_2=value_2\" } 现在想要将message的值拆分成2个新的字段：key_1、key_2，并且将它们index到ES里，可以借助Logstash的filter的插件来完成；这里提供两种解决方案。 ","date":"2019-05-12","objectID":"/posts/b37842a8.html/:1:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash"],"title":"ELK系列(5) - Logstash怎么分割字符串并添加新的字段到Elasticsearch","uri":"/posts/b37842a8.html/"},{"categories":["ELK"],"content":"方案一：使用mutate插件 filter { mutate { split =\u003e [\"message\",\";,;\"] } if [message][0] { mutate { add_field =\u003e { \"temp1\" =\u003e \"%{[message][0]}\" } } } if [message][1] { mutate { add_field =\u003e { \"temp2\" =\u003e \"%{[message][1]}\" } } } if [temp1][1] { mutate { split =\u003e [\"temp1\",\"=\"] add_field =\u003e { \"%{[temp1][0]}\" =\u003e \"%{[temp1][1]}\" } } } if [temp2][1] { mutate { split =\u003e [\"temp2\",\"=\"] add_field =\u003e { \"%{[temp2][0]}\" =\u003e \"%{[temp2][1]}\" } remove_field =\u003e [ \"temp1\", \"temp2\", \"message\" ] } } } 看得出来，这种做法很麻烦，也不利于日后的维护。每当message里被拼接的字段的数量增加时，就必须同步改动这里的filter逻辑，而且添加的代码量也是呈线性递增的。 此外，这里使用的诸如temp1等临时变量，可以用[@metadata][temp1]的写法来作为临时变量，这样就不需要去手动remove掉了。 ","date":"2019-05-12","objectID":"/posts/b37842a8.html/:2:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash"],"title":"ELK系列(5) - Logstash怎么分割字符串并添加新的字段到Elasticsearch","uri":"/posts/b37842a8.html/"},{"categories":["ELK"],"content":"方案二：使用ruby插件 filter { ruby { code =\u003e \" array1 = event.get('message').split(';,;') array1.each do |temp1| if temp1.nil? then next end array2 = temp1.split('=') key = array2[0] value = array2[1] if key.nil? then next end event.set(key, value) end \" remove_field =\u003e [ \"message\" ] } } ruby插件可以允许你使用ruby的语法来完成各种复杂的逻辑，使用这种方案可以完美解决方案一中的不足之处，便于日后的维护。 ","date":"2019-05-12","objectID":"/posts/b37842a8.html/:3:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash"],"title":"ELK系列(5) - Logstash怎么分割字符串并添加新的字段到Elasticsearch","uri":"/posts/b37842a8.html/"},{"categories":["ELK"],"content":"参考链接 Logstash事件字段遍历 Logstash详解之——filter模块 logstash filter如何判断字段是够为空或者null ","date":"2019-05-12","objectID":"/posts/b37842a8.html/:4:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash"],"title":"ELK系列(5) - Logstash怎么分割字符串并添加新的字段到Elasticsearch","uri":"/posts/b37842a8.html/"},{"categories":["ELK"],"content":"问题与分析 在使用Elasticsearch进行index数据时，发现报错如下： java.lang.IllegalArgumentException: cannot write xcontent for unknown value of type class java.math.BigDecimal at org.elasticsearch.common.xcontent.XContentBuilder.unknownValue(XContentBuilder.java:755) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:726) at org.elasticsearch.common.xcontent.XContentBuilder.field(XContentBuilder.java:711) at org.elasticsearch.index.query.BaseTermQueryBuilder.doXContent(BaseTermQueryBuilder.java:154) at org.elasticsearch.index.query.AbstractQueryBuilder.toXContent(AbstractQueryBuilder.java:82) at org.elasticsearch.index.query.BoolQueryBuilder.doXArrayContent(BoolQueryBuilder.java:275) at org.elasticsearch.index.query.BoolQueryBuilder.doXContent(BoolQueryBuilder.java:256) at org.elasticsearch.index.query.AbstractQueryBuilder.toXContent(AbstractQueryBuilder.java:82) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:779) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:772) at org.elasticsearch.common.xcontent.XContentBuilder.field(XContentBuilder.java:764) at org.elasticsearch.search.builder.SearchSourceBuilder.toXContent(SearchSourceBuilder.java:1184) at org.elasticsearch.common.xcontent.XContentHelper.toXContent(XContentHelper.java:349) at org.elasticsearch.search.builder.SearchSourceBuilder.toString(SearchSourceBuilder.java:1558) at org.elasticsearch.search.builder.SearchSourceBuilder.toString(SearchSourceBuilder.java:1553) at java.lang.String.valueOf(String.java:2994) at java.lang.StringBuilder.append(StringBuilder.java:131) at org.elasticsearch.action.search.SearchRequest.toString(SearchRequest.java:516) 从异常信息看，显然ES无法接受BigDecimal类型，经过百度，也确实如此。在一篇博文评论中解释如下： 应该是客户端代码里将查询的数值定义成了java.math.BigDecimal，而ES不支持这个类型。之所以2.2没有问题，是因为之前的transport client发送数据之前将其序列化成了json，而在5.x以后，使用的内部的transport protocol，数据类型如果不匹配会抛错误。 所以数据类型的定义上，需要使用ES支持的类型。 ","date":"2019-05-12","objectID":"/posts/7784288c.html/:1:0","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(4) - Elasticsearch cannot write xcontent for unknown value of type class java.math.BigDecimal","uri":"/posts/7784288c.html/"},{"categories":["ELK"],"content":"解决方案 ","date":"2019-05-12","objectID":"/posts/7784288c.html/:2:0","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(4) - Elasticsearch cannot write xcontent for unknown value of type class java.math.BigDecimal","uri":"/posts/7784288c.html/"},{"categories":["ELK"],"content":"方案一：转变成其他ES支持的数据类型 我使用的是6.4.2版本的Elasticsearch，该版本尚不支持BigDecimal或者BigInteger的数据类型，所以在index到Elasticsearch之前，需要转换成其他数据类型，这里要注意不要数据溢出了: BigDecimal要转变成Double类型 BigInteger要转变成Long类型 ","date":"2019-05-12","objectID":"/posts/7784288c.html/:2:1","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(4) - Elasticsearch cannot write xcontent for unknown value of type class java.math.BigDecimal","uri":"/posts/7784288c.html/"},{"categories":["ELK"],"content":"方案二：使用更高版本的ES 我在看6.7.1版本的Elasticsearch源码时发现已经可以支持BigDecimal或者BigInteger的数据类型了，所以直接使用该版本或更高版本的就行了。 下面附上两个版本的支持的数据类型的源码： 6.4.2版本的Elasticsearch相关源码 Map\u003cClass\u003c?\u003e, Writer\u003e writers = new HashMap\u003c\u003e(); writers.put(Boolean.class, (b, v) -\u003e b.value((Boolean) v)); writers.put(Byte.class, (b, v) -\u003e b.value((Byte) v)); writers.put(byte[].class, (b, v) -\u003e b.value((byte[]) v)); writers.put(Date.class, XContentBuilder::timeValue); writers.put(Double.class, (b, v) -\u003e b.value((Double) v)); writers.put(double[].class, (b, v) -\u003e b.values((double[]) v)); writers.put(Float.class, (b, v) -\u003e b.value((Float) v)); writers.put(float[].class, (b, v) -\u003e b.values((float[]) v)); writers.put(Integer.class, (b, v) -\u003e b.value((Integer) v)); writers.put(int[].class, (b, v) -\u003e b.values((int[]) v)); writers.put(Long.class, (b, v) -\u003e b.value((Long) v)); writers.put(long[].class, (b, v) -\u003e b.values((long[]) v)); writers.put(Short.class, (b, v) -\u003e b.value((Short) v)); writers.put(short[].class, (b, v) -\u003e b.values((short[]) v)); writers.put(String.class, (b, v) -\u003e b.value((String) v)); writers.put(String[].class, (b, v) -\u003e b.values((String[]) v)); writers.put(Locale.class, (b, v) -\u003e b.value(v.toString())); writers.put(Class.class, (b, v) -\u003e b.value(v.toString())); writers.put(ZonedDateTime.class, (b, v) -\u003e b.value(v.toString())); writers.put(Calendar.class, XContentBuilder::timeValue); writers.put(GregorianCalendar.class, XContentBuilder::timeValue); 6.7.1版本的Elasticsearch相关源码 Map\u003cClass\u003c?\u003e, Writer\u003e writers = new HashMap\u003c\u003e(); writers.put(Boolean.class, (b, v) -\u003e b.value((Boolean) v)); writers.put(Byte.class, (b, v) -\u003e b.value((Byte) v)); writers.put(byte[].class, (b, v) -\u003e b.value((byte[]) v)); writers.put(Date.class, XContentBuilder::timeValue); writers.put(Double.class, (b, v) -\u003e b.value((Double) v)); writers.put(double[].class, (b, v) -\u003e b.values((double[]) v)); writers.put(Float.class, (b, v) -\u003e b.value((Float) v)); writers.put(float[].class, (b, v) -\u003e b.values((float[]) v)); writers.put(Integer.class, (b, v) -\u003e b.value((Integer) v)); writers.put(int[].class, (b, v) -\u003e b.values((int[]) v)); writers.put(Long.class, (b, v) -\u003e b.value((Long) v)); writers.put(long[].class, (b, v) -\u003e b.values((long[]) v)); writers.put(Short.class, (b, v) -\u003e b.value((Short) v)); writers.put(short[].class, (b, v) -\u003e b.values((short[]) v)); writers.put(String.class, (b, v) -\u003e b.value((String) v)); writers.put(String[].class, (b, v) -\u003e b.values((String[]) v)); writers.put(Locale.class, (b, v) -\u003e b.value(v.toString())); writers.put(Class.class, (b, v) -\u003e b.value(v.toString())); writers.put(ZonedDateTime.class, (b, v) -\u003e b.value(v.toString())); writers.put(Calendar.class, XContentBuilder::timeValue); writers.put(GregorianCalendar.class, XContentBuilder::timeValue); writers.put(BigInteger.class, (b, v) -\u003e b.value((BigInteger) v)); writers.put(BigDecimal.class, (b, v) -\u003e b.value((BigDecimal) v)); 可以发现，在6.7.1版本的源码里，多出了最后的两种数据类型的支持：BigInteger和BigDecimal。 ","date":"2019-05-12","objectID":"/posts/7784288c.html/:2:2","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(4) - Elasticsearch cannot write xcontent for unknown value of type class java.math.BigDecimal","uri":"/posts/7784288c.html/"},{"categories":["ELK"],"content":"参考链接 elastic search 5.4.版本，java api 调用出现：can not write type [class java.math.BigDecimal] ","date":"2019-05-12","objectID":"/posts/7784288c.html/:3:0","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(4) - Elasticsearch cannot write xcontent for unknown value of type class java.math.BigDecimal","uri":"/posts/7784288c.html/"},{"categories":["ELK"],"content":"方法 Elasticsearch默认会配置1G的JVM堆的初始值和最大值，该jvm参数被配置在/config/jvm.options里： -Xms1g -Xmx1g 如果只是个人开发小项目，可以把参数改小些，比如： -Xms512m -Xmx512m 这个jvm.options用来配置各种jvm参数，比如GC、GC logging、heap dumps等。 ","date":"2019-05-12","objectID":"/posts/7a146e10.html/:1:0","tags":["Java相关框架","ELK系列","Elasticsearch"],"title":"ELK系列(3) - Elasticsearch修改jvm参数","uri":"/posts/7a146e10.html/"},{"categories":["ELK"],"content":"问题 Kibana在创建Index Patterns的时候，可以选择某个date类型的field作为排序字段。之后在Discover里打开对应的index，会发现这个date类型的field的格式显示如下： April 10th 2019, 17:40:32.359 这是Kibana默认的日期格式，有两种修改的方式。 ","date":"2019-05-12","objectID":"/posts/c85bbf4e.html/:1:0","tags":["Java相关框架","ELK系列","Kibana"],"title":"ELK系列(2) - Kibana怎么修改日期格式Date format","uri":"/posts/c85bbf4e.html/"},{"categories":["ELK"],"content":"方式一：全局修改 登录http://localhost:5601/，会进入Kibana的页面，选择Management -\u003e Index Patterns -\u003e Advanced Settings，找到Date format，如何修改这里的值，默认是MMMM Do YYYY, HH:mm:ss.SSS。 可以改成YYYY-MM-DD HH:mm:ss.SSS，这样页面的所有日期就会显示成2019-04-23 16:30:39.139这种格式了。 ","date":"2019-05-12","objectID":"/posts/c85bbf4e.html/:2:0","tags":["Java相关框架","ELK系列","Kibana"],"title":"ELK系列(2) - Kibana怎么修改日期格式Date format","uri":"/posts/c85bbf4e.html/"},{"categories":["ELK"],"content":"方式二：局部修改 可以只针对某个时间字段进行修改，这样就不会影响到其它的时间字段，允许不同字段用不同的日期格式。 登录http://localhost:5601/，会进入Kibana的页面，选择Management -\u003e Index Patterns，选择某个已经创建好的index pattern，接着在Fields这个tab里找到对应的日期字段，点击那个字段最后的铅笔图标（Edit）进行编辑。 对于date类型的字段，其Format默认是选择了- Default -，将其改为选择Date，然后将下面的format改成YYYY-MM-DD HH:mm:ss.SSS，最后再点击下方的Save field。 ","date":"2019-05-12","objectID":"/posts/c85bbf4e.html/:3:0","tags":["Java相关框架","ELK系列","Kibana"],"title":"ELK系列(2) - Kibana怎么修改日期格式Date format","uri":"/posts/c85bbf4e.html/"},{"categories":["ELK"],"content":"前言 最近公司分了个ELK相关的任务给我，在一边学习一边工作之余，总结下这些天来的学习历程和踩坑记录。 首先介绍下使用ELK的项目背景：在项目的数据库里有个表用来存储消息队列的消费日志，这些日志用于开发者日后的维护。每当客户端生产一条消息并发送到消息队列后，就会插入一条对应的记录到数据库里。当这条消息被消费之后，又会更新数据库里对应的记录的几个column的值，比如status、updated_on这些常用的column。 由于客户每天生产消费的消息很多，导致数据库里的这个表里的数据很多，长年累月下来，会达到数以亿计。领导决定不再把这些消费日志保存到数据库，而是改为通过Log4j2 + ELK架构把这些日志保存到Elasticsearch里。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:1:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"ELK简介 ELk是Elasticsearch + Logstash + Kibana的缩写，ELK一般用来收集分布式架构下各个节点的日志，并进行统一地管理。 Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。 Kibana也是一个开源和免费的工具，Kibana可以为Logstash和ElasticSearch提供的日志分析友好的Web界面，可以帮助汇总、分析和搜索重要数据日志。 上面的官方介绍可能会比较抽象，按我个人的理解，可以简单将ELK理解为一个MVC架构的Java web应用：Elasticsearch对应M，Logstash对应C，Kibana对应V。 由于项目使用的是6.4.2版本的Elasticsearch，所以整个ELK都采用了同样的版本6.4.2。这三个软件都可以直接从官网下载到，下面是官网地址。 → 官方下载地址 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:2:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"ELK的下载安装与快速入门 本文只是基于Windows平台下，进行简单的快速入门，先搭建好ELK框架并测试通过，后续文章再记录更多的细节。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:3:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Elasticsearch 6.4.2 从官网下载了6.4.2版本的Elasticsearch的压缩版后，解压即可使用，使用默认的配置即可。 在Elasticsearch的安装目录下，进入/bin目录，可以看到有两个文件： elaticsearch elaticsearch.bat 这两个文件都可以启动Elasticsearch，暂时没发现在Windows平台下通过这两个文件启动Elasticsearch有什么不同。我一般使用没有后缀名的那个文件来启动Elasticsearch。 启动成功后，在浏览器输入127.0.0.1:9200，如果访问成功会反馈信息： { \"name\" : \"erwbgE5\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"QQvV3hBnSCSGsf-ycD3fng\", \"version\" : { \"number\" : \"6.4.2\", \"build_flavor\" : \"default\", \"build_type\" : \"zip\", \"build_hash\" : \"04711c2\", \"build_date\" : \"2018-09-26T13:34:09.098244Z\", \"build_snapshot\" : false, \"lucene_version\" : \"7.4.0\", \"minimum_wire_compatibility_version\" : \"5.6.0\", \"minimum_index_compatibility_version\" : \"5.0.0\" }, \"tagline\" : \"You Know, for Search\" } 注意，如果使用Elasticsearch5.X及以上的版本，需要使用jdk 1.8；5.X以下版本使用jdk 1.6或1.7。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:3:1","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Logstash 6.4.2 同样从官网下载6.4.2版本的Logstash安装包，解压之后进入/config目录，创建一个配置文件tcp.conf，内容如下： input { stdin { } } filter { } output { stdout { codec =\u003e rubydebug } } 接着进入/bin目录，运行命令如下： logstash -f ../config/test.conf 当看到Successfully started Logstash API endpoint的字眼时表示启动成功，此时输入任意字符，比如输入hello，可以得到相应的反馈，如下： { \"message\" =\u003e \"hello\\r\", \"@timestamp\" =\u003e 2019-05-09T14:48:04.033Z, \"host\" =\u003e \"DESKTOP-S7HJJKD\", \"@version\" =\u003e \"1\" } 这里解释下，Logstash的配置非常简单，就是一套流程：input -\u003e filter -\u003e output。 input用来收集信息，这里配置的是stdin插件，即标准输入，也就是刚刚在控制台里输入的字符串。 filter表示过滤信息，这里没有进行任何过滤。 output表示输出信息，这里配置的是stdout插件，即标准输出，也就是将信息输出到控制台上。这里的codec指明使用rubydebug作为编解码器。 接着是运行的命令，使用了-f参数来指定使用某个配置文件。如果想要热加载的效果，可以加上-r参数，这样就可以在运行Logstash的时候去修改配置文件并自动重加载生效。这个-r参数等同于--config.reload.automatic。如下： logstash -f ../config/test.conf -r logstash -f ../config/test.conf --config.reload.automatic 注意，如果在输入源里使用了stdin或者syslog等输入插件，是不支持热加载的，会一直报错。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:3:2","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Kibana 6.4.2 从官网上下载Kibana6.4.2的压缩包，解压后即可使用。接着进入/bin目录，运行kibana.bat。运行成功后，在浏览器输入localhost:5601，即可访问Kibana的页面，之后就可以通过这个Kibana提供的web界面来对Elasticsearch里的文档进行各种操作。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:3:3","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Logstash + Log4j2的快速搭建用例其一 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:4:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"配置tcp插件并启动Logstash 修改之前创建的Logstash的配置文件test.config，内容如下： input { tcp { mode =\u003e \"server\" host =\u003e \"127.0.0.1\" port =\u003e 4567 } } filter { } output { stdout { codec =\u003e rubydebug } } 然后运行命令logstash -f ../config/test.conf -r来启动Logstash。由于我们这里通过-r来启用了热加载功能，所以可以在运行中直接修改配置并生效，比如修改input里的port。热加载成功后会看到如下字眼： Reloading pipeline {\"pipeline.id\"=\u003e:main} ","date":"2019-05-11","objectID":"/posts/65db1615.html/:4:1","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"使用了Socket Appender的Log4j2项目demo 接着准备一个使用了Log4j2的项目demo，如下是一个测试类Test.java： import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Test { public static final Logger LOGGER = LogManager.getLogger(\"elk.test\"); public static void main(final String[] args) { LOGGER.info(\"Hello world!\"); } } 这里使用的是2.11.1版本的Log4j2，Maven依赖如下： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.11.1\u003c/version\u003e \u003c/dependency\u003e 接着是配置Log4j2的配置文件log4j2.xml，如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration xmlns:xi=\"http://www.w3.org/2001/XInclude\" monitorInterval=\"30\"\u003e \u003cProperties\u003e \u003cProperty name=\"LOG_PATTERN\"\u003e{\"logger\": \"%logger\", \"level\": \"%level\", \"msg\": \"%message\"}%n\u003c/Property\u003e \u003c/Properties\u003e \u003cAppenders\u003e \u003cConsole name=\"stdout\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${LOG_PATTERN}\" /\u003e \u003c/Console\u003e \u003cSocket name=\"logstash-tcp\" host=\"127.0.0.1\" port=\"4567\" protocol=\"TCP\"\u003e \u003cPatternLayout pattern=\"${LOG_PATTERN}\"/\u003e \u003c/Socket\u003e \u003c/Appenders\u003e \u003cLoggers\u003e \u003cLogger name=\"elk.test\" level=\"info\" additivity=\"false\"\u003e \u003cAppenderRef ref=\"stdout\" /\u003e \u003cAppenderRef ref=\"logstash-tcp\" /\u003e \u003c/Logger\u003e \u003cRoot level=\"error\"\u003e \u003cAppenderRef ref=\"stdout\" /\u003e \u003c/Root\u003e \u003c/Loggers\u003e \u003c/configuration\u003e 从配置文件中可以看到，这里使用的是Socket Appender来将日志打印的信息发送到Logstash。 注意了，Socket的Appender必须要配置到下面的Logger才能将日志输出到Logstash里！ 另外这里的host是部署了Logstash服务端的地址，并且端口号要和你在Logstash里配置的一致才行。 运行该项目demo，可以看到Logstash的控制台收集到了数据，如下： { \"host\" =\u003e \"127.0.0.1\", \"message\" =\u003e \"{\\\"logger\\\": \\\"elk.test\\\", \\\"level\\\": \\\"INFO\\\", \\\"msg\\\": \\\"Hello world!\\\"}\\r\", \"@timestamp\" =\u003e 2019-05-09T16:20:35.940Z, \"@version\" =\u003e \"1\", \"port\" =\u003e 49781 } ","date":"2019-05-11","objectID":"/posts/65db1615.html/:4:2","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"注意 这里由于使用的是Socket方式来连接Logstash的服务端，如果在连接期间，Logstash的服务停止了或者断掉了，就算接下来重启了Logstash，项目工程也无法自动重新连接上Logstash，除非重启项目工程。 在生产环境中，Logstash自然是有可能半路出问题重启的，所以不能使用这种Socket方式来传输日志。 可以使用gelf的方式来传输日志到Logstash，用例如下所示。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:4:3","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Logstash + Log4j2的快速搭建用例其二 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:5:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"配置gelf插件并启动Logstash 修改之前创建的Logstash的配置文件test.config，内容如下： input { gelf { host =\u003e \"127.0.0.1\" port =\u003e 4567 use_tcp =\u003e true } } filter { } output { stdout { codec =\u003e rubydebug } } 运行命令logstash -f ../config/test.conf -r启动Logstash。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:5:1","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"在Log4j2项目中使用Gelf Appender 将之前的项目工程里的log4j2.xml的Socket Appender改为使用Gelf Appender，如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration xmlns:xi=\"http://www.w3.org/2001/XInclude\" monitorInterval=\"30\"\u003e \u003cProperties\u003e \u003cProperty name=\"LOG_PATTERN\"\u003e{\"logger\": \"%logger\", \"level\": \"%level\", \"msg\": \"%message\"}%n\u003c/Property\u003e \u003c/Properties\u003e \u003cAppenders\u003e \u003cConsole name=\"stdout\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${LOG_PATTERN}\" /\u003e \u003c/Console\u003e \u003cGelf name=\"logstash-gelf\" host=\"tcp:localhost\" port=\"4567\" version=\"1.1\" ignoreExceptions=\"true\" extractStackTrace=\"true\" filterStackTrace=\"false\"\u003e \u003cField name=\"timestamp\" pattern=\"%d{yyyy-MM-dd'T'HH:mm:ss.SSSZ}\" /\u003e \u003cField name=\"level\" pattern=\"%level\" /\u003e \u003cField name=\"simpleClassName\" pattern=\"%C{1}\" /\u003e \u003cField name=\"className\" pattern=\"%C\" /\u003e \u003cField name=\"server\" pattern=\"%host\" /\u003e \u003c/Gelf\u003e \u003c/Appenders\u003e \u003cLoggers\u003e \u003cLogger name=\"elk.test\" level=\"info\" additivity=\"false\"\u003e \u003cAppenderRef ref=\"stdout\" /\u003e \u003cAppenderRef ref=\"logstash-gelf\" /\u003e \u003c/Logger\u003e \u003cRoot level=\"error\"\u003e \u003cAppenderRef ref=\"stdout\" /\u003e \u003c/Root\u003e \u003c/Loggers\u003e \u003c/configuration\u003e 另外，这个Gelf Appender需要导入另一个依赖，如下： \u003cdependency\u003e \u003cgroupId\u003ebiz.paluch.logging\u003c/groupId\u003e \u003cartifactId\u003elogstash-gelf\u003c/artifactId\u003e \u003cversion\u003e1.11.1\u003c/version\u003e \u003c/dependency\u003e 接着运行项目工程，可以看到Logstash的控制台已经把收集到的日志打印出来了： { \"message\" =\u003e \"Hello world!\", \"@timestamp\" =\u003e 2019-05-10T14:09:43.267Z, \"className\" =\u003e \"lewky.cn.Test\", \"source_host\" =\u003e \"127.0.0.1\", \"timestamp\" =\u003e \"2019-05-10T22:09:43.211+0800\", \"simpleClassName\" =\u003e \"Test\", \"facility\" =\u003e \"logstash-gelf\", \"level\" =\u003e \"INFO\", \"host\" =\u003e \"DESKTOP-S7HJJKD\", \"@version\" =\u003e \"1\", \"server\" =\u003e \"DESKTOP-S7HJJKD\" } ","date":"2019-05-11","objectID":"/posts/65db1615.html/:5:2","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"ELK + Log4j2快速搭建用例 接下来就可以把Logstash收集到的日志输出到Elasticsearch，并通过Kibana显示到界面上。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:6:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"Logstash配置Elasticsearch插件 修改配置文件如下： input { gelf { host =\u003e \"127.0.0.1\" port =\u003e 4567 use_tcp =\u003e true } } filter { } output { stdout { codec =\u003e rubydebug } elasticsearch { hosts =\u003e [\"127.0.0.1:9200\"] document_id =\u003e \"%{docId}\" index =\u003e \"%{indexName}\" } } output里添加了elasticsearch插件： hosts里配置Elasticsearch server的地址 document_id是index到ES时使用的索引id index是index到ES是使用的索引名字 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:6:1","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"修改log4j2.xml和项目代码 在项目的log4j2.xml里的Gelf Appender加上两个个新的Field：indexName和docId，如下： \u003cGelf name=\"logstash-gelf\" host=\"tcp:localhost\" port=\"4567\" version=\"1.1\" ignoreExceptions=\"true\" extractStackTrace=\"true\" filterStackTrace=\"false\"\u003e \u003cField name=\"timestamp\" pattern=\"%d{yyyy-MM-dd'T'HH:mm:ss.SSSZ}\" /\u003e \u003cField name=\"level\" pattern=\"%level\" /\u003e \u003cField name=\"simpleClassName\" pattern=\"%C{1}\" /\u003e \u003cField name=\"className\" pattern=\"%C\" /\u003e \u003cField name=\"server\" pattern=\"%host\" /\u003e \u003cField name=\"indexName\" mdc=\"indexName\" /\u003e \u003cField name=\"docId\" mdc=\"docId\" /\u003e \u003c/Gelf\u003e 这里添加的两个新的Field对应于上边Logstash配置文件里的两个变量，然后这里用到了mdc，这个是Log4j2里的ThreadContext的东西，有兴趣可以去了解下Log4j2里的MDC和NDC。 接着修改测试类的代码，如下： public class Test { public static final Logger LOGGER = LogManager.getLogger(\"elk.test\"); public static void main(final String[] args) { ThreadContext.put(\"docId\", \"1\"); ThreadContext.put(\"indexName\", \"test\"); LOGGER.info(\"Hello world!\"); } } 接着依次启动ELK三个软件，然后运行项目，可以发现Logstash控制台里收集到了日志信息： { \"simpleClassName\" =\u003e \"Test\", \"server\" =\u003e \"DESKTOP-S7HJJKD\", \"message\" =\u003e \"Hello world!\", \"@version\" =\u003e \"1\", \"source_host\" =\u003e \"127.0.0.1\", \"indexName\" =\u003e \"test\", \"level\" =\u003e \"INFO\", \"@timestamp\" =\u003e 2019-05-11T16:40:14.996Z, \"facility\" =\u003e \"logstash-gelf\", \"className\" =\u003e \"lewky.cn.Test\", \"timestamp\" =\u003e \"2019-05-12T00:40:14.877+0800\", \"docId\" =\u003e 1, \"host\" =\u003e \"DESKTOP-S7HJJKD\" } 而在我们的IDE控制台（我用的是Eclipse）里也可以看到输出了信息： {\"logger\": \"elk.test\", \"level\": \"INFO\", \"msg\": \"Hello world!\"} ","date":"2019-05-11","objectID":"/posts/65db1615.html/:6:2","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"配置Kibana查看Elasticsearch的index数据 接下来就是最后一步了，通过Kibana来查看我们刚刚index到Elasticsearch里的数据。 启动了Kibana后，在浏览器访问localhost:5601，进入界面后，操作如下： Management -\u003e Index Patterns 输入index的名字，我们这里填的是test；然后点击Next step 在Time Filter field name下方的下拉框里选择timestamp作为我们的一个排序字段，默认是desc，即递减排序 最后点击Create index pattern 现在已经配置好了Index pattern，我们就可以直接在左侧菜单栏里的Discover去查看对应的index里的数据了。如果不出意外，现在在Discover里已经看到刚刚被我们index进去的日志信息了。 默认只会显示Time和_source两个字段的数据，Time就是排序字段，它的值和之前我们选择的那个timestamp一样。_source里则是所有字段的数据总和。 可以根据需要，在显示字段的左侧把任意的字段add到右侧以显示出来。当你添加了新的字段之后，_source字段会自动消失。 这就是最简单的一个ELK快速搭建例子，有兴趣的可以接着看后续的文章以了解更多和ELK相关的问题或知识。 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:6:3","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["ELK"],"content":"参考链接 ELK入门01—Elasticsearch安装 ELK入门02—Logstash+Log4j2+ES log4j2 + logstash 想问下ELK，不同版本都支持哪些jdk，在哪里查看。 logstash配置之自动重载配置文件 ET001 不可不掌握的 Logstash 使用技巧 ","date":"2019-05-11","objectID":"/posts/65db1615.html/:7:0","tags":["Java相关框架","ELK系列","Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例","uri":"/posts/65db1615.html/"},{"categories":["Hexo写作系列"],"content":"问题 在用Hexo写文章时，如果文章标题含有双引号\"，也就是说如果在文件头里的title出现双引号，如下： ---title:Hexo- 文章标题含有双引号\"导致页面渲染失败无法打开--- 由于这里的写法属于yml语法，双引号属于特殊符号，上述的title的写法就会在执行hexo g时报错，当我们在浏览器里打开这篇文章的页面时就会渲染失败无法打开。 ","date":"2019-05-04","objectID":"/posts/31deca5f.html/:1:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(3) - 文章标题含有双引号\"导致页面渲染失败无法打开","uri":"/posts/31deca5f.html/"},{"categories":["Hexo写作系列"],"content":"解决方法 我们需要对这里的双引号进行转义，对于这些特殊字符，可以用对应的HTML字符实体来替换。 对于双引号，其字符实体是\u0026#34;或者\u0026quot;。 最终我们在hexo文章的文件头里，应该这样写： ---title:Hexo- 文章标题含有双引号\u0026#34;导致页面渲染失败无法打开--- ","date":"2019-05-04","objectID":"/posts/31deca5f.html/:2:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(3) - 文章标题含有双引号\"导致页面渲染失败无法打开","uri":"/posts/31deca5f.html/"},{"categories":["Hexo写作系列"],"content":"补充 当然，对于文件头之外的部分，则是属于markdown语法的部分，此外由于我们的文章会被swig渲染，同样有一些特殊字符，比如 {{}}，如果在代码块之外的地方使用到这些特殊字符，就会报错！对于不同的语言，各自的特殊字符是不一样的。 这里补充下各种常用到的特殊字符的字符实体： ! \u0026#33; — 惊叹号 Exclamation mark \" \u0026#34; \u0026quot; — 双引号 Quotation mark # \u0026#35; — 数字标志 Number sign $ \u0026#36; — 美元标志 Dollar sign % \u0026#37; — 百分号 Percent sign \u0026 \u0026#38; \u0026amp; — 与符号(\u0026) Ampersand ' \u0026#39; — 单引号 Apostrophe ( \u0026#40; — 小括号左边部分 Left parenthesis ) \u0026#41; — 小括号右边部分 Right parenthesis * \u0026#42; — 星号 Asterisk + \u0026#43; — 加号 Plus sign \u003c \u0026#60; \u0026lt; 小于号 Less than = \u0026#61; — 等于符号 Equals sign - \u0026#45; \u0026minus; — 减号 \u003e \u0026#62; \u0026gt; — 大于号 Greater than ? \u0026#63; — 问号 Question mark @ \u0026#64; — Commercial at [ \u0026#91; — 中括号左边部分 Left square bracket \\ \u0026#92; — 反斜杠 Reverse solidus (backslash) ] \u0026#93; — 中括号右边部分 Right square bracket { \u0026#123; — 大括号左边部分 Left curly brace | \u0026#124; — 竖线Vertical bar } \u0026#125; — 大括号右边部分 Right curly brace 如果想要在文章中使用空格，直接输入空格是没用的，同样可以使用字符实体来代替，即\u0026nbsp;。这个代表不间断空格：non-breaking space。 ","date":"2019-05-04","objectID":"/posts/31deca5f.html/:3:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(3) - 文章标题含有双引号\"导致页面渲染失败无法打开","uri":"/posts/31deca5f.html/"},{"categories":["Hexo写作系列"],"content":"参考链接 Hexo 特殊符号的转义问题 HTML 字符实体 常用特殊符号的HTML代码(HTML字符实体) ","date":"2019-05-04","objectID":"/posts/31deca5f.html/:4:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(3) - 文章标题含有双引号\"导致页面渲染失败无法打开","uri":"/posts/31deca5f.html/"},{"categories":["Hexo"],"content":"问题与分析 某天忽然发现，一直运行得好好的Pages服务部署失败了，GitHub Pages报错如下： Your site is having problems building: The tag cq on line 3 in source/high/index.md is not a recognized Liquid tag. For more information, see https://help.github.com/articles/page-build-failed-unknown-tag-error/. 与此同时，Coding Pages同样也报错了： Starting jekyll build. \u003e jekyll build --safe Configuration file: /usr/src/app/_config.yml jekyll 3.6.2 | Error: The next theme could not be found. Jekyll build exit with code 1. Fail to build jekyll site. 首先我使用的是Hexo的next主题，而根据GitHub Pages的报错信息来看，是说在source/high/index.md里使用到了一个不认识的cq标签。 这个标签是next主题自带的，使用该标签快一年了，还是第一次遇到报这个错。接着根据Coding Pages的报错来看，则是说/usr/src/app/_config.yml里找不到jekyll的主题。 这就很奇怪了，我使用的明明是hexo，怎么忽然就变成jekyll了？一阵瞎折腾过后，一直部署失败。我忽然想起来一个事情，我之前曾经拿本地的博客仓库的git配置练过手，难道和这个有关？ 我开始查找本地博客仓库的git配置，我是使用hexo-deployer-git这个插件来将本地生成的静态博客发送到远程仓库的。 当我在本地在执行hexo g后，会在博客根目录下生成一个public文件夹，这个文件夹里的文件组合起来就是一个完整的静态博客。 接着如果执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里，然后会把该文件夹里的所有文件全部推送push到远程库。之后会触发Pages服务的钩子去build项目，然后部署到网站上。 ","date":"2019-04-26","objectID":"/posts/a5a02c64.html/:1:0","tags":["Hexo"],"title":"Hexo - 记录一次Pages服务部署失败的原因","uri":"/posts/a5a02c64.html/"},{"categories":["Hexo"],"content":"发现线索 我打开public文件夹，发现生成出来的文件很正常，接着打开.deploy_git文件夹，发现也很正常，接着查看远程库里的文件，终于发现了问题。 在远程库的分支里，根本就没有hexo相关的文件，至此算是找到原因了。 很显然，我在执行hexo d时出了问题，没能正常将文件push到远程库，于是部署就失败了。之前该命令是没问题的，可之前我曾经动过手脚，修改过博客项目里的git配置，手动修改了.git里的文件，莫非这就是问题的根源？ ","date":"2019-04-26","objectID":"/posts/a5a02c64.html/:2:0","tags":["Hexo"],"title":"Hexo - 记录一次Pages服务部署失败的原因","uri":"/posts/a5a02c64.html/"},{"categories":["Hexo"],"content":"解决方法 基于以上的猜想，我直接删掉了本地博客项目的.deploy_git文件夹，重新执行命令： hexo cl hexo g -d 等待片刻后，我终于看到远程部署成功，我的个人站点再次运转成功！ 皇天不负有心人啊！原因终于明了，是.deploy_git文件夹出现问题，删掉该文件夹，重新运行hexo d即可。 记录下这次的遭遇，遇到问题应该静下心来，仔细分析，才不容易瞎折腾~ ","date":"2019-04-26","objectID":"/posts/a5a02c64.html/:3:0","tags":["Hexo"],"title":"Hexo - 记录一次Pages服务部署失败的原因","uri":"/posts/a5a02c64.html/"},{"categories":["Java"],"content":"场景 出于业务考虑，将多个字符串拼接起来时，使用的分隔符是;,;。如果要将这样一个拼接来的字符串分割成原本的多个字符串时，就需要使用到jdk自带的split()方法。不过因为公司的编程规范，改为使用了Apache工具类的StringUtils.split()。 之后就发现，当被拼接的字符串里含有;或,时，就会出现分割不正确的问题。 ","date":"2019-04-09","objectID":"/posts/44d23f55.html/:1:0","tags":["Java","split"],"title":"StringUtils.split()和string.split()的区别","uri":"/posts/44d23f55.html/"},{"categories":["Java"],"content":"具体例子 下面的代码，使用了上述的两种split方法，猜猜结果是什么。 public class Test { public static void main(final String[] args) { final String str = \"老肥,老肥;是个,逗比\"; final String seperator = \";,;\"; //Apache工具类的split方法 final String[] result1 = StringUtils.split(str, seperator); for (final String string : result1) { System.out.println(string); } System.out.println(\"############分割线###########\"); //jdk的split方法 final String[] result2 = str.split(seperator); for (final String string : result2) { System.out.println(string); } } } 分割的结果如下： 老肥 老肥 是个 逗比 ############分割线########### 老肥,老肥;是个,逗比 ","date":"2019-04-09","objectID":"/posts/44d23f55.html/:2:0","tags":["Java","split"],"title":"StringUtils.split()和string.split()的区别","uri":"/posts/44d23f55.html/"},{"categories":["Java"],"content":"StringUtils.split()和string.split()的区别 StringUtils.split()是把分隔符拆成一个个单独的字符，再用这些字符去把字符串进行分割的。只要匹配到了分隔符中的任意一个字符，就会进行分割。而string.split()是把分隔符作为一个整体来对字符串进行分割。 比如分隔符是;,;，那么在用StringUtils.split()时，只要被分割的字符串里遇到;或,，就会被分割。而在用string.split()时，必须被分割的字符串里遇到;,;时才会被分割。 另外string.split()的分隔符参数其实是正则表达式，而StringUtils.split()的分隔符参数就只是个普通的字符串。此外，StringUtils.split()是null-safe的，已经帮你判空了，这也是公司规范要我们使用Apache工具类的原因。不过由于这里的业务要求，最终还是选择使用string.split()。 最后附上StringUtils.split()的部分底层实现： //standard case while (i \u003c len) { if (separatorChars.indexOf(str.charAt(i)) \u003e= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } ","date":"2019-04-09","objectID":"/posts/44d23f55.html/:3:0","tags":["Java","split"],"title":"StringUtils.split()和string.split()的区别","uri":"/posts/44d23f55.html/"},{"categories":["Eclipse"],"content":"方法 Window -\u003e Preferences -\u003e General -\u003e Startup and Shutdown -\u003e Workspaces 勾选Prompt for workspace on startup ","date":"2019-01-30","objectID":"/posts/3671826f.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 怎么设置在启动时提示选择工作空间","uri":"/posts/3671826f.html/"},{"categories":["Eclipse"],"content":"参考链接 怎样设置Eclipse在启动时提示选择工作空间 ","date":"2019-01-30","objectID":"/posts/3671826f.html/:2:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 怎么设置在启动时提示选择工作空间","uri":"/posts/3671826f.html/"},{"categories":["Eclipse"],"content":"问题 Eclipse在安装了jd-eclipse插件后依然无法反编译类文件，这个问题是因为没有修改默认的类文件查看器。 ","date":"2019-01-30","objectID":"/posts/89d8e317.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 安装了jd-eclipse插件后依然无法反编译类文件","uri":"/posts/89d8e317.html/"},{"categories":["Eclipse"],"content":"解决方法 修改默认的类文件查看器为jd-eclipse Window -\u003e Preference -\u003e General -\u003e Editors -\u003e File Associations 选中*.class，将Class File Editor设置为默认(Default) 选中*.class without source，将Class File Editor设置为默认(Default)；如果这一步操作只有Class File Viewer，则需要点击Add把Class File Editor添加进来并设置为默认(Default) 新版本的jd-eclipse的类文件查看器名字可能叫做JD Class File Viewer(总之，Class File Viewer是Eclipse自带的类文件查看器，安装插件后会出现新的类文件查看器) 接着重启Eclipse后就可以正常地反编译类文件了，如果缺少上述的第三步操作，会有比较大的可能依然无法反编译类文件。 ","date":"2019-01-30","objectID":"/posts/89d8e317.html/:2:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 安装了jd-eclipse插件后依然无法反编译类文件","uri":"/posts/89d8e317.html/"},{"categories":["Eclipse"],"content":"参考链接 安装jadClipse插件后,还是不能反编译.class ","date":"2019-01-30","objectID":"/posts/89d8e317.html/:3:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 安装了jd-eclipse插件后依然无法反编译类文件","uri":"/posts/89d8e317.html/"},{"categories":["Eclipse"],"content":"问题 今天导入项目时Eclipse报错如下： Access restriction: The type 'JPEGCodec' is not API (restriction on required library 'C:\\Program Files\\Java\\jdk1.8.0_191\\jre\\lib\\rt.jar') 第一次遇到这种错误，百度了下，原来是因为Eclipse默认把访问受限的API设置成了Error级别，所以才会编译报错。 ","date":"2019-01-18","objectID":"/posts/5f77a7c4.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - Access restriction: The type 'JPEGCodec' is not API","uri":"/posts/5f77a7c4.html/"},{"categories":["Eclipse"],"content":"解决方法 ","date":"2019-01-18","objectID":"/posts/5f77a7c4.html/:2:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - Access restriction: The type 'JPEGCodec' is not API","uri":"/posts/5f77a7c4.html/"},{"categories":["Eclipse"],"content":"方法一（推荐） 直接将项目的JRE给remove掉，然后再重新将JRE添加到项目中，操作如下： 右键项目，选择Properties -\u003e Java Build Path -\u003e Libraries -\u003e 选中JRE System Library [jdkxxxx] -\u003e 选择Remove 接着选择Add Librariy...，重新加入JRE ","date":"2019-01-18","objectID":"/posts/5f77a7c4.html/:2:1","tags":["IDE工具","Eclipse"],"title":"Eclipse - Access restriction: The type 'JPEGCodec' is not API","uri":"/posts/5f77a7c4.html/"},{"categories":["Eclipse"],"content":"方法二 修改Eclipse中关于访问受限的API的编译级别： Window -\u003e Preferences -\u003e Java -\u003e Compiler -\u003e Errors/Warnings，选择Deprecated and restricted API，将其中的Forbidden reference(access rules)的级别选为Warning。 ","date":"2019-01-18","objectID":"/posts/5f77a7c4.html/:2:2","tags":["IDE工具","Eclipse"],"title":"Eclipse - Access restriction: The type 'JPEGCodec' is not API","uri":"/posts/5f77a7c4.html/"},{"categories":["Eclipse"],"content":"参考链接 解决办法：Access restriction: The type JPEGImageEncoder is not accessible due to restriction ","date":"2019-01-18","objectID":"/posts/5f77a7c4.html/:3:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - Access restriction: The type 'JPEGCodec' is not API","uri":"/posts/5f77a7c4.html/"},{"categories":["常用软件"],"content":"前言 有时候需要对若干列进行一样的操作，比如在前一百行数据的最前边加上一样的字符，这时候可以通过列块编辑模式来快捷地实现这个效果。在列块编辑模式下，被选定的区域内的所有字符会被替换成你之后输入的字符。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:1:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"Eclipse Alt + Shift + A启用列块编辑模式 按住鼠标左键选定区域 Alt + Shift + A关闭列块编辑模式 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:2:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"IntelliJ IDEA 按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:3:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"Notepad++ 两种方法： 按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。 按住Alt + Shift，然后用键盘的上下左右箭头进行选定区域。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:4:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"UltraEdit UltraEdit的列块编辑模式快捷键是Alt + C，也可以直接在Column菜单里选择Column Mode，或者直接在工具栏里点击其图标按钮。 使用方法有两种： 先选定要同时编辑的区域，再启动列块编辑模式。 先启动列块编辑模式，再选定要同时编辑的区域。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:5:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"EditPlus 两种方法： 菜单：编辑 -\u003e 选择 -\u003e 列选择 使用快捷键Alt + C，接着移动鼠标或键盘上下左右键选定区域。 注意：在自动换行的模式下是不行的，改为不自动换行就行了。可以参考设置自动换行的方法：EditPlus 3：设置自动换行 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:6:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"EmEditor 按住Alt + C不放，然后用鼠标选定区域。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:7:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"LiteEdit 按住Alt不放，然后用鼠标进行列块选择。 点击菜单上的“列块选择”后用鼠标进行列块选择。 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:8:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["常用软件"],"content":"参考链接 notepad++如何使用列块编辑模式？ eclipse、EditPlus等编辑器选中列(块)的方法 ","date":"2019-01-17","objectID":"/posts/f0ce18c5.html/:9:0","tags":["常用软件","IDE工具","列块编辑"],"title":"IDE工具、文本编辑器的列块编辑模式","uri":"/posts/f0ce18c5.html/"},{"categories":["Git"],"content":"问题 如果某个文件已经存在于远程仓库了，也就是说某个文件已经被版本控制了，如果将该文件添加到.gitignore中，是无法生效的。因为.gitignore是用来控制尚未被纳入版本控制的文件，如果文件已经存在于远程库中，自然也就无法生效了。 于是就此衍生了一个问题：.gitignore怎么忽略已经被版本控制的文件？ ","date":"2019-01-07","objectID":"/posts/a7180574.html/:1:0","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":"解决方法 ","date":"2019-01-07","objectID":"/posts/a7180574.html/:2:0","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":"方法一 直接在远程库里将想要忽略的文件删除掉，再将该文件写入.gitignore中即可。 这种做法的前提是，你确定该文件是允许从远程库删除掉的，然而有些时候，这种做法是不可能的。要么没权限去远程库删掉该文件，要么该文件是必须的。 ","date":"2019-01-07","objectID":"/posts/a7180574.html/:2:1","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":"方法二 使用命令git rm --cached filename，然后将该文件写入.gitignore中即可。 该命令表示从git仓库中将文件移除，不再进行版本控制，但保留工作区的该文件。 需要注意的是，该命令其实和方法一差不多。git rm表示移除某个文件，--cached表示从暂存区中移除，如果不加该参数就是直接从工作区移除了。 工作区就是指的Working Tree，暂存区就是指的Stage。工作区就是我们的磁盘，被版本控制的文件都存放于工作区。如果改动了某个文件，首先要将该文件添加到暂存区(Stage)，然后再提交(commit)到本地仓库，最后才推送(push)到远程库。 git rm --cached filename并不会从物理上删除文件，只是从暂存区中将文件删除。由于该文件原本已经被版本控制了，使用了该命令后，虽然保留了工作区的该文件，但是却会在暂存区中生成一个删除了该文件的记录，如果此时进行commit，就会把版本库里的该文件给删掉了，如果push到远程库，也会被删掉。最终还是走的方法一的路子。 ","date":"2019-01-07","objectID":"/posts/a7180574.html/:2:2","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":"关于git rm --cached filename的补充 看到有篇文章举例很详细，如下： 新建文件1.txt，未被跟踪(Untracked files)，提交到暂存区(Changed to be committed)，未提交到版本库。 使用git rm —cached 1.txt： 把文件恢复到未被跟踪的状态，即删除暂存区中的1.txt； 文件1.txt，已经提交到版本库，工作区，暂存区都是干净的。使用git rm —cached 1.txt： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files 暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。 不影响工作区中的文件。 文件1.txt, 已经提交到版本库，修改1.txt，并且提交到了暂存区。使用git rm —cached 1.txt： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files。\u2028 暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。\u2028 不影响工作区中的文件。还是修改后的1.txt 文件1.txt, 已经提交到版本库，修改1.txt，提交到暂存区，继续修改1.txt。使用git rm —cached 1.txt 会报错，不能执行操作。 ","date":"2019-01-07","objectID":"/posts/a7180574.html/:3:0","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":"参考链接 .gitignore无效，不能过滤某些文件 git rm - - cached filename git忽略已经被提交的文件 ","date":"2019-01-07","objectID":"/posts/a7180574.html/:4:0","tags":["Git","版本控制工具"],"title":"Git - .gitignore怎么忽略已经被版本控制的文件","uri":"/posts/a7180574.html/"},{"categories":["Git"],"content":".gitignore文件的作用 .gitignore文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被git跟踪到的，换句话说，被忽略的文件是不会被放入到远程仓库里的。 也就是说，如果文件已经存在于远程仓库中，是无法通过.gitignore文件来忽略的。 .gitignore文件存放于git仓库的根目录下。 ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:1:0","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":".gitignore文件的语法 ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:0","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"注释 #表示注释，如下： # Here is comment. ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:1","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"忽略文件/文件夹 直接写入文件或文件夹名即可，指定文件夹里的所有文件也会一起被忽略，如下： # ignore target folder target/ # ignore Eclipse files .settings/ build/ .classpath .project ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:2","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"不忽略文件/文件夹 !表示不忽略指定的文件，如下： # don't ignore src folder !src/ ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:3","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"在指定文件夹里不忽略指定的文件 通过!可以实现更加有意思的用法，如下： # ignore scaffolds folder, but don't ignore draft.md under scaffolds folder. scaffolds/* !scaffolds/draft.md 注意：这里必须在文件夹后面加上/*，否则是无法实现想要的效果的。 ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:4","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"使用通配符及其他符号 可以使用通配符及其他符号来指定复杂条件的文件，如下： *.log day_1?.txt hello[0-9].txt hi[^0-9].txt *表示匹配任意字符； ?表示匹配一个字符； []表示匹配中括号内的单个字符： 可以使用-来表示连贯的字符，比如0-9，a-z，A-Z等，[0-9]表示匹配从0到9的单个字符。 可以使用^来表示除外，比如[^0-9]表示除0到9之外的单个字符。 ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:2:5","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["Git"],"content":"参考链接 .gitignore 规则写法 - 在已忽略文件夹中不忽略指定文件、文件夹【注意项】 ","date":"2019-01-06","objectID":"/posts/b6b49845.html/:3:0","tags":["Git","版本控制工具","gitignore"],"title":"Git - .gitignore文件的用法","uri":"/posts/b6b49845.html/"},{"categories":["日志框架"],"content":"功能需求 项目里将User分成了各个区域(domain)，这些domain有个标志domainId，现在要求在打印日志的时候，不仅将所有User的日志都打印到日志文件logs/CNTCore.log中，还需要另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log。 比如User A的domainId是RD2，那么除了logs/CNTCore.log外，还需要将该User A的日志额外打印到logs/RD2/CNTCore.log中。 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:1:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"实现思路 将所有User的日志都打印到日志文件logs/CNTCore.log中，这个可以直接使用配置文件log4j2.xml来解决，一个简单的配置如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration monitorInterval=\"30\"\u003e \u003cAppenders\u003e \u003cConsole name=\"stdout\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"%-5p %m%n\" /\u003e \u003cThresholdFilter level=\"debug\" onMatch=\"ACCEPT\" onMismatch=\"DENY\" /\u003e \u003c/Console\u003e \u003cRollingFile name=\"cntCorelog\" immediateFlush=\"true\" fileName=\"logs/CNTCore.log\" filePattern=\"logs/CNTCore.log.%d{yyyy-MM-dd-a}.gz\" append=\"true\"\u003e \u003cPatternLayout\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS}:%p %t %X{TracingMsg} %c - %m%n\u003c/pattern\u003e \u003c/PatternLayout\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"1\" /\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e \u003c/Appenders\u003e \u003cLoggers\u003e \u003cLogger name=\"com.lewis\" level=\"debug\" additivity=\"true\"\u003e \u003cAppenderRef ref=\"cntCorelog\" /\u003e \u003c/Logger\u003e \u003cRoot level=\"error\"\u003e \u003cAppenderRef ref=\"stdout\" /\u003e \u003c/Root\u003e \u003c/Loggers\u003e \u003c/configuration\u003e 在上边的配置中，配置了cntCorelog这个appender来生成对应的回滚日志文件，具体由com.lewis这个logger来使用该appender进行拼接日志信息。 至于另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log，这个可以通过代码来动态生成各个domain的appender，并交由com.lewis这个logger来进行拼接日志。 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:2:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"代码的具体实现 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:3:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"项目的Log4j2依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.11.1\u003c/version\u003e \u003c/dependency\u003e ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:3:1","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"动态生成appender public static void createDomainAppender(final String domainId){ final LoggerContext ctx = (LoggerContext) LogManager.getContext(false); final org.apache.logging.log4j.core.config.Configuration config = ctx.getConfiguration(); if (config.getAppender(domainId + \"DomainCntCoreLog\") != null) { return; } final PatternLayout layout = PatternLayout.newBuilder() .withCharset(Charset.forName(\"UTF-8\")) .withConfiguration(config) .withPattern(\"%d %t %p %X{TracingMsg} %c - %m%n\") .build(); final TriggeringPolicy policy = TimeBasedTriggeringPolicy.newBuilder() .withModulate(true) .withInterval(1) .build(); final Appender appender = RollingFileAppender.newBuilder() .withName(domainId + \"DomainCntCoreLog\") .withImmediateFlush(true) .withFileName(\"logs/\" + domainId + \"/CNTCore.log\") .withFilePattern(\"logs/\" + domainId + \"/CNTCore.log.%d{yyyy-MM-dd-a}.gz\") .withLayout(layout) .withPolicy(policy) .build(); appender.start(); config.addAppender(appender); final KeyValuePair[] pairs = {KeyValuePair.newBuilder().setKey(\"domainId\").setValue(domainId).build()}; final Filter filter = ThreadContextMapFilter.createFilter(pairs, null, Result.ACCEPT, Result.DENY); config.getLoggerConfig(\"com.lewis\").addAppender(appender, Level.DEBUG, filter); ctx.updateLoggers(config); } 这段代码动态生成一个名为omainCntCoreLog的RollingFileAppender，该appender交由com.lewis这个logger来使用，并将日志信息输入到logs/{domainId}/CNTCore.log。 该logger在使用omainCntCoreLog这个RollingFileAppender时还设置了一个过滤器ThreadContextMapFilter，这个Filter用来控制logger只能对指定了domainId的进行打印日志。 ThreadContext是Log4j2用来存放线程信息的，相当于Log4j 1.X中的MDC和NDC，MDC是map，NDC是stack。当每个User登录时，就将该User的domainId存放到ThreadContext中，当退出登录时就将该domainId从ThreadContext中移除。 假如有10个User登录了，一个User对应一个线程，每个线程都存放了User对应的domainId。在用户登录时，调用上边的方法来动态生成domain appender；假如有10个domainId，就会生成10个domain appender。 由于这10个domain appender都被add到同一个logger里了，如果不通过ThreadContextMapFilter来控制，就会造成每个User的日志信息都会被输入到所有domain appender里去。 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:3:2","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"在加载配置文件后拼接domain appender 需要注意的是，必须在读取配置文件后才能去动态生成appender或者其他的日志对象，否则会被原本的配置文件覆盖掉。 public static void main(final String[] args) { ThreadContext.put(\"domainId\", \"RD2\"); final String domainId = \"RD2\"; final LoggerContext context1 = (org.apache.logging.log4j.core.LoggerContext) LogManager.getContext(false); try { context1.setConfigLocation(Loader.getResource(\"log4j2.xml\", null).toURI()); createDomainAppender(domainId); } catch (final Exception e) { LogManager.getRootLogger().error(\"load log4j2 configuration error\", e); ThreadContext.remove(\"domainId\"); } } 上边的代码简单地动态生成了RD2 domain的appender，需要注意的是，如果启用了Log4j2的动态加载配置文件功能，那么当配置文件被改动后并被重新加载时，会导致原本动态生成的domain appender无效。 因为重新加载配置文件会生成新的LoggerContext对象，这时候可能会丢失一部分日志信息到对应的domain日志文件里。对于这个暂时没找到很好的解决方法，目前只能是在每个User登录时去创建domain appender对象，如果已存在就不创建。 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:3:3","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"对ThreadContextMapFilter的补充 上边通过代码动态生成了RollingFileAppender和ThreadContextMapFilter，下边记录下配置文件里的写法： \u003cRollingFile name=\"domainCntCoreLog\" immediateFlush=\"true\" fileName=\"logs/RD2/CNTCore.log\" filePattern=\"logs/RD2/CNTCore.log.%d{yyyy-MM-dd-a}.gz\" append=\"true\"\u003e \u003cThreadContextMapFilter onMatch=\"ACCEPT\" onMismatch=\"DENY\"\u003e \u003cKeyValuePair key=\"domainId\" value=\"RD2\" /\u003e \u003c/ThreadContextMapFilter\u003e \u003cPatternLayout pattern=\"%d %t %p %X{TracingMsg} %c - %m%n\" /\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"1\" /\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e 从上边的配置就可以看出来短板了，只能配置死某个domainId的RollingFileAppender以及ThreadContextMapFilter，假如有10个domainId，就要手动配置十个对应的appender和Filter，很是繁琐。 就算通过占位符${ctx:domainId}的写法来避免写死，也只能生成某个domainId的appender： \u003cRollingFile name=\"domainCntCoreLog\" immediateFlush=\"true\" fileName=\"logs/${ctx:domainId}/CNTCore.log\" filePattern=\"logs/${ctx:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\" append=\"true\"\u003e \u003cThreadContextMapFilter onMatch=\"ACCEPT\" onMismatch=\"DENY\"\u003e \u003cKeyValuePair key=\"domainId\" value=\"${ctx:domainId}\" /\u003e \u003c/ThreadContextMapFilter\u003e \u003cPatternLayout pattern=\"%d %t %p %X{TracingMsg} %c - %m%n\" /\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"1\" /\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e 这种方法只能生成一个domain appender，此外如果启用了动态加载配置文件的功能，在扫描配置文件是否改动时，还会报错，原因是在RollingFileAppender的FileName和filePattern里使用了占位符。在另起线程扫描配置文件时，该占位符时取不到值的，于是就会报错。 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:4:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"参考链接 运行时添加log4j2的appender log4j2如何动态的创建logger和appender log4j2 不使用配置文件，动态生成logger对象 log4j2的MDC应用配置 ","date":"2019-01-03","objectID":"/posts/8dc44b45.html/:5:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender","uri":"/posts/8dc44b45.html/"},{"categories":["日志框架"],"content":"问题与分析 在使用Log4j2时，虽然可以正确读取配置文件并生成log文件，但偶然发现控制台打印了异常信息如下： 2018-12-31 17:28:14,282 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to invoke factory method in class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.findFactoryMethod(PluginBuilder.java:235) at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:135) at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:959) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:899) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:891) at org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:514) at org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:238) at org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:250) at org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:547) at org.apache.logging.log4j.core.LoggerContext.onChange(LoggerContext.java:670) at org.apache.logging.log4j.core.config.ConfiguratonFileWatcher$ReconfigurationRunnable.run(ConfiguratonFileWatcher.java:68) at java.lang.Thread.run(Thread.java:748) 将控制台的所有信息都复制出来，仔细查找，又发现了相关的异常信息： 2018-12-31 17:28:14,241 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to create file logs/${ctx:domainId}/CNTCore.log java.io.IOException: The filename, directory name, or volume label syntax is incorrect at java.io.WinNTFileSystem.canonicalize0(Native Method) at java.io.WinNTFileSystem.canonicalize(WinNTFileSystem.java:428) at java.io.File.getCanonicalPath(File.java:618) at .... 2018-12-31 17:28:14,280 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Could not create plugin of type class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/${ctx:domainId}/CNTCore.log] with data [...] java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/${ctx:domainId}/CNTCore.log] with data [...] at org.apache.logging.log4j.core.appender.AbstractManager.getManager(AbstractManager.java:115) at org.apache.logging.log4j.core.appender.OutputStreamManager.getManager(OutputStreamManager.java:114) at org.apache.logging.log4j.core.appender.rolling.RollingFileManager.getFileManager(RollingFileManager.java:188) at .... 看起来是因为配置文件里的RollingFile使用到了${ctx:domainId}导致了这个问题。百度了下，发现了log4j2的jira issue：Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile 该问题和我遇到的一样，而在jira里有comment如下： Question: Does system property logfile have a value? 结合项目的配置文件log4j2.xml: \u003cRollingFile name=\"logfile\" immediateFlush=\"true\" fileName=\"logs/${ctx:domainId}/CNTCore.log\" filePattern=\"logs/${ctx:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\" append=\"true\"\u003e \u003cPatternLayout\u003e \u003cpattern\u003e%d %t %p %X{TracingMsg} %c - %m%n\u003c/pattern\u003e \u003c/PatternLayout\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"1\" /\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e 可以看出，这个异常是由于RollingFile使用到了${ctx:domainId}，而该变量值是null，导致无法创建对应的RollingFile文件到磁盘。但是这个domainId是通过ThreadContext把值put进去的，不可能是null，从最终的效果来看，这个变量其实也是拿到了值的，因为对应的日志文件以及存在于磁盘上了。 既然如此，为什么还会出现这个异常呢？通过观察控制台可以发现，每过一段时间就会出现一次该异常。从异常中可以看到ConfiguratonFileWatcher，好像有些明白为什么了。 ConfiguratonFileWatcher是用来扫描配置文件是否被改动过的，在配置文件中设置的扫描间隔是30s： \u003cconfiguration monitorInterval=\"30\"\u003e .... \u003c/configuration\u003e 由于扫描文件时另外起一个线程去扫描的，而${ctx:domainId}的值是存放于ThreadContext中的，Th","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:1:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"解决方法 ","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:2:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"方案一 既然问题是因为扫描配置文件是否改动造成的，那么只要将动态加载的功能关闭就行了，如下： \u003cconfiguration monitorInterval=\"0\"\u003e .... \u003c/configuration\u003e ","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:2:1","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"方案二 如果希望不关闭动态加载配置文件的功能，可以将domainId的值存放到System.properties里： System.setProperty(\"domainId\", \"xxx\"); 然后通过${sys:xxx}的方式来获取该properties的值： \u003cRollingFile name=\"logfile\" immediateFlush=\"true\" fileName=\"logs/${sys:domainId}/CNTCore.log\" filePattern=\"logs/${sys:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\" append=\"true\"\u003e \u003cPatternLayout\u003e \u003cpattern\u003e%d %t %p %X{TracingMsg} %c - %m%n\u003c/pattern\u003e \u003c/PatternLayout\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"1\" /\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e 在log4j2中关于这些变量取值有以下这些种类： Prefix Context bundle Resource bundle. The format is ${bundle:BundleName:BundleKey}. The bundle name follows package naming conventions, for example: ${bundle:com.domain.Messages:MyKey}. ctx Thread Context Map (MDC) date Inserts the current date and/or time using the specified format env System environment variables. The formats are ${env:ENV_NAME} and ${env:ENV_NAME:-default_value}. jndi A value set in the default JNDI Context. jvmrunargs A JVM input argument accessed through JMX, but not a main argument; see RuntimeMXBean.getInputArguments(). Not available on Android. log4j Log4j configuration properties. The expressions ${log4j:configLocation} and ${log4j:configParentLocation} respectively provide the absolute path to the log4j configuration file and its parent folder. main A value set with MapLookup.setMainArguments(String[]) map A value from a MapMessage sd A value from a StructuredDataMessage. The key “id” will return the name of the StructuredDataId without the enterprise number. The key “type” will return the message type. Other keys will retrieve individual elements from the Map. sys System properties. The formats are ${sys:some.property} and ${sys:some.property:-default_value}. ","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:2:2","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"方案三 不要在RollingFile的fileName和filePattern属性里使用到${ctx:domainId}等cdn或者mdn的写法，这样会导致在log4j2异步扫描重加载配置文件的时候报错。 可以使用另一种Appender来实现这种把日志分别打印到不同文件的效果，那就是RoutingAppender。有兴趣的可以去了解下这个RoutingAppender，还是挺有意思的。 ","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:2:3","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"参考链接 Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile Property Substitution ","date":"2019-01-02","objectID":"/posts/d8320ac8.html/:3:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - IllegalStateException: No factory method found for class","uri":"/posts/d8320ac8.html/"},{"categories":["日志框架"],"content":"问题 项目使用了log4j2，由于使用了全局异步打印日志的方式，还需要引入disruptor的依赖，最后使用的log4j2和disruptor的版本依赖如下： \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.11.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- log4j2 AsyncLogger need disruptor--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.lmax\u003c/groupId\u003e \u003cartifactId\u003edisruptor\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e 在项目最开始的地方(第一次使用到log4j2的logger之前)，通过代码来启用全局异步打印日志： // use asyncLogger for log4j2 framework System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\"); 然而在启动项目后报错如下： java.lang.NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor.\u003cinit\u003e(Lcom/lmax/disruptor/EventFactory;ILjava/util/concurrent/ThreadFactory;Lcom/lmax/disruptor/dsl/ProducerType;Lcom/lmax/disruptor/WaitStrategy;)V at org.apache.logging.log4j.core.async.AsyncLoggerDisruptor.start(AsyncLoggerDisruptor.java:97) at org.apache.logging.log4j.core.async.AsyncLoggerContext.start(AsyncLoggerContext.java:75) at ....... ","date":"2019-01-02","objectID":"/posts/a5cad454.html/:1:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor","uri":"/posts/a5cad454.html/"},{"categories":["日志框架"],"content":"解决方法 该问题是因为Disruptor的版本较低导致，将版本改用较新版本的即可： \u003cdependency\u003e \u003cgroupId\u003ecom.lmax\u003c/groupId\u003e \u003cartifactId\u003edisruptor\u003c/artifactId\u003e \u003cversion\u003e3.4.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2019-01-02","objectID":"/posts/a5cad454.html/:2:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2异常 - NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor","uri":"/posts/a5cad454.html/"},{"categories":["日志框架"],"content":"应用场景与问题 当项目在运行时，我们如果需要修改log4j 1.X或者log4j2的配置文件，一般来说我们是不能直接将项目停止运行再来修改文件重新部署的。于是就有这样一个问题：如何在不停止当前项目的运行的情况下，让系统能够自动地监控配置文件的修改状况，从而实现动态加载配置文件的功能？而log4j 1.X和log4j2的差别略大，各自应该怎么实现这个功能？ ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:1:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"log4j 1.X动态加载配置文件 log4j 1.X提供了动态加载配置文件的方法： DOMConfigurator.configureAndWatch() PropertyConfigurator.onfigureAndWatch() DOMConfigurator对应的是xml配置文件，PropertyConfigurator对应的是properties配置文件。这两个类都有configureAndWatch这个方法，该方法有个重载方法，如下： configureAndWatch(String configFilename) configureAndWatch(String configFilename, long delay) configureAndWatch方法用来监控配置文件是否被改动，监控的时间间隔是delay参数来决定，如果不传入该参数则使用默认的时间间隔1分钟(60000L)。configureAndWatch(String configFilename)实际上还是调用的configureAndWatch(String configFilename, long delay)。 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:2:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"log4j2动态加载配置文件 和log4j 1.X比起来，log4j2的动态加载配置很简单就能实现，不需要另外在代码中调用api，方法如下： \u003cconfiguration monitorInterval=\"30\"\u003e ... \u003c/configuration\u003e 在log4j2.xml配置文件中的configuration节点添加monitorInterval的值，单位是秒，如果配置的值大于0，则会按照时间间隔来自动扫描配置文件是否被修改，并在修改后重新加载最新的配置文件。如果不配置该值，默认为0，即不扫描配置文件是否被修改。 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:3:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"Log4j 1.X动态加载配置文件的底层实现原理 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:4:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"DOMConfigurator#configureAndWatch源码解析 org.apache.log4j.xml.DOMConfigurator#configureAndWatch源码如下： static public void configureAndWatch(String configFilename, long delay) { XMLWatchdog xdog = new XMLWatchdog(configFilename); xdog.setDelay(delay); xdog.start(); } 这里new了一个XMLWatchdog对象，接着设置了delay参数，最后调用了start()方法。 watchdog是看门狗、检查者的意思，XMLWatchdog继承了FileWatchdog这个类，在XMLWatchdog中仅仅重写了doOnChange方法： public void doOnChange() { new DOMConfigurator().doConfigure(filename, LogManager.getLoggerRepository()); } 从方法名就可以看出来，如果XMLWatchdog监控到配置文件被改动了，就会调用这个doOnChange方法，用来重新加载配置文件。那么它又是怎么知道配置文件被改动过了呢？接着看其父类FileWatchdog的源码： public abstract class FileWatchdog extends Thread { /** The default delay between every file modification check, set to 60 seconds. */ static final public long DEFAULT_DELAY = 60000; /** The name of the file to observe for changes. */ protected String filename; /** The delay to observe between every check. By default set {@link #DEFAULT_DELAY}. */ protected long delay = DEFAULT_DELAY; File file; long lastModif = 0; boolean warnedAlready = false; boolean interrupted = false; protected FileWatchdog(String filename) { super(\"FileWatchdog\"); this.filename = filename; file = new File(filename); setDaemon(true); checkAndConfigure(); } /** Set the delay to observe between each check of the file changes. */ public void setDelay(long delay) { this.delay = delay; } abstract protected void doOnChange(); protected void checkAndConfigure() { boolean fileExists; try { fileExists = file.exists(); } catch(SecurityException e) { LogLog.warn(\"Was not allowed to read check file existance, file:[\"+ filename+\"].\"); interrupted = true; // there is no point in continuing return; } if(fileExists) { long l = file.lastModified(); // this can also throw a SecurityException if(l \u003e lastModif) { // however, if we reached this point this lastModif = l; // is very unlikely. doOnChange(); warnedAlready = false; } } else { if(!warnedAlready) { LogLog.debug(\"[\"+filename+\"] does not exist.\"); warnedAlready = true; } } } public void run() { while(!interrupted) { try { Thread.sleep(delay); } catch(InterruptedException e) { // no interruption expected } checkAndConfigure(); } } } 可以看到，FileWatchdog继承了Thread类，类里定义了几个成员变量，比如默认的监控时间间隔等。而在该类的构造方法中可以看到，首先该线程类将名字设定成FileWatchdog，接着根据传入的配置文件的路径new了一个File对象，然后该线程类又设置成了守护线程(daemon thread)，最后调用了checkAndConfigure()。 在checkAndConfigure()中，则是对new出来的配置文件File对象进行检查是否存在该文件，若不存在该文件则会设置成员变量的值，这样就不会去监控不存在的配置文件了。如果该配置文件存在，则通过lastModified()来获取文件的最后更新时间，和上次的更新时间作对比，如果比上次更新时间大则会调用doOnChange()来重新加载配置文件。 而在FileWatchdog的run方法中，则是在无限循环中先让线程睡眠设置好的监控时间间隔，然后调用checkAndConfigure()。 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:4:1","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"总结 可以看出，在log4j 1.X的DOMConfigurator中，是通过创建一个守护线程来不停地扫描配置文件的最后更新时间，并和上次的更新时间进行对比，如果最后更新时间大于上次更新时间则会重新加载配置文件。 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:4:2","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"PropertyConfigurator#configureAndWatch源码解析 PropertyConfigurator的configureAndWatch()其实和DOMConfigurator差不多，区别是PropertyConfigurator在方法里new了一个PropertyWatchdog对象，PropertyWatchdog和XMLWatchdog一样继承了FileWatchdog，一样重写了doOnChange()方法。只是PropertyWatchdog是通过new PropertyConfigurator().doConfigure()来加载配置文件的。 从源码实现来看，无论是使用xml配置文件，还是使用properties配置文件，其动态加载配置文件的底层实现是基本一样的。可以通过解析配置文件的文件后缀来判断是xml还是properties文件，然后调用对应的方法即可，大概的思路如下： boolean flag = true; boolean isXml = StringUtils.equalsIgnoreCase(\"xml\", StringUtils.substringAfterLast(filepath, \".\")); ling delay = 30000; if (isXml) { if (flag) { DOMConfigurator.configureAndWatch(filepath, delay); } else { DOMConfigurator.configure(filepath); } } else { if (flag) { PropertyConfigurator.configureAndWatch(filepath, delay); } else { PropertyConfigurator.configure(filepath); } } ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:4:3","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"log4j2底层实现动态加载配置文件的简单解析 虽然log4j2的动态加载配置很简单，但其底层实现比起log4j 1.X却要复杂很多，使用到了很多并发包下的类，具体也不是很了解，这里简单解释下流程。 对于log4j2.xml文件，对应的是org.apache.logging.log4j.core.config.xml.XmlConfiguration这个类。如果在log4j2.xml里配置了monitorInterval，在构建XmlConfiguration时会根据该值来走一段特定的逻辑： for (final Map.Entry\u003cString, String\u003e entry : attrs.entrySet()) { final String key = entry.getKey(); final String value = getStrSubstitutor().replace(entry.getValue()); if (\"status\".equalsIgnoreCase(key)) { statusConfig.withStatus(value); } else if (\"dest\".equalsIgnoreCase(key)) { statusConfig.withDestination(value); } else if (\"shutdownHook\".equalsIgnoreCase(key)) { isShutdownHookEnabled = !\"disable\".equalsIgnoreCase(value); } else if (\"shutdownTimeout\".equalsIgnoreCase(key)) { shutdownTimeoutMillis = Long.parseLong(value); } else if (\"verbose\".equalsIgnoreCase(key)) { statusConfig.withVerbosity(value); } else if (\"packages\".equalsIgnoreCase(key)) { pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR))); } else if (\"name\".equalsIgnoreCase(key)) { setName(value); } else if (\"strict\".equalsIgnoreCase(key)) { strict = Boolean.parseBoolean(value); } else if (\"schema\".equalsIgnoreCase(key)) { schemaResource = value; } else if (\"monitorInterval\".equalsIgnoreCase(key)) { final int intervalSeconds = Integer.parseInt(value); if (intervalSeconds \u003e 0) { getWatchManager().setIntervalSeconds(intervalSeconds); if (configFile != null) { final FileWatcher watcher = new ConfiguratonFileWatcher(this, listeners); getWatchManager().watchFile(configFile, watcher); } } } else if (\"advertiser\".equalsIgnoreCase(key)) { createAdvertiser(value, configSource, buffer, \"text/xml\"); } } 可以看到，如果monitorInterval的值大于0，则会拿到WatchManager并设置扫描配置文件的时间间隔，如果配置文件存在，则会new一个ConfiguratonFileWatcher对象，并将配置文件和该对象一起传递给WatchManager的watchFile方法。这两个方法的底层实现很绕，比起log4j 1.X要复杂得多，不容易看懂。不过最终实现的效果还是一样的，依然会开启一个守护线程来监控配置文件是否被改动。 区别在于，log4j2使用线程池来启动线程，在WatchManager#start()里实现的： @Override public void start() { super.start(); if (intervalSeconds \u003e 0) { future = scheduler.scheduleWithFixedDelay(new WatchRunnable(), intervalSeconds, intervalSeconds, TimeUnit.SECONDS); } } 而该方法则是在启动配置文件时被调用的，AbstractConfiguration#start()： /** * Start the configuration. */ @Override public void start() { // Preserve the prior behavior of initializing during start if not initialized. if (getState().equals(State.INITIALIZING)) { initialize(); } LOGGER.debug(\"Starting configuration {}\", this); this.setStarting(); if (watchManager.getIntervalSeconds() \u003e 0) { watchManager.start(); } ... } 这里只是简单解析了下主要的流程，具体的实现细节目前还看不太懂，有兴趣的可以自己去看看log4j2的源码。另外我在官方文档里看到说monitorInterval的最小值是5，但是在源码里也没看到这个，我觉得只要配置值大于0应该就是可以的。有不对之处，欢迎指出。 这是官方原文： ###Automatic Reconfiguration When configured from a File, Log4j has the ability to automatically detect changes to the configuration file and reconfigure itself. If the monitorInterval attribute is specified on the configuration element and is set to a non-zero value then the file will be checked the next time a log event is evaluated and/or logged and the monitorInterval has elapsed since the last check. The example below shows how to configure the attribute so that the configuration file will be checked for changes only after at least 30 seconds have elapsed. The minimum interval is 5 seconds. ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:5:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"参考链接 Log4j 2.0 的新特性 Log4j – Configuring Log4j 2 - Apache Log4j 2 ","date":"2018-12-28","objectID":"/posts/2c65baa3.html/:6:0","tags":["Java相关框架","Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件","uri":"/posts/2c65baa3.html/"},{"categories":["日志框架"],"content":"LevelRangeFilter的注意点 在log4j2中，LevelRangeFilter的minLevel，maxLevel的配置是和log4j 1.x相反的；minLevel需要配置的是高级别，maxLevel配置的是低级别，如下： \u003cLevelRangeFilter minLevel=\"fatal\" maxLevel=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/\u003e 如上边的配置，是打印info到fatal级别的log，如果配置反过来，则不会输出任何log。 如果不配置minLevel、maxLevel、onMatch和onMismatch的值，则会为其设置默认值，在LevelRangeFilter中的源码实现如下： @PluginFactory public static LevelRangeFilter createFilter( // @formatter:off @PluginAttribute(\"minLevel\") final Level minLevel, @PluginAttribute(\"maxLevel\") final Level maxLevel, @PluginAttribute(\"onMatch\") final Result match, @PluginAttribute(\"onMismatch\") final Result mismatch) { // @formatter:on final Level actualMinLevel = minLevel == null ? Level.ERROR : minLevel; final Level actualMaxLevel = maxLevel == null ? Level.ERROR : maxLevel; final Result onMatch = match == null ? Result.NEUTRAL : match; final Result onMismatch = mismatch == null ? Result.DENY : mismatch; return new LevelRangeFilter(actualMinLevel, actualMaxLevel, onMatch, onMismatch); } 至于为什么把最大最小level的值配置反了就会无法输出，是因为在LevelRangeFilter中的源码实现如下： private Result filter(final Level level) { return level.isInRange(this.minLevel, this.maxLevel) ? onMatch : onMismatch; } 可以看到，在调用filter方法进行过滤时，是调用了level#isInRange()来判断是否匹配该filter的。而在该方法中，实现如下： public boolean isInRange(final Level minLevel, final Level maxLevel) { return this.intLevel \u003e= minLevel.intLevel \u0026\u0026 this.intLevel \u003c= maxLevel.intLevel; } 这里通过对比Level对象的intLevel值(int)来判断是否匹配，而这些Level对象也在Level这个类里进行里实例化： static { OFF = new Level(\"OFF\", StandardLevel.OFF.intLevel()); FATAL = new Level(\"FATAL\", StandardLevel.FATAL.intLevel()); ERROR = new Level(\"ERROR\", StandardLevel.ERROR.intLevel()); WARN = new Level(\"WARN\", StandardLevel.WARN.intLevel()); INFO = new Level(\"INFO\", StandardLevel.INFO.intLevel()); DEBUG = new Level(\"DEBUG\", StandardLevel.DEBUG.intLevel()); TRACE = new Level(\"TRACE\", StandardLevel.TRACE.intLevel()); ALL = new Level(\"ALL\", StandardLevel.ALL.intLevel()); } 可以看到，这些Level对象的intLevel值是由另一个枚举类StandardLevel来提供的： /** * No events will be logged. */ OFF(0), /** * A severe error that will prevent the application from continuing. */ FATAL(100), /** * An error in the application, possibly recoverable. */ ERROR(200), /** * An event that might possible lead to an error. */ WARN(300), /** * An event for informational purposes. */ INFO(400), /** * A general debugging event. */ DEBUG(500), /** * A fine-grained debug message, typically capturing the flow through the application. */ TRACE(600), /** * All events should be logged. */ ALL(Integer.MAX_VALUE); 可以看到，Level级别越高，其对应的intLevel值越小，可以这样理解：级别越高，能打印出来的日志信息就越少，所以其intLevel值就越小。 如果我们把LevelRangeFilter的minLevel、maxLevel配置反了，会导致level#isInRange()返回false，最终也就没有任何日志得以输出了。 ","date":"2018-12-22","objectID":"/posts/f53d27da.html/:1:0","tags":["Java相关框架","Log4j2"],"title":"Log4j2中LevelRangeFilter的注意点","uri":"/posts/f53d27da.html/"},{"categories":["日志框架"],"content":"前言 log4j中常用的Filter分为四种：DenyAllFilter、LevelMatchFilter、LevelRangeFilter、StringMatchFilter。 当appender匹配了某个Filter的时候，就不会继续匹配下一个filter，所以当需要配置多个filter时需要注意先后顺序，这样才能实现需要的效果。 这些filter有个共同的属性AcceptOnMatch，用来控制匹配到的appender是否打印日志。 ","date":"2018-12-20","objectID":"/posts/ec168d9b.html/:1:0","tags":["Java相关框架","Log4j"],"title":"Log4j.xml中Filter的用法","uri":"/posts/ec168d9b.html/"},{"categories":["日志框架"],"content":"只打印指定level的日志 假如现在只希望打印INFO和ERROR级别的日志，可以这样配置： \u003cappender name=\"cntCorelog\" class=\"org.apache.log4j.rolling.RollingFileAppender\"\u003e ...... \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"INFO\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\"/\u003e \u003c/filter\u003e \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\"/\u003e \u003c/filter\u003e \u003cfilter class=\"org.apache.log4j.varia.DenyAllFilter\" /\u003e \u003c/appender\u003e 这里如果不配置最后一个filter，则会放行所有日志输出。 ","date":"2018-12-20","objectID":"/posts/ec168d9b.html/:2:0","tags":["Java相关框架","Log4j"],"title":"Log4j.xml中Filter的用法","uri":"/posts/ec168d9b.html/"},{"categories":["日志框架"],"content":"不打印指定level的日志 假如不希望打印DEBUG级别的日志，可以这样配置： \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"false\" /\u003e \u003c/filter\u003e AcceptOnMatch表示是否输出日志，这里需要注意的是，一旦匹配了某个filter，就无法再匹配后续的filter了，如下： \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"false\" /\u003e \u003c/filter\u003e \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\" /\u003e \u003c/filter\u003e 对于上面的配置，ERROR级别的日志匹配了第一个filter后，结果是被过滤掉不被输出，于是第二个filter就不生效了。 如果将上边的配置颠倒过来，如下： \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\" /\u003e \u003c/filter\u003e \u003cfilter class=\"org.apache.log4j.varia.LevelMatchFilter\"\u003e \u003cparam name=\"LevelToMatch\" value=\"ERROR\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"false\" /\u003e \u003c/filter\u003e 这时候ERROR级别的日志就依然能正常被打印出来。 ","date":"2018-12-20","objectID":"/posts/ec168d9b.html/:3:0","tags":["Java相关框架","Log4j"],"title":"Log4j.xml中Filter的用法","uri":"/posts/ec168d9b.html/"},{"categories":["日志框架"],"content":"只打印从level A到B之间的所有日志 假如现在只想要打印INFO到ERROR级别之间的日志，可以这样配置： \u003cfilter class=\"org.apache.log4j.varia.LevelRangeFilter\"\u003e \u003cparam name=\"LevelMin\" value=\"INFO\"/\u003e \u003cparam name=\"LevelMax\" value=\"ERROR\"/\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\" /\u003e \u003c/filter\u003e 需要注意的是，对于LevelRangeFilter，会匹配所有的appender，如果将该filter置于其他filter的前面，则会导致后续的filter无效。 ","date":"2018-12-20","objectID":"/posts/ec168d9b.html/:4:0","tags":["Java相关框架","Log4j"],"title":"Log4j.xml中Filter的用法","uri":"/posts/ec168d9b.html/"},{"categories":["日志框架"],"content":"只打印包含某些字符串的日志 假如只希望打印某些字符串的日志，可以这样配置： \u003cfilter class=\"org.apache.log4j.varia.StringMatchFilter\"\u003e \u003cparam name=\"StringToMatch\" value=\"test\" /\u003e \u003cparam name=\"AcceptOnMatch\" value=\"true\" /\u003e \u003c/filter\u003e 如上配置，如果日志里包含了test这个字符串就会被输出到日志了，如果是包含某些字符串就不打印出来，直接将AcceptOnMatch设成false就行。 如果不配置StringToMatch的value，该filter无效；如果将其value配置为\"\"空字符串，该filter则会匹配所有日志。在StringMatchFilter的源码实现里，是通过indexOf()来判断是否包含指定字符串的。 ","date":"2018-12-20","objectID":"/posts/ec168d9b.html/:5:0","tags":["Java相关框架","Log4j"],"title":"Log4j.xml中Filter的用法","uri":"/posts/ec168d9b.html/"},{"categories":["Hexo"],"content":"问题 一般我们会将Hexo博客搭建到Github上，如果在Github上为其配置一个自定义的域名时，会自动在项目仓库根目录下新添加一个CNAME文件。但是这里有个问题，如果将Hexo博客重新部署一遍后，Github仓库里的这个CNAME文件就会消失掉，又需要重新配置一遍。 ","date":"2018-12-19","objectID":"/posts/39e3ca60.html/:1:0","tags":["Hexo","CNAME"],"title":"Hexo - CNAME文件在每次部署后就没了","uri":"/posts/39e3ca60.html/"},{"categories":["Hexo"],"content":"解决方法 其实这里有个技巧，我们可以将需要上传部署到Github的文件都放在source文件夹里，例如CNAME文件、favicon.ico、或者其他的图片等等，这样在执行hexo d这个命令之后，这些文件就不会被删除了。 Hexo在执行命令时是不会删除掉source目录下的文件的，我们可以在该目录下随意增加其他文件或者文件夹，建议在该目录下添加子文件夹，然后在子文件夹里添加文件，这样便于文件分档归类。 ","date":"2018-12-19","objectID":"/posts/39e3ca60.html/:2:0","tags":["Hexo","CNAME"],"title":"Hexo - CNAME文件在每次部署后就没了","uri":"/posts/39e3ca60.html/"},{"categories":["Java"],"content":"什么是反编译 高级语言源程序经过编译变成可执行文件，反编译就是逆过程。但是通常不能把可执行文件变成高级语言源代码，只能转换成汇编程序。 反编译是一个复杂的过程,所以越是高级语言,就越难于反编译,但目前还是有许许多多的反编译软件:通过对他人软件的目标程序（可执行程序）进行“逆向分析、研究”工作，以推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素，作为自己开发软件时的参考，或者直接用于自己的软件产品中。所以现在大家写的东西就想办法保护，不被侵权！ 总之，有时候我们想要阅读代码，但是只有jar包却没有源码，就需要用到反编译工具了。 ","date":"2018-12-10","objectID":"/posts/add9b646.html/:1:0","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"Java反编译工具JD-GUI Github上的官方下载地址：https://github.com/java-decompiler/jd-gui/releases 有多种平台的安装版本，可以自己选择下载安装，也可以直接下载JAR包，然后用java -jar进行运行，如下： java -jar jd-gui-1.4.0.jar ","date":"2018-12-10","objectID":"/posts/add9b646.html/:2:0","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"安装Eclipse的反编译插件 ","date":"2018-12-10","objectID":"/posts/add9b646.html/:3:0","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"jd-eclipse jd-gui在Eclipse上也有对应的反编译插件jd-eclipse，安装方式如下： 打开Eclipse -\u003e Help -\u003e Install New Software… -\u003e Add… 在弹出的窗口中输入Name和Location，Name可以随意取，Location要填写反编译插件的下载地址：http://jd.benow.ca/jd-eclipse/update （该地址可能已经过期，需要去官网下载jd-eclipse，地址：http://java-decompiler.github.io/ ） 填写完毕后会加载该插件的相关信息，勾选该插件，一路Next安装下去即可。 重启Eclipse该插件即可生效。 不过安装插件后Eclipse可能继续使用着默认的class查看器，我们可以把它改成我们新安装的jd查看器： Window -\u003e Preference -\u003e General -\u003e Editors -\u003e File Associations 选中*.class文件 -\u003e 将Class File Editor设置为默认(Default) 最后确定修改，无需重启Eclipse即可生效。 新版本的jd-eclipse的类文件查看器名字可能叫做JD Class File Viewer(总之，Class File Viewer是Eclipse自带的类文件查看器，安装插件后会出现新的类文件查看器) ","date":"2018-12-10","objectID":"/posts/add9b646.html/:3:1","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"Enhanced Class Decompiler 3.0.0 上边的反编译插件jd-eclipse可能在安装并修改了class查看器后依然无效，可能是由于Eclipse版本不兼容或者其他的原因，这时候可以安装另一个反编译插件，安装步骤如下： 打开Eclipse -\u003e Help -\u003e Eclipse Marketplace… 在弹窗的搜索框中输入Decompiler，选择安装Enhanced Class Decompiler 3.0.0 安装工程中有Next选Next，中间需要选择接受安装协议，最后点击Finish 安装结束后重启Eclipse生效 ","date":"2018-12-10","objectID":"/posts/add9b646.html/:3:2","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"参考链接 反编译是什么意思 Java反编译工具-JD-GUI jd-eclipse反编译插件的在线安装和使用 关于Eclipse安装了反编译插件,无法查看源码问题 ","date":"2018-12-10","objectID":"/posts/add9b646.html/:4:0","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件","uri":"/posts/add9b646.html/"},{"categories":["Java"],"content":"问题与解决方法 有时候我们的系统会报java.io.NotSerializableException，根据堆栈信息又无法得出有用的信息，无法找到具体是因为哪些类或者变量造成的，可以使用一个java参数-Dsun.io.serialization.extendedDebugInfo=true来得到更加具体的序列化信息。 从jdk6开始就可以使用该参数，可以在启动java程序时启用该参数，也可以在项目的一开始通过代码来启用： System.setProperty(\"sun.io.serialization.extendedDebugInfo\", \"true\"); 下边是stackoverflow上找到的两个回答： ","date":"2018-12-03","objectID":"/posts/a206131b.html/:1:0","tags":["Java"],"title":"如何获取更多关于序列化异常的堆栈信息","uri":"/posts/a206131b.html/"},{"categories":["Java"],"content":"回答其一 From JDK6 you should be able to get extra information by setting the sun.io.serialization.extendedDebugInfo system property: -Dsun.io.serialization.extendedDebugInfo=true ","date":"2018-12-03","objectID":"/posts/a206131b.html/:1:1","tags":["Java"],"title":"如何获取更多关于序列化异常的堆栈信息","uri":"/posts/a206131b.html/"},{"categories":["Java"],"content":"回答其二 Set the system property sun.io.serialization.extendedDebugInfo to true, either by adding-Dsun.io.serialization.extendedDebugInfo=trueto the command line, or add the line System.setProperty(\"sun.io.serialization.extendedDebugInfo\", \"true\"); at the start of your program. If something isn’t serializable, this will cause a trace of the path through the data structure that leads from the “root” object (the one passed to ObjectOutputStream.writeObject()) to the object that’s not serializable. At least, it’ll tell you the class names of the instances and the fields that lead to the non-serializable object. ","date":"2018-12-03","objectID":"/posts/a206131b.html/:1:2","tags":["Java"],"title":"如何获取更多关于序列化异常的堆栈信息","uri":"/posts/a206131b.html/"},{"categories":["Java"],"content":"参考链接 Locating Serialization Issue in Complex Bean cannot find source of NotSerializableException ","date":"2018-12-03","objectID":"/posts/a206131b.html/:2:0","tags":["Java"],"title":"如何获取更多关于序列化异常的堆栈信息","uri":"/posts/a206131b.html/"},{"categories":["JavaWeb"],"content":"需要在filter标签后添加多个filter-mapping标签，一个url-pattern就对应一个filter-mapping标签，不能直接把多个url-pattern配置到同一个filter-mapping标签里，也不能直接把多个url直接配置到一个url-pattern标签里。 正确地配置方式如下所示： \u003cfilter\u003e \u003cfilter-name\u003etest\u003c/filter-name\u003e \u003cfilter-class\u003ecom.test.TestFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003etest\u003c/filter-name\u003e \u003curl-pattern\u003e/test/a/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003etest\u003c/filter-name\u003e \u003curl-pattern\u003e/test/b/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2018-11-25","objectID":"/posts/61154519.html/:0:0","tags":["JavaWeb","web.xml"],"title":"web.xml中一个filter配置多个url-pattern","uri":"/posts/61154519.html/"},{"categories":["常用软件"],"content":"场景 现在有个需求：将Excel里的时间转换为分+秒的格式，如下： time(second) time(min+second) 482.712 XXmin,XXs 480.737 XXmin,XXs 对于这种场景，可以通过Excel的公式来实现。 ","date":"2018-11-22","objectID":"/posts/5be6b2f2.html/:1:0","tags":["常用软件","Excel"],"title":"Excel - 使用公式将秒转换为分+秒","uri":"/posts/5be6b2f2.html/"},{"categories":["常用软件"],"content":"解决方法 假设现在的time(second)是单元格的A1位置，我们需要对A2、A3等等这一列转换到B这一列。先在B1单元格输入以下公式： =INT(A2/60)\u0026\"min,\"\u0026ROUND(MOD(A2,60),0)\u0026\"s\" 输入之后，你会发现该单元格的内容就变成了8min,3s。 这里的INT(a)表示将数值a向下取整为最接近的整数，ROUND(a, b)表示按照b的位数来将a四舍五入，MOD(a, b)表示a除以b的余数，\u0026表示拼接字符串。 现在可以对一个单元格进行公式求值了，接着按住该单元格的右下角，鼠标会变成一个+号，按住不放向其它方向拖动，可以将对应的单元格自动填充该公式。 如果希望在单元格内进行换行，在需要换行的地方按下Alt + Enter组合键即可。 ","date":"2018-11-22","objectID":"/posts/5be6b2f2.html/:2:0","tags":["常用软件","Excel"],"title":"Excel - 使用公式将秒转换为分+秒","uri":"/posts/5be6b2f2.html/"},{"categories":["Eclipse"],"content":"问题分析 @Override注解用来检测子类对父类或接口的方法的重写是否正确，但有一次我在Eclipse里对接口的实现类里使用@Override注解却报错，不过在父类的子类里使用该注解却是正常的。 百度了下才知道原来这是jdk1.5时的一个bug，在1.6时已经被修复；那么问题来了，我使用的jdk是1.8，为什么会报这个错误？明明之前也在接口的实现类里用过该注解，却没问题。由于Eclipse经常抽风，我怀疑是Eclipse的问题，经过排查确实如此，该项目使用的jdk版本不知道为什么变成了jdk1.5，导致出现了注解报错的问题。 ","date":"2018-11-20","objectID":"/posts/f3ccdaa7.html/:1:0","tags":["IDE工具","Eclipse","Java"],"title":"Eclipse - 在接口的实现类里使用@Override注解报错","uri":"/posts/f3ccdaa7.html/"},{"categories":["Eclipse"],"content":"解决方法 右键该项目，选择Properties，将Java Compiler和Java Facets里的jdk版本从1.5改为更高的版本，再刷新下项目重新编译就没问题了。 ","date":"2018-11-20","objectID":"/posts/f3ccdaa7.html/:2:0","tags":["IDE工具","Eclipse","Java"],"title":"Eclipse - 在接口的实现类里使用@Override注解报错","uri":"/posts/f3ccdaa7.html/"},{"categories":["常用软件"],"content":"问题 在win10平台安装了MarkdownPad 2之后，发现在渲染md文件时报错，在预览页面无法正常渲染HTML： markdownpad_error.jpg \" markdownpad_error.jpg 安装报错提示前往官网，可以看到如下的解决方法： LivePreview is not working - it displays an error message stating This view has crashed! This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane. To fix this issue, please try installing the Awesomium 1.6.6 SDK. If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010). ","date":"2018-11-17","objectID":"/posts/511045a6.html/:1:0","tags":["常用软件","MarkdownPad2"],"title":"MarkdownPad - win10环境下无法渲染HTML问题","uri":"/posts/511045a6.html/"},{"categories":["常用软件"],"content":"解决方法 请尝试安装Awesomium 1.6.6 SDK，下载链接：awesomium_v1.6.6_sdk_win.zip 在安装之后依然有这个问题，请安装Microsoft’s DirectX End-User Runtimes (June 2010) ","date":"2018-11-17","objectID":"/posts/511045a6.html/:2:0","tags":["常用软件","MarkdownPad2"],"title":"MarkdownPad - win10环境下无法渲染HTML问题","uri":"/posts/511045a6.html/"},{"categories":["常用软件"],"content":"参考链接 Frequently Asked Questions 升级win10后 MarkdownPad 2 无法实时渲染HTML页面问题 ","date":"2018-11-17","objectID":"/posts/511045a6.html/:3:0","tags":["常用软件","MarkdownPad2"],"title":"MarkdownPad - win10环境下无法渲染HTML问题","uri":"/posts/511045a6.html/"},{"categories":["Java"],"content":"问题与分析 我在本地安装了1.7和1.8两个版本的jdk，此时我的JAVA_HOME环境变量配置的是jdk1.8，在cmd窗口输入java -version发现报错如下： C:\\Users\\Lewis\u003ejava -version Error: Registry key 'Software\\JavaSoft\\Java Runtime Environment'\\CurrentVersion' has value '1.8', but '1.7' is required. Error: could not find java.dll Error: Could not find Java SE Runtime Environment. 接着输入javac -version则是正常： C:\\Users\\Lewis\u003ejavac -version javac 1.8.0_191 javac命令能正常执行， 说明我配置的CLASSPATH变量和JAVA_HOME变量正确。而java命令报错，则说明PATH变量有问题。cmd窗口在执行命令时会去PATH变量的值里寻找路径，当找到对应的路径后就不会再继续查找下去。 所以我们应该把java相关的路径放到PATH变量值的最前面，需要注意的是，如果你安装了Oracle，你会发现Oracle的环境变量会直接排到最前面，也就是说，这时候会优先去Oracle指定的目录下寻找java的命令。 但只是将java路径放置到最前面还是不够的，因为WINDOW本身系统SYSTEM32里面的环境变量加载等级要优先于用户设置的环境变量，所以我们还需要将C:\\Windows\\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名才行。 ","date":"2018-11-17","objectID":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/:1:0","tags":["Java"],"title":"Java - 怎么通过环境变量来切换jdk版本","uri":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/"},{"categories":["Java"],"content":"解决方案 将PATH环境变量的变量值里的java路径放置到最前面； 将C:\\Windows\\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名。 接下来进行测试，会发现java -version得到了正确的结果： C:\\Users\\Lewis\u003ejava -version java version \"1.8.0_191\" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 接着将JAVA_HOME改为jdk1.7的目录，再一次测试java和javac命令，都能得到正确的结果。 ","date":"2018-11-17","objectID":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/:2:0","tags":["Java"],"title":"Java - 怎么通过环境变量来切换jdk版本","uri":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/"},{"categories":["Java"],"content":"参考链接 切换JDK版本时修改JAVA_HOME环境变量不生效 ","date":"2018-11-17","objectID":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/:3:0","tags":["Java"],"title":"Java - 怎么通过环境变量来切换jdk版本","uri":"/posts/Java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/"},{"categories":["Java"],"content":"前言 双十一买了台新的笔记本，需要重新安装下Java，这里记录下安装的过程，毕竟万事开头难，就算是老手也不一定能一次就把Java安装成功。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:1:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"安装jdk 作为一名Java开发，当然是要安装jdk了，如果只是需要Java的运行环境，那么安装jre就足够了。另外说下，jdk里以及包含了jre了。 首先去官网下载Java，由于Sun被Oracle收购了，现在去官网下载Java需要先注册一个Oracle账号，虽然麻烦了点，但是没办法，谁叫Oracle牛逼呢。 由于页面是全英文的，部分同学可能会懵逼，其实没什么，随便找一个版本下载就行。唯一需要注意的是，下载文件之前要先点击一下文件上方的同意协议，否则会提示你还没有同意协议。 接着把下载好的文件启动，一路按照默认配置安装即可。当安装好jdk后，接下来的步骤就是配置环境变量了。不夸张的说，99%的同学都曾经倒在了环境变量的配置上，甚至直接就放弃安装Java了。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:2:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"配置环境变量 环境变量其实就是定义给系统使用的变量，当使用到这些变量时，会自动替换成对应的路径名，以便找到程序或者命令。而环境变量分为用户变量和系统变量，顾名思义，用户变量是给当前的电脑用户使用的，系统变量是所有用户公用的。我们只要配置成用户变量就行，如果你想定义成系统变量也没问题。 配置Java的环境变量其实很简单，一共就三个环境变量： JAVA_HOME PATH CLASSPATH 注意，所有环境变量的变量值都是使用的英文符号！！别写成中文的分号、冒号等符号了！！ ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:3:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"JAVA_HOME 这个变量名指的是Java的安装路径，其实很多程序在安装的时候，都会自动给你新建一个对应的环境变量XXX_HOME。不过Java并没有自动给我们新建该变量，所以需要我们自己来创建。另外很多程序，比如Eclipse、Maven、Tomcat等等，都会使用到这个变量。 新建一个环境变量JAVA_HOME，然后在变量值里输入你的jdk安装路径，比如我的是C:\\Program Files\\Java\\jdk1.7.0_80。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:3:1","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"PATH 这个变量是系统本身就有的，当你在cmd窗口里执行命令的时候就会去这个PATH变量里找到对应的路径，如果找不到就会报错。这一步我们需要在PATH的变量值里加上%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，最好是将这段变量值加在最前面，如果是加在最前面，还需要在末尾加上英文的分号。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:3:2","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"CLASSPATH 这个变量需要我们新建，变量名是CLASSPATH，变量值是.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar，请别在变量值的末尾画蛇添足加上分号。 该变量的作用是用来寻找类文件的路径，如果该变量值不对，就会导致javac命令找不到的错误。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:3:3","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"测试jdk和环境变量 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:4:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"java -version win+R打开运行程序，输入cmd接着回车，在cmd窗口里输入java -version，正常的情况是能得到类似如下的信息： C:\\Users\\Lewis\u003ejava -version java version \"1.7.0_80\" Java(TM) SE Runtime Environment (build 1.7.0_80-b15) Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:4:1","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"javac -version 在cmd窗口里输入javac -version，正常的情况是能得到类似如下的信息： C:\\Users\\Lewis\u003ejavac -version javac 1.7.0_80 这两个命令的区别是，前者是用来执行java程序或者命令的，后者是用来编译java文件的。javac就是指的java compiler。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:4:2","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"win10下的环境变量问题 如果是win10，在配置环境变量时，一般是弹出表格，然后一行一行地输入变量值，而不是像上边那样需要使用英文分号来分隔开。有可能会发生配置好环境变量后，在输入java -version能得到正常的结果，而在输入javac -version后却是显示的： C:\\Users\\Lewis\u003ejavac -version 'javac' 不是内部或外部命令，也不是可运行的程序 或批处理文件。 解决办法很简单，先检查你的JAVA_HOME是否路径正确，是否使用了错误的中文符号等；接着检查另外两个变量是否书写正确。因为win10第一次配置环境变量时是一行一行地在表格里输入的，后面重新打开的时候就变回了win7/8那种格式，你会发现CLASSPATH变量的变量值莫名被加上了双引号(我本人就是属于这种情况)，把双引号去掉后重新保存环境变量；接着关闭原本的cmd窗口，重新打开cmd窗口进行测试，测试成功。 如果依然是一行一行输入变量值的表格形式，需要把分号去掉，然后分成多行各自输入，且末尾不能有英文分号，另外最好把变量值上移到顶端。 注意，如果改变了环境变量，必须要把原本的cmd窗口关掉才行，因为原本的cmd窗口依然使用的是你修改之前的环境变量。 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:5:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"参考链接 java 安装教程 window10下java环境变量的配置 javac不是内部或外部命令的问题 ","date":"2018-11-17","objectID":"/posts/4c4c677.html/:6:0","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量","uri":"/posts/4c4c677.html/"},{"categories":["Java"],"content":"问题分析 Java是向下兼容的，每一个jdk版本都有对应的class版本号(major + minor version numbers)；如果用低版本的jvm去加载高版本jdk编译的类，就会报错：java.lang.UnsupportedClassVersionError 源码中关于这个UnsupportedClassVersionError的注释如下： /** * Thrown when the Java Virtual Machine attempts to read a class * file and determines that the major and minor version numbers * in the file are not supported. * * @since 1.2 */ ","date":"2018-11-12","objectID":"/posts/fd82a4a.html/:1:0","tags":["Java"],"title":"Java - Class版本号和UnsupportedClassVersionError","uri":"/posts/fd82a4a.html/"},{"categories":["Java"],"content":"Java版本对应的Class版本号 Java版本 Class版本 JDK1.0.2 45.0~45.3 JDK1.1 45.0~46.0以下 J2SE1.2 46.0 J2SE1.3 47.0 J2SE1.4 48.0 JavaSE5 49.0 JavaSE6 50.0 JavaSE7 51.0 JavaSE8 52.0 ","date":"2018-11-12","objectID":"/posts/fd82a4a.html/:2:0","tags":["Java"],"title":"Java - Class版本号和UnsupportedClassVersionError","uri":"/posts/fd82a4a.html/"},{"categories":["Java"],"content":"解决方法 把类重新用当前的jdk版本去编译，只要确保jvm的版本比类版本号相同或更高就可以了。 ","date":"2018-11-12","objectID":"/posts/fd82a4a.html/:3:0","tags":["Java"],"title":"Java - Class版本号和UnsupportedClassVersionError","uri":"/posts/fd82a4a.html/"},{"categories":["Java"],"content":"参考链接 Class版本号和Java版本对应关系 ","date":"2018-11-12","objectID":"/posts/fd82a4a.html/:4:0","tags":["Java"],"title":"Java - Class版本号和UnsupportedClassVersionError","uri":"/posts/fd82a4a.html/"},{"categories":["Java"],"content":"前言 最近老大让我修改项目里所有和log有关的代码，之前我也用过log4j、slf4j或者Logback等日志框架/接口，一直以为打印异常信息就是简单地一句log.info()或者log.error()而已，没想到原来一直都使用错了，以至于有些错误信息没能在log文件中打印出堆栈信息，最终难以定位bug，排查困难。 ","date":"2018-11-11","objectID":"/posts/ea188909.html/:1:0","tags":["Java"],"title":"如何正确地打印异常堆栈信息","uri":"/posts/ea188909.html/"},{"categories":["Java"],"content":"如何正确地打印异常的堆栈信息？ 一般在catch到异常的时候，不要使用e.printStackTrace()来打印异常信息。我们使用日志框架来打印信息，一般来说，日志框架的log级别从低到高是：debug, info, warn, error, fatal。 对于异常，一般使用log.error()来打印堆栈信息。下边的三个log语句都打印了异常，但是写法却不一样，打印出来的效果也是不同的： log.error(\"ERROR\", \"Error found: \", e); log.error(\"ERROR\", \"Error found: \" + e.getMessage()); log.error(\"ERROR\", \"Error found: \" + e); 以下边的代码为例： try { System.out.println(1/0); } catch (final Exception e) { log.error(\"ERROR\", \"Error found: \", e); log.error(\"ERROR\", \"Error found: \" + e.getMessage()); log.error(\"ERROR\", \"Error found: \" + e); } 在log文件中可以发现输出是这样的： 2018-11-09 11:46:34,834 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero at com.lewis.test.TestLewis.main(TestLewis.java:46) 2018-11-09 11:46:34,837 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: / by zero 2018-11-09 11:46:34,838 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero 对于第一个log语句，可以看到堆栈信息被打印了出来。 对于第二个log语句，只是打印出了异常的具体信息，既没有异常类名，也没有堆栈信息。 对于第三个log语句，打印出了异常的类名和具体信息，但是没有打印出来堆栈信息。 总结一下，就是我们应该使用第一种log语句的形式来将堆栈信息打印出来，方便日后定位bug，排除错误。 ","date":"2018-11-11","objectID":"/posts/ea188909.html/:2:0","tags":["Java"],"title":"如何正确地打印异常堆栈信息","uri":"/posts/ea188909.html/"},{"categories":["Git"],"content":"场景 我在本地有个代码仓库local-A，本地仓库local-A已经和一个远程仓库remote-A关联了。 接着我又在GitHub上新建了一个仓库remote-B，我希望将本地仓库local-A的本地dev分支push到这个新建的远程库remote-B。我的想法是这样的： 在本地仓库local-A里添加刚刚新建的远程库remote-B 检出(check out)并切换到remote-B的master分支 将本地dev分支merge到当前的master分支 解决可能发生的冲突后，将改动全部commit并push到远程库remote-B的master分支上 接着当我做到第三步的时候，发现报错如下： Merge: refusing to merge unrelated histories 看到报错，我又重新操作了一遍，依然是同样的错误。记得以前我也做过类似的操作，但是却没有现在的问题，百度了下，发现可能是git升级之后造成的。 ","date":"2018-10-28","objectID":"/posts/f25652af.html/:1:0","tags":["Git","版本控制工具"],"title":"Git - Merge: refusing to merge unrelated histories","uri":"/posts/f25652af.html/"},{"categories":["Git"],"content":"解决方案 因为两个仓库是不同的项目(本地仓库已经跟踪了另外一个远程库了)，git默认不允许不相干的项目进行push等操作。如果想要进行这些操作，就需要加入--allow-unrelated-histories参数才可以合并两个不同的项目： git merge --squash dev --allow-unrelated-histories 这句命令表示将dev分支合并到当前分支，这里的两个本地分支各自追踪不同的远程库，需要加入--allow-unrelated-histories参数才能够完成合并操作而不报错，至于--squash参数是为了压缩dev分支原本的commit历史，可以将原本所有的commit历史合成一个commit，以避免当前分支在合并之后掺入了其他项目的commit历史。 ","date":"2018-10-28","objectID":"/posts/f25652af.html/:2:0","tags":["Git","版本控制工具"],"title":"Git - Merge: refusing to merge unrelated histories","uri":"/posts/f25652af.html/"},{"categories":["Git"],"content":"参考链接 如何去解决fatal: refusing to merge unrelated histories git merge –no-ff是什么意思 ","date":"2018-10-28","objectID":"/posts/f25652af.html/:3:0","tags":["Git","版本控制工具"],"title":"Git - Merge: refusing to merge unrelated histories","uri":"/posts/f25652af.html/"},{"categories":["Eclipse"],"content":"问题与分析 最近开始学习spring-boot框架，我用的是Eclipse，然后发现在使用到了lombok的@Data注解时，Eclipse会编译错误。@Data的作用是自动生成toString方法和setter/getter方法，可以减少大量重复性的代码工作。 另外在使用了@Slf4j注解时，这个注解可以自动为当前类生成一个log变量，即：rivate final Logger logger = LoggerFactory.getLogger(XXX.class);。然而Eclipse无法识别log变量，会报log变量未声明的错误。 一开始我以为是没导入包或者漏了jar包，但是检查一番后没有问题。百度了下才知道，原来除了导包之外，还需要为Eclipse安装该lombok插件。 ","date":"2018-10-24","objectID":"/posts/eea0b72e.html/:1:0","tags":["IDE工具","Eclipse","lombok"],"title":"Eclipse - lombok的@Slf4j和@Data无效","uri":"/posts/eea0b72e.html/"},{"categories":["Eclipse"],"content":"解决方法 安装方法很简单，找到你导入的lombok的jar包，双击运行该jar包，会出现一个安装界面。或者右键jar包，选择打开方式，接着选择Java (TM) Platform SE binary，会出现安装界面。 在安装界面选择当前的Eclipse进程，或者点击左下角的Specify location...选择你要安装插件的Eclipse，接着点右下角的Install / Update，很快就安装完毕，点击Quit Installer。 lombok的下载地址：https://projectlombok.org/downloads/lombok.jar ","date":"2018-10-24","objectID":"/posts/eea0b72e.html/:2:0","tags":["IDE工具","Eclipse","lombok"],"title":"Eclipse - lombok的@Slf4j和@Data无效","uri":"/posts/eea0b72e.html/"},{"categories":["Eclipse"],"content":"问题补充 当我安装好lombok之后，Eclipse虽然能够正常识别@Slf4j注解生成的log变量，但@Data注解依然无效。在使用到了pojo类的私有变量时，依然会提示说缺少setter/getter方法。折腾了好久，才发现原来是因为Eclipse自动给我的pojo类的私有变量加上final修饰符，导致setter/getter方法注入失败了。 把pojo类的私有变量前边的final去掉后，@Data终于生效了。之所以会自动给变量加上final修饰符，是因为我设置了Save Action，Eclipse会自动在我保存代码的时候自动在私有变量、局部变量前加上final修饰符，这个是公司制定的代码编程规范。 ","date":"2018-10-24","objectID":"/posts/eea0b72e.html/:3:0","tags":["IDE工具","Eclipse","lombok"],"title":"Eclipse - lombok的@Slf4j和@Data无效","uri":"/posts/eea0b72e.html/"},{"categories":["Hexo"],"content":"问题与分析 今天发现在使用hexo g时报错如下： FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Template render error: unexpected token: }} 一时间很诧异，因为前几天还可以正常生成静态文件，今天忽然就挂了。看看报错的信息，说是模板渲染失败，因为出现了预期外的标志。因为我刚刚写了新的文章，就出现了这个错误，可以想象到，应该是文章中出现了特殊字符导致hexo命令执行失败了。 百度了下，确实如此。因为在Hexo中，有些特殊字符如果不进行转义的话，在渲染模板时就会报错。 ","date":"2018-10-23","objectID":"/posts/2a5ffb7e.html/:1:0","tags":["Hexo"],"title":"Hexo - Template render error unexpected token","uri":"/posts/2a5ffb7e.html/"},{"categories":["Hexo"],"content":"解决方法 如果遇到类似的报错，解决方法很简单，就是对这些特殊字符进行转义，需要使用转义标签来将这些特殊字符包括起来，如下： {% raw %} 特殊字符 {% endraw %} 比如我的报错是因为使用{% raw %}}}{% endraw %}，那么就需要对这对大括号进行转义： {% raw %} {{ something... }} {% endraw %} 如果是在引用块里，可以随便使用特殊字符；如果是行内引用块，就需要进行转义了。 ","date":"2018-10-23","objectID":"/posts/2a5ffb7e.html/:2:0","tags":["Hexo"],"title":"Hexo - Template render error unexpected token","uri":"/posts/2a5ffb7e.html/"},{"categories":["Hexo"],"content":"参考链接 Hexo的一个小BUG(Template render error) Hexo 异常 - Template render error unexpected token ","date":"2018-10-23","objectID":"/posts/2a5ffb7e.html/:3:0","tags":["Hexo"],"title":"Hexo - Template render error unexpected token","uri":"/posts/2a5ffb7e.html/"},{"categories":["Java"],"content":"前言 最近debug时忽然发现，如果一个集合赋值为null，那么对该集合进行foreach循环(也叫增强for循环)时，会报NPE(即空指针异常NullPointerException)。 代码如下： final List\u003cString\u003e list = null; // final List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (final String string : list) { System.out.println(string); } 运行时报错如下： Exception in thread \"main\" java.lang.NullPointerException at com.lewis.test.TestLewis.main(TestLewis.java:42) 一时间很惊奇，因为在我印象中，foreach循环在遇到null的集合时，应该是会自动跳过去不进行遍历的才对。于是修改代码如下： //final List\u003cString\u003e list = null; final List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (final String string : list) { System.out.println(string); } 运行后发现没有报错，看来是以前记错了。foreach循环只会自动跳过遍历空的集合，如果对于null值的集合，就会直接报NPE。 ","date":"2018-10-14","objectID":"/posts/fba3f254.html/:1:0","tags":["Java"],"title":"Java - foreach循环报NPE空指针异常","uri":"/posts/fba3f254.html/"},{"categories":["Java"],"content":"解决方法 在写业务逻辑时难免会遇到遍历集合的情况，这时候应该先判断集合是否为null再进行遍历，可以使用Apache的工具类CollectionUtils。 另外补充下，foreach循环内部是使用的迭代器来遍历，也就是说，这种遍历方式和使用迭代器来遍历是一样的。 ","date":"2018-10-14","objectID":"/posts/fba3f254.html/:2:0","tags":["Java"],"title":"Java - foreach循环报NPE空指针异常","uri":"/posts/fba3f254.html/"},{"categories":["Hexo写作系列"],"content":"前言 NexT主题会自动为每一篇文章生成目录，这个目录可以通过配置来控制是否生成对应的序号。毕竟有时候我们会给文章的小标题写上序号，有时候又会懒得去写，这个时候这个配置就很重要了。 有两种方法来实现这个效果，一种是全局生效，一种是对具体某篇文章生效。 ","date":"2018-09-06","objectID":"/posts/99e0f22b.html/:1:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(2) - 如何令文章目录显示序号","uri":"/posts/99e0f22b.html/"},{"categories":["Hexo写作系列"],"content":"全局生效 在NexT的主题配置文件 _config.yml中启用如下配置： # Table Of Contents in the Sidebar # 侧栏文章目录设置 toc: enable: true # Automatically add list number to toc. # 自动为文章目录添加行号 number: true 设置为true后就可以对站点下所有文章自动添加序号，如果想取消这个功能，再设置为false即可。 ","date":"2018-09-06","objectID":"/posts/99e0f22b.html/:2:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(2) - 如何令文章目录显示序号","uri":"/posts/99e0f22b.html/"},{"categories":["Hexo写作系列"],"content":"对具体某篇文章生效 如果你在文章的小标题中已经使用了序号，那么自动为文章目录添加序号的功能会导致你的文章目录出现了赘余的序号，解决方法很简单，在你的文章的文件头添加一行代码即可，如下： --- title: XXX date: XXX toc_number: false --- 这样这篇文章就不会被自动添加序号到文章目录里了。 ","date":"2018-09-06","objectID":"/posts/99e0f22b.html/:3:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(2) - 如何令文章目录显示序号","uri":"/posts/99e0f22b.html/"},{"categories":["Hexo写作系列"],"content":"前言 本系列主要介绍和hexo-NexT主题相关的一些写作技巧，可能会涉及到部分前端知识(不了解也没关系，能用就行)。我之所以选择hexo-NexT来搭建个人网站，一个很重要的原因就是因为简单、方便、快捷！不需要服务器，直接通过Markdown来进行写作，不仅文章布局美观，还可以节省大量的时间。 我一般不会在文章中手动加入各种html标签，因为太麻烦了–而NexT主题就很贴心地自带了一些样式，让你可以不需要自己写一大堆html标签就能得到美观的页面效果。 本系列针对的是NexT 5.1.4版本的样式，请到我的个人站点更加直观地看到页面效果，不便之处还请见谅。 -\u003e这是本文在个人站点的链接\u003c- ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:1:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"文本居中引用 该样式可以将一段文本居中显示，并在首尾各自生成一个引号图片，效果如下： hexo-write-1.jpg \" hexo-write-1.jpg 源码如下： {% cq %} 人类的本质是复读机。 ——**复读机** {% endcq %} 原本该样式的字体是黑色的，我把它改成红色了。这里的cq是标签别名，也可以用完整的标签名： {% centerquote %} 人类的本质是复读机。 ——**复读机** {% endcenterquote %} ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:2:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"图片突破容器宽度限制 使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。效果如下： 附上一张wlop大大的saber~ hexo-write-2.jpg \" hexo-write-2.jpg 使用方式如下： {% fullimage /image-url, alt, title %} \u003c!-- 别名 --\u003e {% fi /image-url, alt, title %} 这里的alt和title可以不写，alt属性是找不到图片时显示的文本，title是鼠标停留在图片上时显示的文本。 ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:3:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"Note标签 本标签出自于Bootstrap，使用前需要先启用主题配置文件： # 主题自带的标签样式，有 note、label、tabs 三种# Note tag (bs-callout).note:# Note tag style values:# - simple bs-callout old alert style. Default.# - modern bs-callout new (v2-v3) alert style.# - flat flat callout style with background, like on Mozilla or StackOverflow.# - disabled disable all CSS styles import of note tag.# Note标签的样式有四种：# - simple：默认的样式，也是Bootstrap Callout旧版本的样式。# - modern：Bootstrap Callout新版本(v2-v3)的样式。# - flat：该样式会连同背景也一起渲染，如同Mozilla或者StackOverflow那样。# - disabled：禁用本Note标签。style:flaticons:trueborder_radius:3# Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).# Offset also applied to label tag variables. This option can work with disabled note tag.light_bg_offset:0 效果如下： hexo-write-3.jpg \" hexo-write-3.jpg Note标签一共有以上六种类型：default,primary,success,info,warning,danger，源码如下： {% note default %}default{% endnote %} {% note primary %}primary{% endnote %} {% note success %}success{% endnote %} {% note info %}info{% endnote %} {% note warning %}warning{% endnote %} {% note danger %}danger{% endnote %} ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:4:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"Label标签 使用前同样需要启用配置： # Label tag.label:true 效果如下： hexo-write-4.jpg \" hexo-write-4.jpg 和Note标签一样，同样是六种类型。@前面是类型，@后面是显示的文本内容。这个label标签的样式并不好看，我基本不用。 ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:5:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"Tab标签 这个标签和浏览器的tab是类似的，使用前也需要启用配置： # Tabs tag.tabs:enable:truetransition:tabs:truelabels:trueborder_radius:3 效果如下： hexo-write-5.jpg \" hexo-write-5.jpg 源码如下： {% tabs 贴吧, 1 %} \u003c!-- tab android开发吧 --\u003e 有问题为什么不先问问隔壁Java吧呢？ \u003c!-- endtab --\u003e \u003c!-- tab java吧 --\u003e 有问题为什么不先问问隔壁C++吧呢？ \u003c!-- endtab --\u003e \u003c!-- tab c++吧 --\u003e 有问题为什么不先问问隔壁C语言吧呢？ \u003c!-- endtab --\u003e \u003c!-- tab c语言 --\u003e 有问题为什么不先问问神奇海螺吧呢？ \u003c!-- endtab --\u003e \u003c!-- tab 神奇海螺 --\u003e 有问必答不知道 \u003c!-- endtab --\u003e {% endtabs %} 简单介绍下常规用法： 源码第一行的数字表示默认显示哪一个tab页面，如果是-1则表示隐藏所有tab页面内容。 如果不为每个tab单独制定名字，则会以第一行源码的名字为每个tab命名，并自动在名字后加上1,2,3...以示区分。 tab的名字支持fontawesome图标，使用方法是@加上图标的名字，例如@home，注意该图标需要添加在tab名字的最后，渲染时图标会自动放在名字最前面，比如：\u003c!-- tab android开发吧@home --\u003e 更多用法可以参考该文章 ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:6:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"按钮标签样式 这个样式和阅读全文那个按钮一样，效果如下： hexo-write-6.jpg \" hexo-write-6.jpg 源码如下： {% btn https://www.baidu.com, 点击前往百度, download fa-lg fa-fw %} 更多用法可以参考该文章 此外还有其他的标签样式的使用方法，请参考下边的连接文章。 ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:7:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo写作系列"],"content":"参考链接 官方文档：内置标签 - NexT 使用文档 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 样式汇总 ","date":"2018-09-05","objectID":"/posts/38eb04fa.html/:8:0","tags":["Hexo写作系列","NexT主题"],"title":"Hexo写作系列(1) - NexT主题自带的样式","uri":"/posts/38eb04fa.html/"},{"categories":["Hexo瞎折腾系列"],"content":"前言 Hexo的NexT主题本身就集成了一些评论系统，多说啊之类的已经关闭服务的略过不提，目前比较多人用的有畅言、来必力livere、Gitment、Gitalk、Disqus等。 我刚用的评论系统的时候，网易云跟贴和多说已经gg了，畅言需要备案，Disqus需要FQ，Gitment和Gitalk类似，都需要GitHub账号。经过搜集资料和考虑，我最终还是决定使用Gitment。只是在用了一段时间后，终于还是放弃了Gitment，转而使用来必力livere。 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"Gitment的优缺点 最初我选择使用Gitment的原因如下： Gitment是一个基于GitHub的issue来开发的评论插件，本身很有创意，对于我这种没事看看GitHub的也很有吸引力。 使用Gitment进行评论需要有GitHub账号，这无形中过滤掉了一些评论者，毕竟不是谁都有GitHub账号的，也不是谁都能登陆上GitHub的。 GitHub的评论数据存放在GitHub的issue里，基本不用担心数据丢失或者GitHub关闭服务，毕竟GitHub可是全球最大同性交友社区(滑稽)。 当我美滋滋地享受了Gitment一段时间后，开始发现一些问题： GitHub是个神奇的网站，有时候会登陆不上去，这导致我的个人站点加载页面时无法把Gitment加载出来，这使得我的页面长时间处于一片空白的状态，用户体验极差，而且最后页面加载出来了，Gitment评论模块依然没有加载出来。 我希望我的站点可以不分国界，所以我将站点分别部署到了Coding.net和GitHub上，这样可以国内外都快速访问到站点(这个需要域名才能实现)。由于国内有些地区在有些时段是无法访问到GitHub的，这将导致我的页面长时间假死。 Gitment的使用太繁琐，每一篇文章都必须先初始化一遍，才能使用评论系统，如果你有一百篇文章，你就需要手动初始化一百次！虽然后来有脚本一键初始化，但还是很麻烦。 issue的滥用。因为Gitment是建立的issue之上的，当你的文章越来越多，你会发现你的站点仓库里的issue会越来越多，这就不太友好了。 综上所述，我还是放弃了Gitment，转投了来必力的怀抱。 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"Gitment使用流程 虽然现在没有使用Gitment了，但这里还是记录下当初遇到的问题，方便回顾或者大家解决类似的困难。 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"安装模块 使用Gitment需要安装模块： npm i --save gitment ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:3:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"申请应用ID与密钥 因为Gitment需要GitHub的授权，所以需要先去New OAuth App申请一个密钥，需要填写的内容如下： Application name:随便写 Homepage URL:这个也可以随意写,就写你的博客地址就行 Application description:描述,也可以随意写 Authorization callback URL:这个必须写你的博客地址 这里只有最后一个callback必须写准确，申请成功后你可以看到ClientID和Client Secret，这个会被使用到，另外注意不要把这个ID和密钥告诉别人– ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:3:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"在主题配置文件中启用 # Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment:enable:truemint:true# RECOMMEND, A mint on Gitment, to support count, language and proxy_gatewaycount:true# Show comments count in post meta arealazy:false# Comments lazy loading with a buttoncleanly:false# Hide 'Powered by ...' on footer, and morelanguage:# Force language, or auto switch by themegithub_user:{yougithubuserid}github_repo:随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issueclient_id:{刚才申请的ClientID}client_secret:{刚才申请的ClientSecret}proxy_gateway: # Address of api proxy, See:https://github.com/aimingoo/intersectredirect_protocol:# Protocol of redirect_uri with force_redirect_protocol when mint enabled 这里的配置，只有github_user，github_repo，client_id，client_secret是必须填准确的，其他的可以不使用。 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:3:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"初始化Gitment 到这里为止已经全部配置完毕，接下来只需要登陆你的个人站点，然后手动给每篇文章初始化Gitment就行了。初始化也很简单，打开每篇文章，在下方的评论模块那里点一下初始化就行，以后就可以直接评论了。据说由一键初始化所有文章的脚本，我没用过，不清楚。 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:3:4","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"Gitment踩坑记录 这里说一下当初折腾了我很久的一个地方，在主题配置文件里有个github_user，这个由于注释写的是Your Github ID，我误以为是要填写的不是用户昵称，而是一串数字id。于是就去了GitHub的api里查看了自己的id，然后填了一串数字进去，之后花费了我几个小时的时间，始终有授权失败的错误，最后终于发现，这个ID其实是要填的用户昵称…orz GitHub的api地址：https://api.github.com/users/xxx 把这里的xxx随便改成某个用户名，可以拿到对方的json数据，里边有各种用户首页上的数据信息。 更多Gitment踩坑相关的文章可以参考：Gitment评论功能接入踩坑教程 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:4:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"来必力livere的使用 来必力的使用就简单多了，直接去官网注册个账号，拿到来必力City版安装代码里的data-uid，把这个uid填写到主题配置文件里的livere_uid后就行，记得id要和前边的冒号之间有一个空格，否则在启用hexo服务的时候会解析出错。 这样我们的来必力就使用成功了，平时可以去来必力的后台系统查看站点的评论数据等。 如果不会注册安装来必力的，可以看看这篇文章 ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:5:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"参考链接 Hexo 使用Gitment评论功能 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件 添加网易云跟帖(跟帖关闭，已失效，改为来必力) ","date":"2018-09-05","objectID":"/posts/ec12c039.html/:6:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(8) - 添加评论系统","uri":"/posts/ec12c039.html/"},{"categories":["Hexo瞎折腾系列"],"content":"问题 今天我的个人站点SSL/TLS证书到期，我的证书是由Coding Pages提供的，每次申请成功后有效期是三个月，证书到期后可以继续免费申请。但是当我登陆进入Coding Pages服务的后台并点击申请证书时，竟然报错了！！ 我重新点了申请，几秒后依然报错，并提示我半小时只能申请一次。我查看了下报错的提示信息，如下： urn:acme:error:unauthorized:Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx 一时间也不明白是怎么回事，因为我第一次申请的时候不用几秒钟就成功了，由于报错信息中包含了本静态博客的部署时间，我以为可能存在部署时间的校验，于是重新部署了一下，半小时后继续申请，依然报同样的错误。 好吧，有事就问度娘，百度了一下，发现了Coding Pages的官方文件：Coding Pages 常见问题 这时候按照官方文件的指引，找到了和我一样的错误信息的解决方案： 错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 因为Coding Pages的静态Pages是免费的，而动态Pages是收费的，对于用Hexo搭建的静态站点，自然是选择免费的静态Pages服务就足够了。于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"分析 由于我的个人站点是同时部署到GitHub Pages和Coding Pages上的，接着在阿里云域名解析里进行了配置：默认的解析线路将我的域名指向pages.coding.me，国外的解析路线则是指向了lewky.github.io。 之所以这样配置，是因为国内部分地区无法直接访问GitHub，自然就无法访问我部署在GitHub上的个人站点，于是我又选择了Coding.net的Pages服务，这样国内用户就可以快速访问到我部署在Coding Pages的个人站点，而国外用户则是快速访问到Coding Pages上的个人站点。 问题就出现在这里，因为我第一次申请SSL/TLS证书的时候，还没有解析境外的线路，所以很快就申请成功了。后来添加了国外线路的解析，这导致在Coding Pages的后台申请证书时无法通过验证，自然就申请失败了。 分析到这里，我也基本知道怎么解决这个错误了。 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"解决方法 由于我是在阿里云购买的域名，于是登陆到阿里云域名解析的后台系统，打开个人域名的解析设置，暂停对于境外线路的解析。这里暂停就行了，一般来说大概需要5分钟左右的生效时间，毕竟DNS解析是存在缓存的。 五分钟后，我又进入Coding Pages服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后我申请证书成功，又给续了三个月。 最后，再次返回阿里云域名解析的后台，将境外解析的线路再次启用，嗯，完美。 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"其他的申请错误 这里罗列下申请证书时所有可能遇到的错误与解决方案，以备不时之需。 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:connection 1、错误信息：DNS problem: NXDOMAIN looking up A for example.com 错误原因：域名不存在 解决方式1：检查域名是否填写正确 解决方式2：到域名注册商处检查是否设置了 DNS 服务器 解决方式3：咨询 DNS 服务商是否支持解析该域名 2、错误信息：DNS problem: SERVFAIL looking up A for exmaple.com 错误原因：DNS 解析 A 记录出错 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求 3、错误信息：DNS problem: SERVFAIL looking up CAA for example.com 错误原因：DNS 解析 CAA 记录出错 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否支持解析 CAA 记录 4、错误信息：DNS problem: query timed out looking up A for exmaple.com 错误原因：DNS 解析超时 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求 解决方式3：重新申请 解决方式4：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 5、错误信息：Fetching http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxx 错误原因：获取域名验证信息失败 解决方式1：重新申请 解决方式2：请确认是否启动了 DNS 的分区解析。如果有则要把国外的解析记录也设置成 CNAME 至 pages.coding.me。SSL 证书是通过 Let’s Encrypt API 申请。申请证书前需要验证域名，而 Let’s Encrypt 位于国外，所以需要保证 Let’s Encrypt 能通过您的域名正常访问到 Coding Pages 服务器以读取验证信息。 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:malformed 错误信息：Error creating new authz :: Name does not end in a public suffix 错误原因：域名不以公共后缀结尾 解决方式：咨询域名注册商 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:unauthorized 1、错误信息：Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx 错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 2、错误信息：The key authorization file from the server did not match this challenge 错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 3、错误信息：Error creating new authz :: “example.com” was considered an unsafe domain by a third-party API 错误原因：无法获取正确的域名验证信息 解决方式：使用 https://transparencyreport.google.com/safe-browsing/search 查看域名存在的安全隐患，按照说明进行清理，清理完后到 https://www.stopbadware.org/ 提交审查请求。审查通过后，回到 Coding Pages 重新申请证书 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:unknownHost 错误信息：No valid IP addresses found for example.com 错误原因：找不到可用 IP 地址 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 解决方式3：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:4","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:rateLimited 错误信息：Error creating new cert :: too many certificates already issued for exact set of domains: example.com 错误原因：证书申请数目超出限制 解决方式：下周再重新申请，详情见 https://letsencrypt.org/docs/rate-limits/ ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:5","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"错误类型：urn:acme:error:rejectedIdentifier 错误信息：Error creating new authz :: Policy forbids issuing for name 错误原因：相关政策禁止为此域名签发证书 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:4:6","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"参考链接 Coding Pages的官方文件：Coding Pages 常见问题 ","date":"2018-09-03","objectID":"/posts/7ac531d2.html/:5:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(7) - Coding Pages申请SSL/TLS证书错误","uri":"/posts/7ac531d2.html/"},{"categories":["Eclipse"],"content":"问题与分析 最近遇到个奇怪的问题，在Eclipse里对一个Maven项目进行Update Project(快捷键是 Alt+F5)，原本jdk为1.8的项目忽然就变成了1.5，于是就报了一些错误。 我猜想可能跟Maven默认的jdk版本有关系，百度了下，确实如此，Maven项目如果不指定编译的jdk版本，就会默认为jdk1.5。查了下项目的pom文件，里边并没有指定编译的jdk版本，而Maven的配置文件settings.xml里也没有指明jdk版本，所以当我Update Project后，这个Maven项目就会自动变成jdk1.5了。 ","date":"2018-09-02","objectID":"/posts/519a131c.html/:1:0","tags":["IDE工具","Eclipse","Maven"],"title":"Eclipse - Maven项目Update Project后jdk版本变成1.5","uri":"/posts/519a131c.html/"},{"categories":["Eclipse"],"content":"解决方法 有两种解决方法，一种是针对某个Maven项目而言，直接在pom文件中指明jdk版本；一种是全局设置，为所有Maven项目指明jdk版本。 ","date":"2018-09-02","objectID":"/posts/519a131c.html/:2:0","tags":["IDE工具","Eclipse","Maven"],"title":"Eclipse - Maven项目Update Project后jdk版本变成1.5","uri":"/posts/519a131c.html/"},{"categories":["Eclipse"],"content":"在pom文件中指明jdk版本 在项目的pom.xml中的build节点里使用maven的编译插件来指定jdk版本，项目中通常使用这种方法来指定，因为比较灵活，可以随意指定版本，修改保存后即可生效。 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1\u003c/version\u003e \u003cconfiguration\u003e \u003cencoding\u003eUTF-8\u003c/encoding\u003e \u003csource\u003e1.8\u003c/source\u003e \u003ctarget\u003e1.8\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e ","date":"2018-09-02","objectID":"/posts/519a131c.html/:2:1","tags":["IDE工具","Eclipse","Maven"],"title":"Eclipse - Maven项目Update Project后jdk版本变成1.5","uri":"/posts/519a131c.html/"},{"categories":["Eclipse"],"content":"修改settings.xml文件 找到Maven的安装路径，打开conf\\settings.xml，找到profiles节点，在该节点下添加一个profile节点： \u003cprofile\u003e \u003cid\u003ejdk-1.8\u003c/id\u003e \u003cactivation\u003e \u003cjdk\u003e1.8\u003c/jdk\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cmaven.compiler.compilerVersion\u003e1.8\u003c/maven.compiler.compilerVersion\u003e \u003c/properties\u003e \u003c/profile\u003e 使用这种方法的好处是所有Maven项目都会按照这里的jdk版本来编译，当然如果在pom文件里也指定了jdk版本，则以pom里的为准。这种全局修改的方法必须要重启Eclipse才有效果。 个人建议就算是修改了全局配置，也要在每个Maven项目里指明jdk版本，这是种良好的规范，利于别人理解。 ","date":"2018-09-02","objectID":"/posts/519a131c.html/:2:2","tags":["IDE工具","Eclipse","Maven"],"title":"Eclipse - Maven项目Update Project后jdk版本变成1.5","uri":"/posts/519a131c.html/"},{"categories":["Eclipse"],"content":"参考链接 maven 修改默认的JDK版本 Maven管理项目的时候 Update Project后jre变成1.5 ","date":"2018-09-02","objectID":"/posts/519a131c.html/:3:0","tags":["IDE工具","Eclipse","Maven"],"title":"Eclipse - Maven项目Update Project后jdk版本变成1.5","uri":"/posts/519a131c.html/"},{"categories":["文本编辑器"],"content":"显示文件标签栏 view -\u003e views/lists -\u003e open Files Tabs ","date":"2018-09-02","objectID":"/posts/a39d8a42.html/:1:0","tags":["常用软件","文本编辑器","UltraEdit"],"title":"UltraEdit - 怎么显示文件标签栏和侧边栏","uri":"/posts/a39d8a42.html/"},{"categories":["文本编辑器"],"content":"显示侧边栏 view -\u003e views/lists -\u003e File Tree View ","date":"2018-09-02","objectID":"/posts/a39d8a42.html/:2:0","tags":["常用软件","文本编辑器","UltraEdit"],"title":"UltraEdit - 怎么显示文件标签栏和侧边栏","uri":"/posts/a39d8a42.html/"},{"categories":["文本编辑器"],"content":"参考链接 ultraEdit打开多个页面时 怎样显示页面标签 ","date":"2018-09-02","objectID":"/posts/a39d8a42.html/:3:0","tags":["常用软件","文本编辑器","UltraEdit"],"title":"UltraEdit - 怎么显示文件标签栏和侧边栏","uri":"/posts/a39d8a42.html/"},{"categories":["Hexo瞎折腾系列"],"content":"前言 由于本人只是将Hexo博客同时部署到 Github 和 Coding.net ，所以这里只介绍怎么同时部署到这两个网站的pages。 之所以选择这两个网站，是因为国外用户可以访问 Github，而国内用户可以访问 Coding.net。另外，Coding.net可以拥有自己的私人仓库。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"修改站点配置文件 在站点根目录下找到 _config.yml文件，将里边的deploy节点修改成下边的形式： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github: git@github.com:{username}/{repository}.git,master coding: git@git.coding.net:{username}/{repository}.git,master 将上边的仓库url的{username}/{repository}改成自己的项目地址，这里使用的是SSH协议的Git仓库地址，即： git@{domain}:{username}/{repository}.git 还有一种是HTTPS协议的Git仓库地址，即： https://{domain}/{username}/{repository}.git 一般推荐使用SSH协议的地址，因为可以免去每次push都要输入账号密码的繁琐，而且也够安全。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"在 Github 和 Coding.net 上各自创建一个仓库 如果我们只是将项目部署到某一个代码托管站点而已，那么该项目仓库的名字可以随便起；但是现在我们需要将项目同时部署到 Github 和 Coding.net 上，那就不能随意命名了。 我们需要采用特定的命名方式，才能正确将Hexo博客同时部署到这两个站点上；否则很可能会导致只有博客的主页能访问到，而其他的路径全部失效。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"仓库的命名 对于 Coding.net，你可以选择建立一个私人仓库来部署自己的Hexo博客，不过和 Github 不同的地方在于： Github 的仓库名要命名为： {username}.github.io 而 Coding.net 的仓库名要命名为： {username} 这里的 username 指的是你在这两个网站上的用户名，只有以这种命名形式的仓库，才能够不通过子域名的形式来访问我们的博客。 比如说，我的 Github 和Coding.net 的账号都是lewky，那么在部署博客成功后，我就可以通过下边的url来访问我的Hexo博客： https://lewky.github.io/ https://lewky.coding.me/ 如果将仓库名命名为其他的形式，比如：hexo-blog，那么要访问该博客，就需要输入下边的url： https://lewky.github.io/hexo-blog https://lewky.coding.me/hexo-blog 这里的仓库名hexo-blog就变成了子域名，于是问题就来了，对于存在子域名的Hexo博客，需要在站点配置文件里配置url节点： # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://yoursite.com root: / permalink: :year/:month/:day/:title/ permalink_defaults: 如果不配置这里的url节点，会导致除了首页以外的所有页面都请求404；但是我们由于是同时部署在两个网站上，其父域名是不一样的，那么这里的url节点也就只能配置一个而牺牲另一个了；但是如果你有自己的域名，就可以解决这个问题了：直接在这里配置自己的域名就行了。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:3:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"配置 SSH key ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:4:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"创建RSA密钥对 使用 Git Bash 生成RSA密钥对： ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 看到提示就按一次回车，在连续三次回车后，就表示创建成功了。 接着将 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:4:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"Github 配置 SSH key 登陆 Github 的账号： 进入 Settings 页面 选择 SSH and GPG keys 点击 New SSH key 填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来） 然后在 Key 里将我们刚刚复制的公钥复制进去 最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:4:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"Coding.net 配置 SSH key Coding.net 和 Github 有些不一样，Coding.net存在账户公钥和部署公钥； 账户公钥配置后拥有账户下所有项目的读写权限 部署公钥配置后默认拥有该项目的只读权限，如果需要获取推送权限，需要勾选部署公钥设置里的『授予推送权限』 登陆 Coding.net 的账号： 进入个人设置 选择 SSH 公钥 选择新增公钥 填写公钥名称和内容 添加后输入输入账号密码进行确认 ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:4:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"验证 SSH 连接 使用 Git Bash 输入： ssh -T git@github.com 第一次连接时会问你是否继续连接，输入 yes 即可；接下来验证 Coding.net 的ssh连接： ssh -T git@git.coding.net 同样输入 yes 即可。 如果按照前边说的来配置，这里的 SSH 验证应该都是没问题的。 接下来只要撰写博文，然后使用命令进行部署就行了： hexo clean hexo g -d ","date":"2018-08-27","objectID":"/posts/369cf01c.html/:5:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(6) - 将博客同时部署到Github和Coding","uri":"/posts/369cf01c.html/"},{"categories":["Hexo瞎折腾系列"],"content":"为什么要压缩页面静态资源 对于个人博客来说，优化页面的访问速度是很有必要的，如果打开你的个人站点，加载个首页就要十几秒，页面长时间处于空白状态，想必没什么人能够忍受得了吧。我个人觉得，如果能把页面的加载时间控制在三四秒内，就很不错了。 那么怎么提高hexo这个静态博客的页面加载速度呢？可以从以下的几个方面去入手： 将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。 尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。 对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么卵用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。 ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"hexo的压缩静态资源插件 网上有很多相关的博文，常规的做法是使用gulp来进行压缩，gulp是Node.js下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。 使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下相关的东西。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。 这里我选择的是由rozbo大佬开发的hexo-neat压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！ ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"如何使用hexo-neat ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"在站点根目录下安装hexo-neat npm install hexo-neat --save ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:3:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"为站点配置文件添加相关配置 下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。 # hexo-neat # 博文压缩 neat_enable: true # 压缩html neat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - '**/*.min.css' # 压缩js neat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:3:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"hexo-neat插件踩坑记录 由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。 ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:4:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"跳过压缩文件的正确配置方式 如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下： neat_css: enable: true exclude: - '**/*.min.css' ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:4:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"压缩html时不要跳过.md文件 .md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。 当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。 ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:4:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"压缩html时不要跳过.swig文件 .swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。 ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:4:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["Hexo瞎折腾系列"],"content":"参考链接 GitHub项目地址 hexo博客压缩优化 Hexo-Neat介绍 ","date":"2018-08-25","objectID":"/posts/f90c8f1a.html/:5:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源","uri":"/posts/f90c8f1a.html/"},{"categories":["JavaWeb"],"content":"问题与分析 在web.xml中配置servlet节点时报错如下： cvc-complex-type.2.4.a: Invalid content was found starting with element ‘init-param’. One of ‘{“http://java.sun.com/xml/ns/j2ee\":run-as, “http://java.sun.com/xml/ns/j2ee\":security-role-ref}' is expected. 原因是init-param节点不能放在load-on-startup节点的后面，将init-param节点放置到前边就不再报这个错误了： \u003cservlet\u003e \u003cservlet-name\u003eresteasy-servlet\u003c/servlet-name\u003e \u003cservlet-class\u003e org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher \u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003ejavax.ws.rs.Application\u003c/param-name\u003e \u003cparam-value\u003ecom.cbx.ws.rest.jaxrs.CbxApplication\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e2\u003c/load-on-startup\u003e \u003c/servlet\u003e ","date":"2018-08-23","objectID":"/posts/474ffd9f.html/:1:0","tags":["JavaWeb","web.xml"],"title":"web.xml报错：Invalid content was found starting with element 'init-param'","uri":"/posts/474ffd9f.html/"},{"categories":["JavaWeb"],"content":"classpath*:与classpath: classpath对应src目录，该目录下的文件会在编译后被存放到WEB-INF文件夹下的classes目录。 classpath：只会到你的class路径中查找配置文件，对于多个同名的配置文件，只会加载找到的第一个文件； classpath*：除了指定的class路径，还会到该class路径下的jar包中进行查找配置文件，对于多个同名的配置文件，都会被加载。 但是对于classpath*，无法使用模糊匹配的方式，可以通过逗号来隔开多个配置文件。 \u003ccontext-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath*:applicationContext.xml, classpath*:app-1.xml, classpath*:app-2.xml, classpath*:app-3.xml, classpath*:app-4.xml \u003c/param-value\u003e \u003c/context-param\u003e ","date":"2018-08-14","objectID":"/posts/56592abf.html/:1:0","tags":["JavaWeb","web.xml"],"title":"web.xml中classpath*:与classpath:的区别","uri":"/posts/56592abf.html/"},{"categories":["JavaWeb"],"content":"参考链接： 在Web.xml中自动扫描Spring的配置文件及resource时classpath*:与classpath:的区别 ","date":"2018-08-14","objectID":"/posts/56592abf.html/:2:0","tags":["JavaWeb","web.xml"],"title":"web.xml中classpath*:与classpath:的区别","uri":"/posts/56592abf.html/"},{"categories":["Hexo瞎折腾系列"],"content":"文章摘要设置 打开主题配置文件 _config.yml 文件，找到如下： # Automatically Excerpt. Not recommend. # Please use \u003c!-- more --\u003e in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 把这里的false改为true就可以了在首页启动显示文章预览了，length是显示预览的长度。 这里我们可以通过在文章使用\u003c!-- more --\u003e标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。 强烈推荐使用该\u003c!-- more --\u003e标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。 ","date":"2018-07-20","objectID":"/posts/62111.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(4) - 站点首页不显示文章全文","uri":"/posts/62111.html/"},{"categories":["Hexo瞎折腾系列"],"content":"其他的文章配置 # --------------------------------------------------------------- # Post Settings # --------------------------------------------------------------- # Automatically scroll page to section which is under \u003c!-- more --\u003e mark. # 自动将页面滚动到\u003c!-- more --\u003e标记下的地方。 scroll_to_more: false # Automatically saving scroll position on each post/page in cookies. # 自动保存每篇文章或页面上一次滚动的地方。 save_scroll: false # Automatically excerpt description in homepage as preamble text. # 自动在首页对文章进行摘要描述作为前言文本。 excerpt_description: true # Automatically Excerpt. Not recommend. # Please use \u003c!-- more --\u003e in the post to control excerpt accurately. # 不推荐使用自动摘要。 # 请在文章中使用\u003c!-- more --\u003e标志来精确控制摘要长度。 auto_excerpt: enable: true length: 200 # Post meta display settings # 文章元数据展示设置 post_meta: # 文本显示 item_text: true # 创建时间 created_at: true # 更新时间 # 这个更新时间有点问题，因为每次重新生成文章/部署时都会刷新更新时间，不建议使用 updated_at: false # 目录分类 categories: true # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount # 文章字数展示设置 post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: true # 该post_wordcount的所有设置另起一行显示 separated_meta: true ","date":"2018-07-20","objectID":"/posts/62111.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(4) - 站点首页不显示文章全文","uri":"/posts/62111.html/"},{"categories":["Hexo瞎折腾系列"],"content":"页面右上角添加GitHub彩带 你可以在这里找到一共12种样式的GitHub彩带，复制其中的超链代码。 在themes\\next\\layout\\_layout.swig目录下找到头部彩带相关的代码： \u003cdiv class=\"headband\"\u003e\u003c/div\u003e 在这里的div标签内部添加我们刚刚复制的超链代码，并修改超链指向你的GitHub地址： \u003cdiv class=\"headband\"\u003e \u003ca href=\"https://github.com/lewky\"\u003e\u003cimg style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png\" alt=\"Fork me on GitHub\"\u003e\u003c/a\u003e \u003c/div\u003e 当然我本人并不是很推荐用这种方法，因为这个超链使用的图片有时候会加载很久，最后图片还是挂掉了，我是直接将图片保存到站点的images目录下，然后直接使用自己站点的图片，这样可以避免加载过久甚至图片挂掉的情况。 \u003cdiv class=\"headband\"\u003e \u003ca href=\"https://github.com/lewky\" target=\"_blank\"\u003e\u003cimg style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"/images/headband/forkme_right_red.png\" alt=\"Fork me on GitHub\"\u003e\u003c/a\u003e \u003c/div\u003e 我只找到了10张彩带图片，可以直接在我的GitHub项目中找到这些图片并复制到自己的站点上。 ","date":"2018-07-19","objectID":"/posts/844109c2.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(3) - 添加GitHub彩带和GitHub Corner","uri":"/posts/844109c2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"页面右上角添加GitHub Corner 这是我后来在其他博客中见到的，可能是6.x.x版本的NexT主题自带的，由于我使用的主题版本较低，只能自己添加了。 还是在themes\\next\\layout\\_layout.swig目录下，找到如下代码： \u003cheader id=\"header\" class=\"header\" itemscope itemtype=\"http://schema.org/WPHeader\"\u003e \u003cdiv class=\"header-inner\"\u003e {%- include '_partials/header.swig' %} \u003c/div\u003e \u003c/header\u003e 我们在这个header标签的下边，添加一个超链代码： \u003ca href=\"https://github.com/lewky\" class=\"github-corner\" target=\"_blank\" title=\"Follow me on GitHub\" aria-label=\"Follow me on GitHub\"\u003e \u003csvg width=\"80\" height=\"80\" viewBox=\"0 0 250 250\" style=\"fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;\" aria-hidden=\"true\"\u003e \u003cpath d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"\u003e\u003c/path\u003e\u003cpath d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"\u003e\u003c/path\u003e \u003cpath d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"\u003e\u003c/path\u003e \u003c/svg\u003e \u003c/a\u003e 将上边的超链的href改为自己的GitHub地址，然后我们需要修改这个超链的样式，在上文中提及的themes/next/source/css/_custom/custom.styl里添加如下代码： /* GitHub Cornor */ .github-corner :hover .octo-arm { animation: octocat-wave 560ms ease-in-out; } @media (max-width: 991px) { .github-corner \u003esvg { fill: #fff !important; color: #222 !important; } .github-corner .github-corner:hover .octo-arm { animation: none; } .github-corner .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out; } } @-moz-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @-webkit-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @-o-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); tra","date":"2018-07-19","objectID":"/posts/844109c2.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(3) - 添加GitHub彩带和GitHub Corner","uri":"/posts/844109c2.html/"},{"categories":["Hexo瞎折腾系列"],"content":"动态背景图片插件jquery-backstretch jquery-backstretch是一款简单的jQuery插件，可以用来设置动态的背景图片，以下是官方网站的介绍。 A simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element. 可以直接在页面中引入该插件的cdn来调用函数，也可以直接下载下来使用，这是官方地址。 ","date":"2018-07-19","objectID":"/posts/576ee548.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(2) - 添加背景图片轮播","uri":"/posts/576ee548.html/"},{"categories":["Hexo瞎折腾系列"],"content":"jquery-backstretch的使用方法 ","date":"2018-07-19","objectID":"/posts/576ee548.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(2) - 添加背景图片轮播","uri":"/posts/576ee548.html/"},{"categories":["Hexo瞎折腾系列"],"content":"引入该插件的cdn 打开themes\\next\\layout\\_custom\\custom-foot.swig，引入该背景图片插件的cdn： {# Custom foot in body, Can add script here. #} \u003c!-- 图片轮播js文件cdn --\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js\"\u003e\u003c/script\u003e \u003c!-- 自定义的js文件 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/custom.js\"\u003e\u003c/script\u003e 需要注意的是，我们要引入的插件cdn，都需要在自定义的js文件custom.js之前引入才行！否则，插件会在访问页面时无法生效，可以在浏览器的控制台看到报错。 ","date":"2018-07-19","objectID":"/posts/576ee548.html/:2:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(2) - 添加背景图片轮播","uri":"/posts/576ee548.html/"},{"categories":["Hexo瞎折腾系列"],"content":"调用backstretch函数 在themes\\next\\source\\js\\src\\custom.js中添加如下代码： /* 轮播背景图片 */ $(function () { $.backstretch([ \"/images/background/saber1.jpg\", \"/images/background/saber2.jpg\", \"/images/background/bg1.jpg\" ], { duration: 60000, fade: 1500 }); }); 这里可以随意添加你想要轮播的图片，但要确保图片路径是正确的，比如我的背景图片就存放在站点根目录下的images/background/目录下。 然后duration指的是轮换图片的时间，单位是毫秒，也就是说这里的代码表示一分钟就轮换到下一张图片； fade指的是轮换图片时会有个渐进渐出的动作，而这个过程需要花费的时间单位也是毫秒，如果不加上这个参数，就表示离开轮换成下一张图片。 注意这里的$.backstretch指的是对整个页面设置背景图片，我们也可以专门给某个元素设置背景图片，如下： $(function () { $(\".saber1\").backstretch([\"/images/background/saber1.jpg\"]); $(\".saber2\").backstretch([\"/images/background/saber2.jpg\"]); }); 如果只有一张图片，就没必要设置duration和fade参数了。 ","date":"2018-07-19","objectID":"/posts/576ee548.html/:2:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(2) - 添加背景图片轮播","uri":"/posts/576ee548.html/"},{"categories":["Hexo瞎折腾系列"],"content":"为背景图片设置样式 虽然我们设置好了背景图片，但如果页面的许多元素是不透明的，背景图片可能并不能很好地被看见，所以我们可以对背景图片和其他的页面元素进行设置样式。 首先为背景图片设置透明度，因为有的图片颜色比较深厚，而页面多为白色，然后造成喧宾夺主的感觉。 /* 背景图片透明度 */ .backstretch { opacity: .75; } 接下来设置页面元素透明度，需要注意的是，如果我们在主题配置文件中启用了搜索功能，那么就不能简单粗暴地直接将整个页面都设置透明度，这会导致搜索框失效，无法正常使用。原因是因为搜索框是通过jQuery临时添加的，如果整个页面都设置了透明度，会导致搜索框的z-index失效而无法触发点击事件。 我在折腾了一段时间后，终于想到了个取巧的方法，那就是将搜索框的父元素设置为白色透明的，而其他页面元素则直接设置透明度，如下： /* 页面透明度 */ .content-wrap, .sidebar { opacity: .9 !important; } .header-inner { background: rgba(255, 255, 255, 0.9) !important; } ","date":"2018-07-19","objectID":"/posts/576ee548.html/:2:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(2) - 添加背景图片轮播","uri":"/posts/576ee548.html/"},{"categories":["Hexo瞎折腾系列"],"content":"前言 网上有不少相关的帖子，不过版本会比较旧，而不同版本可能存在代码不同的问题，不过大部分还是大同小异，本系列就不啰嗦重复了，基本只会按照本人所使用的版本以及个人所使用到的内容来进行介绍。 该系列是对我所使用的Next主题进行个性化定制，涉及到js和css等的修改，还有各种插件的使用；另一个系列是针对Next主题进行一些写作技巧的介绍与运用，希望能对大家有所帮助。有疑问的朋友可以给我留言，我会尽可能回复O(∩_∩)O。 我所使用的Hexo和NexT的版本如下： hexo: 3.7.1 next: 5.1.4 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"关于配置文件 对于使用了Next主题的Hexo静态博客，存在着两个至关重要的配置文件_config.yml。在本系列中，统一将位于站点根目录下的该文件称为站点配置文件，将位于themes\\next目录下的该文件称为主题配置文件。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"准备工作：添加美化博客的相关文件 本系列会使用到大量的css与JavaScript的相关内容，为了更有效率与可观赏性的美化博客，我们将这些美化相关的东西都尽可能地写到一类文件中，方便日后查询与修改。譬如下边的几个文件里，就存放了博客的大部分美化内容： themes/next/source/css/_custom/custom.styl themes/next/source/js/src/custom.js themes/next/layout/_partials/head/custom-head.swig themes/next/layout/_custom/custom-foot.swig 除了第一个文件custom.styl保存的是css代码，另外三个文件都是保存的js代码。这几个文件分别会在页面的以下位置中被引入： \u003chtml\u003e \u003chead\u003e .... {{ custom.styl }} //css .... {{ custom-head.swig }} //js .... \u003c/head\u003e \u003cbody\u003e .... .... {{ custom-foot.swig }} //js {{ custom.js }} //js \u003c/body\u003e \u003c/html\u003e 这里的custom.styl，custom-head.swig是原本的NexT主题自带的，另外两个是我自己添加的，之所以又添加了另外两个js文件，是因为在页面的不同地方引入js文件会对页面产生不一样的效果与影响。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"添加 custom-foot.swig 文件 在themes/next/layout/_custom/目录下添加custom-foot.swig文件，该文件内容如下： {# Custom foot in body, Can add script here. #} \u003c!-- 自定义的js文件 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/custom.js\"\u003e\u003c/script\u003e 接着修改themes\\next\\layout\\_layout.swig，在body标签的闭合标签前添加一行代码，表示将我们新添加的custom-foot.swig文件包括进去： \u003cbody\u003e .... {% include '_custom/custom-foot.swig' %} \u003c/body\u003e \u003c/html\u003e 这个文件的作用是负责引入我们想要的js文件，比如其他第三方js的cdn等等。因为页面在引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:3:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"添加 custom.js 文件 在themes/next/source/js/src目录下添加custom.js文件，该文件用来存放我们自己写的js函数等等，需要注意的是，我们之前是在custom-foot.swig文件中的script标签里引入了该文件，也就是说，在该文件里，我们不能再自己添加script标签了，直接书写js函数就行了，如下所示： /* 返回随机颜色 */ function randomColor() { return \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"; } ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:3:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"页面的简单美化 由于很多大佬的博客都有很详尽的美化教程，这里我就不赘述了，只简单介绍下比较少人讲述到的部分简单美化。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:0","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"改变页面的字体大小 打开 themes\\next\\source\\css\\_variables\\base.styl，该文件保存了一些基础变量的值，我们找到$font-size-base，将值改为16px。 // Font size $font-size-base = 16px 这个文件里定义了很多常量，有兴趣的可以自己去琢磨琢磨，修改一些其他的变量。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:1","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"文章启用tags和categories 可能是该版本的NexT主题的关系，在我第一次使用NexT主题时，折腾了很久都没办法让菜单栏里的tags和categories的页面生效，一直显示白屏。后来终于在知乎找到答案，首先我们需要将某篇文章设置tags和categories，如下： --- title: Test tags: - MyTag categories: - MyCategory date: 20xx-xx-xx xx:xx:xx --- 接下来是重点了，首先确定是否已经在主题配置文件中启用了tags和categories这两个菜单，如下： menu: home: / || fas fa-home archives: /archives/ || fas fa-archive categories: /categories/ || fas fa-th tags: /tags/ || fas fa-tags 接着确定是否在source目录下是否已经存在tags和categories这两个文件夹，如果不存在需要运行下边的命令： hexo n page tags hexo n page categories 运行之后会在source目录下生成对应的两个文件夹，在文件夹下会存在一个index.md文件，打开这两个index.md文件，分别添加type: tags和type: categories，如下： --- title: 标签 date: 20xx-xx-xx xx:xx:xx type: tags --- --- title: 分类 date: 20xx-xx-xx xx:xx:xx type: categories --- 接下来重新使用本地调试三连，就可以看到tags和categories这两个菜单的页面显示正常了。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:2","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"去掉图片边框 NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下CSS代码： /* 去掉图片边框 */ .posts-expand .post-body img { border: none; padding: 0px; } .post-gallery .post-gallery-img img { padding: 3px; } ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:3","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"修改语法高亮的主题 语法高亮就是在引入代码时让代码呈现特定的样式，而在Markdown文件中语法高亮的使用方法是在引入代码的前一行添加三个反引号加上使用的语言名字，然后在引入代码的下一行使用三个反引号结尾。 如下所示的格式，就表示html代码的语法高亮： \u003ch2\u003eHello World!\u003c/h2\u003e 其源码如下： \u003ch2\u003eHello World!\u003c/h2\u003e 由于NexT默认的语法高亮的主题比较一般，我们可以换成其他的主题，比如我所使用的就是黑色的主题。 打开主题配置文件，修改如下配置： # 语法高亮主题 # Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: night eighties ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:4","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"指定Markdown的解析器 上边我们设置了语法高亮后，虽然在本地调试没有问题，然而当我们将博客部署到GitHub Pages和 Coding Pages后却发现，前者的页面不支持语法高亮，而后者支持。百度后才知道原来是因为 GitHub 默认使用的 Markdown 解析器不支持语法高亮，解决方法如下： 打开站点配置文件_config.yml，在末尾添加如下内容： markdown: redcarpet redcarpet: extensions: [\"fenced_code_blocks\", \"autolink\", \"tables\", \"strikethrough\"] 接下来重新执行部署三连命令，就会发现 GitHub Pages 上部署的页面语法高亮显示成功了。 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:5","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Hexo瞎折腾系列"],"content":"推荐一些写得很齐全的文章链接 hexo的next主题个性化配置教程 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 ","date":"2018-07-11","objectID":"/posts/ef301a4d.html/:4:6","tags":["Hexo","NexT主题个性化"],"title":"Hexo瞎折腾系列(1) - 准备工作与简单美化","uri":"/posts/ef301a4d.html/"},{"categories":["Java"],"content":"1、使用serialVersionUID 在Eclipse中，如果一个类实现了Serializable接口，且没有给这个类设置一个serialVersionUID，就会有一个警告标志： The serializable class BaseEntity does not declare a static final serialVersionUID field of type long 通过设置一个serialVersionUID可以解除该警告，虽然不设置该ID也可以，但若是实现了序列化，一定不能少这个serialVersionUID。之所以要设置该ID，原因如下： 序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。 该serialVersionUID的值可以默认为1L，也可以用Eclipse直接生成。 private static final long serialVersionUID = 5647613333522643572L; ","date":"2018-06-28","objectID":"/posts/71bd19d3.html/:1:0","tags":["Java","序列化"],"title":"Java - 序列化的注意点","uri":"/posts/71bd19d3.html/"},{"categories":["Java"],"content":"2、静态变量不会被序列化 序列化顾名思义，就是将实例对象的各种信息/状态存储到本地，而静态变量是属于类的，则不会被序列化，注意：序列化是针对实例变量的，和静态变量和方法无关。 ","date":"2018-06-28","objectID":"/posts/71bd19d3.html/:2:0","tags":["Java","序列化"],"title":"Java - 序列化的注意点","uri":"/posts/71bd19d3.html/"},{"categories":["Java"],"content":"3、非静态的内部类必须实现序列化 如果被序列化的对象中存在非静态的内部类，该内部类必须实现序列化，否则会报异常 如果是静态内部类，则可以正常序列化外部类的实例对象 ","date":"2018-06-28","objectID":"/posts/71bd19d3.html/:3:0","tags":["Java","序列化"],"title":"Java - 序列化的注意点","uri":"/posts/71bd19d3.html/"},{"categories":["Java"],"content":"4、如果实例变量是对象类型，则该对象类型的类必须实现序列化 序列化要求所有的成员变量都实现了Serializable，比如String类型的变量。 ","date":"2018-06-28","objectID":"/posts/71bd19d3.html/:4:0","tags":["Java","序列化"],"title":"Java - 序列化的注意点","uri":"/posts/71bd19d3.html/"},{"categories":["Java"],"content":"5、使用transient关键字阻止序列化实例变量 如果不想要将某个实例变量序列化，可以使用transient关键字来阻止其序列化。 ","date":"2018-06-28","objectID":"/posts/71bd19d3.html/:5:0","tags":["Java","序列化"],"title":"Java - 序列化的注意点","uri":"/posts/71bd19d3.html/"},{"categories":null,"content":"\rHigh!!! 前方高能♂ 1.gif \" 1.gif 2.gif \" 2.gif ","date":"2018-06-18","objectID":"/high/:0:0","tags":null,"title":"Everybody~ High起来!","uri":"/high/"},{"categories":["Hexo"],"content":"今天安装了hexo-generator-baidu-sitemap后，运行hexo g报错如下： error.jpg \" error.jpg 到了作者的GitHub上发现也有人提了相关的issue，不过都过了相当一段时间了依然没有解决，最后还是自己动手丰衣足食，解决方法很简单，因为Hexo3.X.X版本改变了代码导致toArray()无法使用，我们直接将该方法去掉就行了。 打开 node_modules\\hexo-generator-baidu-sitemap\\baidusitemap.ejs，将这里边的 post.tags.toArray() 和 post.categories.toArray() 改成 post.tags 和 post.categories，简单的说就是把这里的 toArray() 去掉，新版本的Hexo的tags和categories可以直接遍历。 code.jpg \" code.jpg 接下来重新运行 hexo g 和 hexo s，本地调试成功~ ","date":"2018-06-12","objectID":"/posts/49fbb32a.html/:0:0","tags":["Hexo"],"title":"Hexo - 3.X.X版本无法生成baidusitemap","uri":"/posts/49fbb32a.html/"},{"categories":["Java修仙"],"content":"一、基础篇 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:1:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"1.1 JVM JVM内存结构 堆、栈、方法区、直接内存、堆和栈区别Java内存模型 内存可见性、重排序、顺序一致性、volatile、锁、final 垃圾回收 内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定 JVM参数及调优 Java对象模型 oop-klass、对象头 HotSpot 即时编译器、编译优化 类加载机制 classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 虚拟机性能监控与故障处理工具 jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler 编译与反编译 javac 、javap 、jad 、CRF ","date":"2018-06-08","objectID":"/posts/5044311b.html/:1:1","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"1.2 Java基础知识 阅读源代码 String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader \u0026 URLClassLoader、ArrayList \u0026 LinkedList、 HashMap \u0026 LinkedHashMap \u0026 TreeMap \u0026 CouncurrentHashMap、HashSet \u0026 LinkedHashSet \u0026 TreeSet Java中各种变量类型 熟悉Java String的使用，熟悉String的各种函数 JDK 6和JDK 7中substring的原理及区别、replaceFirst、replaceAll、replace区别、String对“+”的重载、String.valueOf和Integer.toString的区别、字符串的不可变性 自动拆装箱 Integer的缓存机制 熟悉Java中各种关键字 transient、instanceof、volatile、synchronized、final、static、const 原理及用法。 集合类 常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因 枚举 枚举的用法、枚举与单例、Enum类 Java IO\u0026Java NIO，并学会使用 bio、nio和aio的区别、三种IO的用法与原理、netty Java反射与javassist 反射与工厂模式、 java.lang.reflect.* Java序列化 什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 注解 元注解、自定义注解、Java中常用注解使用、注解与反射的结合 JMS 什么是Java消息服务、JMS消息传送模型 JMX java.lang.management.、 javax.management. 泛型 泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法 单元测试 junit、mock、mockito、内存数据库（h2） 正则表达式 java.lang.util.regex.* 常用的Java工具库 commons.lang, commons.*… guava-libraries netty 什么是API\u0026SPI 异常 异常类型、正确处理异常、自定义异常 时间处理 时区、时令、Java中时间API 编码方式 解决乱码问题、常用编码方式 语法糖 Java中语法糖原理、解语法糖 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:1:2","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"1.3 Java并发编程 什么是线程，与进程的区别 阅读源代码，并学会使用 Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors 线程池 自己设计线程池、submit() 和 execute() 线程安全 死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系 锁 CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁 volatile happens-before、编译器指令重排和CPU指令重 synchronized synchronized是如何实现的？synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例 sleep 和 wait wait 和 notify notify 和 notifyAll ThreadLocal 写一个死锁的程序 写代码来解决生产者消费者问题 守护线程 守护线程和非守护线程的区别以及用法 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:1:3","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"二、进阶篇 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.1 Java底层知识 字节码、class文件格式 CPU缓存，L1，L2，L3和伪共享 尾递归 位运算 用位运算实现加、减、乘、除、取余 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:1","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.2 设计模式 了解23种设计模式 会使用常用设计模式 单例、策略、工厂、适配器、责任链。 实现AOP 实现IOC 不用synchronized和lock，实现线程安全的单例模式 nio和reactor设计模式 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:2","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.3 网络编程知识 tcp、udp、http、https等常用协议 三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包 http/1.0 http/1.1 http/2之前的区别 Java RMI，Socket，HttpClient cookie 与 session cookie被禁用，如何实现session 用Java写一个简单的静态文件的HTTP服务器 实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则” 了解nginx和apache服务器的特性并搭建一个对应的服务器 用Java实现FTP、SMTP协议 进程间通讯的方式 什么是CDN？如果实现？ 什么是DNS？ 反向代理 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:3","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.4 框架知识 Servlet线程安全问题 Servlet中的filter和listener Hibernate的缓存机制 Hiberate的懒加载 Spring Bean的初始化 Spring的AOP原理 自己实现Spring的IOC Spring MVC Spring Boot2.0 Spring Boot的starter原理，自己实现一个starter Spring Security ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:4","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.5 应用服务器知识 JBoss tomcat jetty Weblogic ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:5","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"2.6 工具 git \u0026 svn maven \u0026 gradle ","date":"2018-06-08","objectID":"/posts/5044311b.html/:2:6","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"三、高级篇 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.1 新技术 Java 8 lambda表达式、Stream API、 Java 9 Jigsaw、Jshell、Reactive Streams Java 10 局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制 Spring 5 响应式编程 Spring Boot 2.0 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:1","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.2 性能优化 使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:2","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.3 线上问题分析 dump获取 线程Dump、内存Dump、gc情况 dump分析 分析死锁、分析内存泄露 自己编写各种outofmemory，stackoverflow程序 HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow 常见问题解决思路 内存溢出、线程死锁、类加载冲突 使用工具尝试解决以下问题，并写下总结 当一个Java程序响应很慢时如何查找问题、 当一个Java程序频繁FullGC时如何解决问题、 如何查看垃圾回收日志、 当一个Java应用发生OutOfMemory时该如何解决、 如何判断是否出现死锁、 如何判断是否存在内存泄露 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:3","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.4 编译原理知识 编译与反编译 Java代码的编译与反编译 Java的反编译工具 词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:4","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.5 操作系统知识 Linux的常用命令 进程同步 缓冲区溢出 分段和分页 虚拟内存与主存 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:5","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.5 数据库知识 MySql 执行引擎 MySQL 执行计划 如何查看执行计划，如何根据执行计划进行SQL优化 SQL优化 事务 事务的隔离级别、事务能不能实现锁的功能 数据库锁 行锁、表锁、使用数据库锁实现乐观锁、 数据库主备搭建 binlog 内存数据库 h2 常用的nosql数据库 redis、memcached 分别使用数据库锁、NoSql实现分布式锁 性能调优 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:6","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.6 数据结构与算法知识 简单的数据结构 栈、队列、链表、数组、哈希表、 树 二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树 排序算法 各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列、贪心算法、KMP算法、hash算法、海量数据处理 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:7","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.7 大数据知识 Zookeeper 基本概念、常见用法 Solr，Lucene，ElasticSearch 在linux上部署solr，solrcloud，，新增、删除、查询索引 Storm，流式计算，了解Spark，S4 在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。 Hadoop，离线计算 HDFS、MapReduce 分布式日志收集flume，kafka，logstash 数据挖掘，mahout ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:8","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"3.8 网络安全知识 什么是XSS XSS的防御 什么是CSRF 什么是注入攻击 SQL注入、XML注入、CRLF注入 什么是文件上传漏洞 加密与解密 MD5，SHA1、DES、AES、RSA、DSA 什么是DOS攻击和DDOS攻击 memcached为什么可以导致DDos攻击、什么是反射型DDoS SSL、TLS，HTTPS 如何通过Hash碰撞进行DOS攻击 用openssl签一个证书部署到apache或nginx ","date":"2018-06-08","objectID":"/posts/5044311b.html/:3:9","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"四、架构篇 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"4.1 分布式 数据一致性、服务治理、服务降级 分布式事务 2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC Dubbo 服务注册、服务发现，服务治理 分布式数据库 怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase 分布式文件系统 mfs、fastdfs 分布式缓存 缓存一致性、缓存命中率、缓存冗余 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:1","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"4.2 微服务 SOA、康威定律 ServiceMesh Docker \u0026 Kubernets Spring Boot Spring Cloud ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:2","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"4.3 高并发 分库分表 CDN技术 消息队列 ActiveMQ ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:3","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"4.4 监控 监控什么 CPU、内存、磁盘I/O、网络I/O等 监控手段 进程监控、语义监控、机器资源监控、数据波动 监控数据采集 日志、埋点 Dapper ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:4","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"4.5 负载均衡 tomcat负载均衡、Nginx负载均衡 DNS DNS原理、DNS的设计 CDN 数据一致性 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:4:5","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"五、扩展篇 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.1 云计算 IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:1","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.2 搜索引擎 Solr、Lucene、Nutch、Elasticsearch ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:2","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.3 权限管理 Shiro ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:3","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.4 区块链 哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 比特币 挖矿、共识机制、闪电网络、侧链、热点问题、分叉 以太坊 超级账本 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:4","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.5 人工智能 数学基础、机器学习、人工神经网络、深度学习、应用场景。 常用框架 TensorFlow、DeepLearning4J ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:5","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"5.6 其他语言 Groovy、Python、Go、NodeJs、Swift、Rust ","date":"2018-06-08","objectID":"/posts/5044311b.html/:5:6","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["Java修仙"],"content":"六、推荐书籍 《深入理解Java虚拟机》 《Effective Java》 《深入分析Java Web技术内幕》 《大型网站技术架构》 《代码整洁之道》 《Head First设计模式》 《maven实战》 《区块链原理、设计与应用》 《Java并发编程实战》 《鸟哥的Linux私房菜》 《从Paxos到Zookeeper》 《架构即未来》 ","date":"2018-06-08","objectID":"/posts/5044311b.html/:6:0","tags":["Java","Java修仙"],"title":"Java工程师成神之路(2018版本)","uri":"/posts/5044311b.html/"},{"categories":["NexT主题个性化"],"content":"安装插件及其使用方法 在站点根目录执行命令： npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 接下来在需要置顶的文章头部添加 top: true 或者 top: n，这里的n是数字，数字越大表示置顶等级越高。 title: XXX tags: - XXX categories: - XXX date: XXX top: 100 ","date":"2018-05-13","objectID":"/posts/6ed0d627.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 添加文章置顶功能","uri":"/posts/6ed0d627.html/"},{"categories":["NexT主题个性化"],"content":"在文章标题下方添加置顶样式 打开 themes/next/layout/_macro/post.swig，在 \u003cdiv class=\"post-meta\"\u003e 下方添加如下代码： {% if post.top %} \u003cspan class=\"post-meta-item-icon\"\u003e \u003ci class=\"fa fa-thumb-tack\"\u003e\u003c/i\u003e \u003c/span\u003e \u003cfont color=\"red\"\u003e置顶\u003c/font\u003e \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e {% endif %} encrypt.jpg \" encrypt.jpg ","date":"2018-05-13","objectID":"/posts/6ed0d627.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 添加文章置顶功能","uri":"/posts/6ed0d627.html/"},{"categories":["NexT主题个性化"],"content":"安装搜索插件 在站点根目录使用 git bash 执行命令： npm install hexo-generator-searchdb --save ","date":"2018-05-13","objectID":"/posts/3e5e6b79.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 启用搜索功能","uri":"/posts/3e5e6b79.html/"},{"categories":["NexT主题个性化"],"content":"启用搜索功能 打开主题配置文件 _config.yml，修改如下配置： # Local search # Dependencies: https://github.com/flashlab/hexo-generator-search # 本地搜索，需要安装 hexo-generator-search # 站点根目录执行：npm install hexo-generator-searchdb --save local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button # auto表示改变输入就自动触发搜索 # manual表示按下回车键或搜索按钮才触发搜索 trigger: auto # show top n results per article, show all results by setting to -1 # 这里的数字n表示显示每篇文章搜索到的n个结果 # -1表示显示每篇文章搜索到的全部结果(不建议) top_n_per_article: 1 ","date":"2018-05-13","objectID":"/posts/3e5e6b79.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 启用搜索功能","uri":"/posts/3e5e6b79.html/"},{"categories":["NexT主题个性化"],"content":" 效果图 code-block.jpg \" code-block.jpg 打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下样式： /* 行内代码块的自定义样式 */ code { color: #d500fc; background: rgba(78, 240, 233, 0.42); margin: 2px; border: 1px solid #d6d6d6; } ","date":"2018-05-13","objectID":"/posts/efd1caf6.html/:0:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 修改行内代码块的样式","uri":"/posts/efd1caf6.html/"},{"categories":["NexT主题个性化"],"content":" a:link 效果图 link.jpg \" link.jpg a:hover 效果图 hover.jpg \" hover.jpg 打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下样式： /* 文章内链接文本样式 */ .post-body p a, .post-body li a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; \u0026:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 这里选择 .post-body p a 是为了不影响文章标题和首页 阅读全文》 的样式，选择 .post-body li a 是为了对列表内的超链也有效果。 总之，我们可以随意定义这里的具体样式。 ","date":"2018-05-13","objectID":"/posts/770f091e.html/:0:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 修改文章内的超链样式","uri":"/posts/770f091e.html/"},{"categories":["Hexo"],"content":"Hexo的永久链接的默认格式是 :year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。 解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。 ","date":"2018-05-13","objectID":"/posts/ff4321d8.html/:0:0","tags":["Hexo"],"title":"Hexo - 修改永久链接的默认格式","uri":"/posts/ff4321d8.html/"},{"categories":["Hexo"],"content":"安装插件 在站点根目录使用 git bash 执行命令： npm install hexo-abbrlink --save ","date":"2018-05-13","objectID":"/posts/ff4321d8.html/:1:0","tags":["Hexo"],"title":"Hexo - 修改永久链接的默认格式","uri":"/posts/ff4321d8.html/"},{"categories":["Hexo"],"content":"修改站点配置文件 打开根目录下的 _config.yml 文件，修改如下配置： # permalink: :year/:month/:day/:title/ # permalink_defaults: permalink: posts/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 这里将页面都添加了 .html 的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。 接下来重新部署三连，可以看到我们的文章路径变成了 /posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。 ","date":"2018-05-13","objectID":"/posts/ff4321d8.html/:2:0","tags":["Hexo"],"title":"Hexo - 修改永久链接的默认格式","uri":"/posts/ff4321d8.html/"},{"categories":["NexT主题个性化"],"content":"打开 themes\\next\\layout\\_macro\\post-collapse.swig，修改这里的超链的target： \u003ca class=\"post-title-link\" href=\"{{ url_for(post.path) }}\" itemprop=\"url\"\u003e {% if post.type === 'picture' %} {{ post.content }} {% else %} \u003cspan itemprop=\"name\"\u003e{{ post.title | default(__('post.untitled')) }}\u003c/span\u003e {% endif %} \u003c/a\u003e 接着打开 themes\\next\\layout\\_macro\\post.swig，修改这里的超链的target： \u003ca class=\"post-title-link\" href=\"{{ url_for(post.path) }}\" itemprop=\"url\"\u003e{# #}{{ post.title | default(__('post.untitled'))}}{# #}\u003c/a\u003e 在这两个超链里添加 target=\"_blank\" ，最终修改如下： target_blank.jpg \" target_blank.jpg ","date":"2018-05-13","objectID":"/posts/4d58b14d.html/:0:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 让所有的文章链接在新窗口打开","uri":"/posts/4d58b14d.html/"},{"categories":["NexT主题个性化"],"content":" 阅读本文前需要先填写密码 123 ","date":"2018-05-12","objectID":"/posts/15308.html/:0:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 对文章进行加密","uri":"/posts/15308.html/"},{"categories":["NexT主题个性化"],"content":"修改 JS 代码 打开 themes\\next\\layout\\_partials\\head.swig，在文件的开头位置找到如下代码： \u003cmeta charset=\"UTF-8\"/\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"/\u003e \u003cmeta name=\"theme-color\" content=\"{{ theme.android_chrome_color }}\"\u003e 在上边代码的末尾添加如下代码： \u003cscript\u003e (function(){ if('{{ page.password }}'){ if (prompt('请输入文章密码') !== '{{ page.password }}'){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e 注意：网上其他的帖子是在这里选择输入密码错误后进行回退历史的操作，代码如下： \u003cscript\u003e (function(){ if('{{ page.password }}'){ if (prompt('请输入文章密码') !== '{{ page.password }}'){ alert('密码错误！'); history.back(); } } })(); \u003c/script\u003e 我经过测试发现，这段代码有问题： 如果当前页面是新打开的窗口，其历史页面只有一个，也就是history.length === 1时，就算不输入密码或者输入错误的密码，也会在提示密码错误之后成功进入文章页面！！！ 所以我们使用改良后的JS代码。 ","date":"2018-05-12","objectID":"/posts/15308.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 对文章进行加密","uri":"/posts/15308.html/"},{"categories":["NexT主题个性化"],"content":"给某篇文章设置密码 添加完脚本代码，接下来在想要加密的文章的文件头加上 password 属性就行了，如下： --- title: XXX date: XXX tags: - XXX categories: - XXX password: 123 --- 这样在打开这篇文章时只有输入了123这个密码才可以打开成功。 ","date":"2018-05-12","objectID":"/posts/15308.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 对文章进行加密","uri":"/posts/15308.html/"},{"categories":["NexT主题个性化"],"content":"NexT主题集成的是4.6.2版本的fontawesome，现在已经出了更高版本的了，修改fontawesome的版本有两种方式。 ","date":"2018-05-12","objectID":"/posts/55711.html/:0:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 使用FontAwesome 5","uri":"/posts/55711.html/"},{"categories":["NexT主题个性化"],"content":"方式一：直接修改主题配置文件 打开主题配置文件 _config.yml，修改如下配置： # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: 在这里的 fontawesome: 后面直接添加上 fontawesome 的 CDN 就行了；不过不推荐这种改法，因为版本5的 fontawesome 改变了不少，直接在这里添加 fontawesome 5的 CDN 会导致原本的图标全部显示不出来。 推荐方式二的改法。 ","date":"2018-05-12","objectID":"/posts/55711.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 使用FontAwesome 5","uri":"/posts/55711.html/"},{"categories":["NexT主题个性化"],"content":"方式二：修改页面头文件的模板 打开 themes\\next\\layout\\_partials\\head.swig，找到如下代码： {% if theme.vendors.fontawesome %} {% set font_awesome_uri = theme.vendors.fontawesome %} {% endif %} \u003clink href=\"{{ font_awesome_uri }}\" rel=\"stylesheet\" type=\"text/css\" /\u003e 在上边的代码后插入 fontawesome 5 的 CDN： \u003clink rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.13/css/all.css\" integrity=\"sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp\" crossorigin=\"anonymous\"\u003e 如果这里的CDN链接无效，请去官网复制CDN链接：https://fontawesome.com/get-started fontawesome-CDN \" fontawesome-CDN ","date":"2018-05-12","objectID":"/posts/55711.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 使用FontAwesome 5","uri":"/posts/55711.html/"},{"categories":["NexT主题个性化"],"content":"安装 wordcount 插件 在站点根目录打开 git bash，输入： npm i --save hexo-wordcount 该插件的具体使用方法可以参考 GitHub 上的仓库：https://github.com/willin/hexo-wordcount ","date":"2018-05-12","objectID":"/posts/22195.html/:1:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 文章启用字数统计、阅读时长","uri":"/posts/22195.html/"},{"categories":["NexT主题个性化"],"content":"在主题配置文件启用该插件 NexT主题本身就集成了该插件，在安装了该插件后直接启用就行了。 进入主题配置文件 _config.yml，修改如下配置： # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount # 文章字数展示设置 post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: false # 该post_wordcount的所有设置另起一行显示 separated_meta: true ","date":"2018-05-12","objectID":"/posts/22195.html/:2:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 文章启用字数统计、阅读时长","uri":"/posts/22195.html/"},{"categories":["NexT主题个性化"],"content":"自定义字数计数的显示样式 启用了该插件后的显示样式也是可以自己修改的，进入 themes\\next\\layout\\post.swig，找到如下代码，这里可以修改字数统计的样式： {% if not theme.post_wordcount.separated_meta %} \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e {% endif %} \u003cspan class=\"post-meta-item-icon\"\u003e \u003ci class=\"fa fa-file-word-o\"\u003e\u003c/i\u003e \u003c/span\u003e {% if theme.post_wordcount.item_text %} \u003cspan class=\"post-meta-item-text\"\u003e{{ __('post.wordcount') }}\u0026#58;\u003c/span\u003e {% endif %} \u003cspan title=\"{{ __('post.wordcount') }}\"\u003e {{ wordcount(post.content) }} \u003c/span\u003e 下边是阅读时长的代码： {% if theme.post_wordcount.min2read %} \u003cspan class=\"post-meta-item-icon\"\u003e \u003ci class=\"fa fa-clock-o\"\u003e\u003c/i\u003e \u003c/span\u003e {% if theme.post_wordcount.item_text %} \u003cspan class=\"post-meta-item-text\"\u003e{{ __('post.min2read') }} \u0026asymp;\u003c/span\u003e {% endif %} \u003cspan title=\"{{ __('post.min2read') }}\"\u003e {{ min2read(post.content) }} \u003c/span\u003e {% endif %} 改完样式后，再去 themes\\next\\languages 目录下找到你所使用的语言对应的 yml 文件，修改要显示的文本。比如我使用的语言是 zh-Hans，就修改 zh-Hans.yml里的文本： post: wordcount: 本文共计 min2read: 阅文耗时 totalcount: Site words total count ","date":"2018-05-12","objectID":"/posts/22195.html/:3:0","tags":["Hexo","NexT主题个性化"],"title":"NexT主题个性化 - 文章启用字数统计、阅读时长","uri":"/posts/22195.html/"},{"categories":["Hexo"],"content":"修改默认的post和draft的模板 通过hexo n post XXX或者hexo n draft XXX所生成的文章或草稿是根据默认的模板来生成的，我们可以自己来定制想要的模板。 在站点根目录下的 scaffolds 文件夹下，存放着 draft.md， page.md 和 post.md这三个文件夹，一般我们只需要修改draft和post这两个模板就行了。 我们可以在模板的文件头里添加自己想要的格式，如下： --- title: {{ title }} date: {{ date }} tags: categories: --- 这样使用命令生成的draft或post都会默认带有上边的文件头了。 ","date":"2018-05-10","objectID":"/posts/1369.html/:1:0","tags":["Hexo"],"title":"Hexo - 修改默认的post和draft的模板","uri":"/posts/1369.html/"},{"categories":["Hexo"],"content":"添加新的模板来生成定制的post 其实我们还可以在 scaffolds 目录下添加新的模板文件，比如 Hexo.md，其模板内容如下： --- title: {{ title }} date: {{ date }} tags: - Hexo categories: - Hexo --- 然后通过命令： hexo n hexo XXX 注意，这里的第二个 hexo 指的是我们刚刚新添加的模板文件 hexo.md 的文件名；这里的文件名和命令都是大小写不敏感的。 执行完命令会在 source/_posts 目录下生成与 hexo.md 模板相对应的文章。 ","date":"2018-05-10","objectID":"/posts/1369.html/:2:0","tags":["Hexo"],"title":"Hexo - 修改默认的post和draft的模板","uri":"/posts/1369.html/"},{"categories":["Hexo"],"content":"网上有不少办法，有的是启用配置文件中的属性，有的则是安装插件，这里只介绍最简单的一种方法。 在 source/ 目录下新建一个文件夹，比如 images；在该文件夹下存放各种图片资源，比如 test.jpg； 新建一篇文章，在文章中使用markdown的插入图片语法： ![test](/images/test.jpg) 这里使用的是绝对路径，如果使用相对路径比如images/test.jpg可能会无法访问到该图片资源。建议在博客或者配置中都使用绝对路径。 ","date":"2018-05-09","objectID":"/posts/12046.html/:0:0","tags":["Hexo"],"title":"Hexo - 如何在文章中插入图片","uri":"/posts/12046.html/"},{"categories":["Hexo搭建博客教程"],"content":" 本章讲的是如何将本地的个人项目远程部署到 GitHub Pages，涉及到GitHub的项目仓库、Git的使用，以及Hexo的远程部署等。 ","date":"2018-04-24","objectID":"/posts/1657.html/:0:0","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"一、安装 hexo-deployer-git 插件 想要将Hexo项目部署到 GitHub上，需要先安装一个插件。在Hexo项目的根目录打开命令窗口，输入： npm install hexo-deployer-git --save\r ","date":"2018-04-24","objectID":"/posts/1657.html/:1:0","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"二、GitHub上创建一个仓库 仓库的名字可以随便起，不过这个仓库是作为我们的博客仓库的，所以尽量将名字以 {username}.github.io 的形式来起。 比如，我的GitHub用户名是lewky，我就会把这个仓库命名为lewky.github.io。（为什么要这样起名，后面会说明） ","date":"2018-04-24","objectID":"/posts/1657.html/:2:0","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"三、修改本地的项目配置文件 在 _config.yml 找到如下： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 把刚刚我们新建的GitHub仓库链接配置进来： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:/{user}/{repository}.git branch: master message: 请注意，这里的仓库地址如果写成：https://github.com/{user}/{repository}.git可能会在后边的部署时无法成功，需要将https://github.com改成如下格式： git@github.com: 另外这里的branch和message可以不填，branch会默认是master分支，message会默认用下边的格式模板： Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} ","date":"2018-04-24","objectID":"/posts/1657.html/:3:0","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"四、SSH key的创建与配置 最关键的一步来了，我们需要生成一对密钥对，然后将公钥配置到GitHub账号上。 ","date":"2018-04-24","objectID":"/posts/1657.html/:4:0","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.1 生成RSA密钥对 首先使用 Git Bash 输入： cd ~/.ssh ~ 指的是当前用户的根目录，即 C:\\Users\\{user}\\；而 .ssh 目录下一般存放着公开的SSH key文件： id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 此外还有个 known_hosts 文件，SSH会把我们每个访问过的计算机的公钥(public key)都记录在里面。 如果在使用了 cd ~/.ssh 后能找到路径，那就把该目录下的 id_rsa.pub 文件里的内容复制到剪切板。如果找不到路径，就执行命令： ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 该命令会生成新的SSH key，这里的参数含义： -t: type，生成的密钥类型 -b: bits，指定密钥长度，对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位，一般越长越安全。 -C: comment，提供一个新注释 接着会看到如下提示： Enter file in which to save the key (/c/Users/123/.ssh/id_rsa): 这里按下回车，表示将SSH key保存到默认地址，即：C:\\Users\\{user}\\ 如果本身已经存在一个RSA私钥了，会提示你： /c/Users/123/.ssh/id_rsa already exists. Overwrite (y/n)? 这里输入 y 可以重新生成RSA密钥对；然后就会看到如下提示： Enter passphrase (empty for no passphrase): 这里按下回车，表示不设置密码；接着会再提示你输入重复密码，依然是按下回车。 Enter same passphrase again: 这时候我们的SSH key就生成好了，去 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。 ","date":"2018-04-24","objectID":"/posts/1657.html/:4:1","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.2 在 GitHub 上配置SSH key 接着登陆我们的 GitHub 账号： 进入 Settings 页面 选择 SSH and GPG keys 点击 New SSH key 填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来） 然后在 Key 里将我们刚刚复制的公钥复制进去 最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。 ","date":"2018-04-24","objectID":"/posts/1657.html/:4:2","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.3 验证ssh连接 使用 Git Bash 输入： ssh -T git@github.com 接着会看到： The authenticity of host 'github.com (192.30.253.112)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? 输入 yes，会看到： Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts. Hi lewky! You've successfully authenticated, but GitHub does not provide shell access. 这时候 github.com的公钥被保存到known_hosts文件里，如果我们再执行一次ssh -T git@github.com，就不需要输入yes了，会直接看到： Hi lewky! You've successfully authenticated, but GitHub does not provide shell access. ","date":"2018-04-24","objectID":"/posts/1657.html/:4:3","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.4 部署到 GitHub Pages 输入命令： hexo d 或者 hexo g -d 后一条命令表示生成静态页面并部署到远处仓库，第一次部署会久一点，部署成功后会看到： * [new branch] HEAD -\u003e master INFO Deploy done: git 接着登陆 GitHub 并进入我们的项目仓库，可以看到已经多出了很多文件，且其 message 都是默认的格式： Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} 接下来点击 Settings 进入该仓库的设置页面，找到 Github Pages 这一项，选择以 Master 分支作为 source，然后保存；接下来这个仓库就会被部署到 https://{username}.github.io/{仓库名}。 如果你希望直接通过 https://{username}.github.io/ 来访问你的博客，可以将仓库名改为 {username}.github.io；这样就不需要在url后边添加上仓库名来访问了。 接下来，开始享受你的个人博客吧 :) ","date":"2018-04-24","objectID":"/posts/1657.html/:4:4","tags":["Hexo","Pages服务"],"title":"Hexo搭建博客教程(3) - 远程部署到GitHub Pages","uri":"/posts/1657.html/"},{"categories":["Hexo搭建博客教程"],"content":" 本章主要讲博客的个性化，譬如站点的基本配置（语言、头像、站点图标等）、安装新的Hexo主题（NexT主题）以及主题的配置。 ","date":"2018-04-24","objectID":"/posts/38619.html/:0:0","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"一、修改站点配置 打开站点配置文件 ，找到： # Site title: Hexo subtitle: description: keywords: author: John Doe language: timezone: 根据自己的需要去修改上边的配置，这些配置的注释如下： # Site # 站点标题 title: Hexo # 站点副标题 subtitle: # 站点描述 description: # 站点关键词 keywords: # 站点主人 author: John Doe # 站点语言 language: # 站点时区 timezone: ","date":"2018-04-24","objectID":"/posts/38619.html/:1:0","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"1.1 language 目前 NexT 支持的语言如下： 语言 language English en 简体中文 zh-Hans Français fr-FR Português pt或者pt-BR 繁體中文 zh-hk或者zh-tw Русский язык ru Deutsch de 日本語 ja Indonesian id Korean ko ","date":"2018-04-24","objectID":"/posts/38619.html/:1:1","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"1.2 timezone Hexo 默认使用电脑的时区，也可以自己配置，比如： UTC+8\r ","date":"2018-04-24","objectID":"/posts/38619.html/:1:2","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"二、安装新主题 Hexo有很多大佬开发的主题，很多人使用的是NexT主题，该主题也确实挺简洁好看的，新版本的NexT主题还可以选择四个主题。 那么怎么安装新的Hexo主题呢？ 在我们的Hexo项目路径下，可以看到有个 themes 文件夹，这个文件夹就是用于存放主题文件的。 ","date":"2018-04-24","objectID":"/posts/38619.html/:2:0","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.1 下载 NexT 主题 首先在Hexo项目的路径下打开命令窗口，如果你没有配置好Git的环境变量，请使用Git Bash。 git clone https://github.com/iissnan/hexo-theme-NexT themes/NexT 注意，当前路径是你的Hexo项目根目录，使用上边的命令才能正确地将 NexT 主题clone到themes文件夹下的NexT文件夹里。 接下来你会看到 themes 下多了个 NexT 文件夹，点进去你会看到个.git文件夹，将该文件夹删掉，否则到时候你无法将整个完整的Hexo项目push到GitHub上。 ","date":"2018-04-24","objectID":"/posts/38619.html/:2:1","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.2 启用 NexT 主题 在Hexo项目中，有两个重要的配置文件 _config.yml；这两个配置文件一个在项目根目录下，一个在主题目录下。 前者是站点配置文件，后者是主题配置文件，顾名思义，一个是Hexo项目的配置选项，一个是主题文件的配置选项。 打开站点配置文件，用Windows自带的笔记本是无法打开该文件的，请使用其他的编辑器来打开，常见的编辑器有Notepad++，UltraEdit，EditPlus等。 在站点配置文件中，找到： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape 默认的博客主题就是这个，我们将其修改为NexT；这里的主题是指在 themes 文件夹下的对应主题的文件夹名字。 **注意，在配置文件中所有的属性的值，都必须和前边的 : 之间留一个空格。**比如下边的写法就是错误的，不加上空格的话会出错。 theme:landscape ","date":"2018-04-24","objectID":"/posts/38619.html/:2:2","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.3 选择对应主题的外观 Scheme 打开主题配置文件，找到下边的选项： # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini 默认会使用Muse作为NexT主题的外观，通过将某个scheme前边的#去掉来启动某个外观，如下： # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini ","date":"2018-04-24","objectID":"/posts/38619.html/:2:3","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.4 验证新主题 依然是老操作——启动调试模式服务器： hexo s --debug 启动成功后，使用浏览器访问http://localhost:4000/，看看博客能否访问成功。 ","date":"2018-04-24","objectID":"/posts/38619.html/:2:4","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"三、修改 NexT 主题配置 主题配置文件 _config.yml 位于 themes\\NexT 之下。 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:0","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.1 头像设置 打开主题配置文件，找到如下： # 侧边栏头像 # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # 头像的路径可以放在主题对应文件夹的source里，也可以放在站点根目录的source里，建议放在站点路径上 #avatar: /images/avatar.gif 将avatar前边的#去掉，接着配置图片的路径即可。 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:1","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.2 网站图标 打开主题配置文件，找到如下： # 将你的网站图标放到`{站点根目录}/source/` (推荐）或者`hexo-site/themes/NexT/source/images/`目录下 # 默认的NexT主题的网站图标放在`{站点根目录}/themes/NexT/source/images/`目录下 # 如果你想将自己的网站图标放到`{站点根目录}/source/`根目录下，必须将`/images`从路径中去掉 # 如果你将网站图标放到了`{站点根目录}/source/images`路径下，需要令网站图标的名字和`{站点根目录}/themes/NexT/source/images/`路径下的网站图标不同，否则网站图标会使用后者的同名图标 favicon: small: /images/favicon-16x16-NexT.png medium: /images/favicon-32x32-NexT.png apple_touch_icon: /images/apple-touch-icon-NexT.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 这里需要注意的是，网站图标一般是.ico或者.gif的类型，而且图标的大小一般只有几k而已，可以使用下边的网站制作个人的网站图标，建议先将原本的图标弄成正方形的。 在线制作ico图标 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:2","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.3 菜单设置 打开主题配置文件，找到如下： # 如果该站点是运行在子目录之下（比如：domain.tld/blog；这里的blog就是指我们的博客，前边的是上一级的域名），需要将路径前的斜杠去掉（/archives -\u003e archives；即是将原本的绝对路径改成了相对路径）。 # 用法：`Key：/link/ || 菜单图标` # Key就是菜单名，如果对该菜单名进行了国际化，即将其翻译放到对应的languages文件夹中，将会根据你设置的语言进行加载对应的菜单名翻译；如果没有设置翻译，则会使用这里的Key作为菜单名。这里的Key是大小写敏感的。 # 在`||`分隔符之前的值是该菜单对应的路径 # 在`||`分隔符之后的值是FontAwesome的图标（不懂的请百度什么是FontAwesome以及其用法），如果不指定图标，将会自动使用question这个图标。 menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 使用方法很简单，依然是将需要展示的菜单的前边的#去掉就行，更加具体的操作信息我已经在上边的注释中给出了。 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:3","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.4 标签分类 首先我们需要新建页面，在站点根目录打开命令窗口，分别输入命令： hexo n page \"categories\" hexo n page \"tags\" hexo n page \"about\" 接着你会发现在根目录的 source 目录下多出了上边的三个文件夹，里面各自有一个 index.md 文件。如果之前我们将menu里的categories，tags，about三个菜单解开了封印，那么在创建好这三个页面后就可以成功访问到，否则会报404请求错误。 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:4","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.5 社交链接 # 如果不指定图标，会默认使用globe图标 #social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 老规矩，去掉#注释就可以启动。 ","date":"2018-04-24","objectID":"/posts/38619.html/:3:5","tags":["Hexo","个性化配置"],"title":"Hexo搭建博客教程(2) - 博客的简单个性化配置","uri":"/posts/38619.html/"},{"categories":["Hexo搭建博客教程"],"content":" 前言 搭建个人博客一般有两种选择，一个是使用WordPress，但是需要将博客搭建在服务器上，不过搭建好后写文章方便，适合没有程序基础的人使用。另一个是使用Hexo，相对简洁高效，不需要服务器，既可以部署在本地，也可以将博客部署到GitHub Pages上，支持Markdown语法，缺点是需要有Git基础，写文章比WordPress麻烦点。 初次使用Hexo来搭建个人博客，确实比较手忙脚乱，这里记录一下流程，希望对大家能有所帮助。 （注：本文是只针对Windows平台的搭建教程） 有兴趣的可以戳下这里看看我的个人博客。 How to play 本教程一共分为3章： 第一章是安装环境和本地搭建 第二章是博客的个性化配置 第三章是将博客部署到 GitHub Pages 请根据自身需要选择章节，以节省时间。 ","date":"2018-04-24","objectID":"/posts/22143.html/:0:0","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"一、安装环境 安装Node.js 安装Git 安装Hexo ","date":"2018-04-24","objectID":"/posts/22143.html/:1:0","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"1.1 安装Node.js Hexo是一个基于Node.js的快速、简洁且高效的静态站点生成框架，想要安装Hexo，需要先安装Node.js，官网的安装包有两种，一种是安装程序.msi文件，一种是.zip压缩包，这里选择.msi文件，安装后会自动配置好环境变量。 下载链接 ","date":"2018-04-24","objectID":"/posts/22143.html/:1:1","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"1.2 安装Git Git就不多说了，作为开发者或多或少都会接触过吧，直接前往官网下载安装包即可。操作教程网上也是一堆，这里就不赘述了。 下载链接 如果Git和Node.js的环境变量都配置好了，可以通过在cmd中确认安装结果。 git --version node -v ","date":"2018-04-24","objectID":"/posts/22143.html/:1:2","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"1.3 安装Hexo 安装好Node.js，就可以使用npm来安装Hexo npm install -g hexo-cli 安装完毕后，可以通过hexo version来确认是否安装成功。 ","date":"2018-04-24","objectID":"/posts/22143.html/:1:3","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"二、开始搭建个人博客 千里之行，始于足下，在安装好所有的环境之后，我们终于可以开始搭建博客的第一步了。 ","date":"2018-04-24","objectID":"/posts/22143.html/:2:0","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.1 初始化Hexo项目 首先是选择一个文件夹，用来给我们我们的个人博客的存放各种文件。接着进入该文件夹的路径，打开cmd命令窗口，这里有两种打开方式： 按住Shift，同时点击鼠标右键，选择在此处打开命令窗口。 在上方的地址栏里输入cmd，接着回车即可快速打开命令窗口。 当然，你也可以直接Win+R然后输入cmd来打开命令窗口，不过需要再通过cd命令将路径切换到你指定的文件夹。 接着输入指令来初始化你的博客 hexo init 初始化成功后，你会看到 Start blogging with Hexo! ","date":"2018-04-24","objectID":"/posts/22143.html/:2:1","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.2 生成静态页面文件 接下来，执行命令 hexo g 该命令用来生成静态页面文件到public目录，Hexo会将 source 文件夹中除 posts 文件夹之外，以下划线_开头命名的文件或文件夹、以及隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。 最后，我们只要启动Hexo服务器就行了。 ","date":"2018-04-24","objectID":"/posts/22143.html/:2:2","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.3 本地启动Hexo服务器 hexo s --debug Hexo启动服务器的速度非常快，很快你就可以看到 Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 恭喜你，你的个人博客已经搭建成功了，接下来只要在浏览器输入http://localhost:4000/就可以在本地访问你的博客了。 这里使用hexo s也可以启动服务器，只不过加上--debug 参数，如果运行中出错可以看到错误信息。 ","date":"2018-04-24","objectID":"/posts/22143.html/:2:3","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"2.4 关闭Hexo服务器 要想关闭服务器，只需要在命令窗口按下Ctrl+C就可以了，这个组合键不仅仅用于关闭服务器，事实上你在cmd窗口中任何执行中的命令都可以用这个组合键来结束命令，只要连按两次该组合键就可以连输入Y或者N都不用。 ","date":"2018-04-24","objectID":"/posts/22143.html/:2:4","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"三、常用的命令 hexo new \"postName\" #新建文章 hexo new page \"pageName\" # 新建页面 hexo generate # 生成静态页面至public目录 hexo server # 启动服务器(默认端口4000，'ctrl+c'关闭server) hexo deploy # 项目部署 hexo help # 查看帮助 hexo version # 查看Hexo的版本 hexo clean # 清除Hexo的缓存 上边的一些命令可以使用简写 hexo n hexo g hexo d hexo s ","date":"2018-04-24","objectID":"/posts/22143.html/:3:0","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.1 本地调试三连 hexo clean hexo g hexo s --debug ","date":"2018-04-24","objectID":"/posts/22143.html/:3:1","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"3.2 远程部署三连 hexo clean hexo g hexo d 注：在使用部署命令时，需要先用npm安装 hexo-deployer-git 插件： npm install hexo-deployer-git --save\r ","date":"2018-04-24","objectID":"/posts/22143.html/:3:2","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"四、撰写第一篇博文 Hexo撰写博文也不难，分为 post 和 draft 两种，其中 post 存放在 source/_posts 目录下，draft 存放在 source/_drafts 目录下。 post 和 draft 的区别在于前者会被发布到博客，而后者不会被发布。 ","date":"2018-04-24","objectID":"/posts/22143.html/:4:0","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.1 第一篇文章 hexo n post \"my-first-post\" Hexo会自动在 source/_posts 目录下新建一个名为 my-first-post 的 .md 文件；打开该文件，可以看到： --- title: my-first-post date: 2018-04-21 23:11:30 tags: --- 这是 post 模板自动生成的 YAML 文件头，title 是这篇 post 的标题，可以将其改为 My First Post；date 是创建的日期；tags 是该 post 的标签，可以添加自定义的标签： --- title: My First Post date: 2018-04-21 23:11:30 tags: - demo - first-post --- 接着再进行本地调试三连，就可以看到刚刚写好的博文了。 hexo clean hexo g hexo s --debug ","date":"2018-04-24","objectID":"/posts/22143.html/:4:1","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":["Hexo搭建博客教程"],"content":"4.1 第一篇草稿 创建命令和前边类似： hexo n draft \"my-first-draft\" 另外草稿的头文件是没有日期的： --- title: my-first-draft tags: --- 草稿文件是不会被 hexo g 命令生成到public目录下的。 ","date":"2018-04-24","objectID":"/posts/22143.html/:4:2","tags":["Hexo","简单入门"],"title":"Hexo搭建博客教程(1) - 安装环境与本地搭建","uri":"/posts/22143.html/"},{"categories":null,"content":"Running Time \r ","date":"2018-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博主相关 ","date":"2018-04-24","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"近况 17年本科毕业，目前在珠海从事Java开发，码农界萌新 (⌒▽⌒) ","date":"2018-04-24","objectID":"/about/:1:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技能 Java, JavaWeb （性感码农，在线搬砖） ","date":"2018-04-24","objectID":"/about/:1:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"联系 email: 1019175915@qq.com github@lewky csdn@lewky_liu cnblogs@yulinlewis ","date":"2018-04-24","objectID":"/about/:1:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"随笔 → 戳我查看随笔 ← ","date":"2018-04-24","objectID":"/about/:1:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"站点相关 ","date":"2018-04-24","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"站点及主题版本 hugo: v0.74.2-48565DE6 windows/amd64 BuildDate: 2020-07-17T17:22:50Z\rLoveIt: v0.2.10\r ","date":"2018-04-24","objectID":"/about/:2:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"建站日志 → 戳我查看建站日志 ← ","date":"2018-04-24","objectID":"/about/:2:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"友情链接 暂时没有友链哟 (ﾉ*･ω･)ﾉ～ 想添加友链可以在下方留言~ \r/* 站点运行时间 */\rfunction show_date_time(){\rwindow.setTimeout(\"show_date_time()\", 1000);\r/* 请修改这里的起始时间 */\rBirthDay=new Date(\"04/24/2018 15:00:00\");\rtoday=new Date();\rtimeold=(today.getTime()-BirthDay.getTime());\rsectimeold=timeold/1000\rsecondsold=Math.floor(sectimeold);\rmsPerDay=24*60*60*1000\re_daysold=timeold/msPerDay\rdaysold=Math.floor(e_daysold);\re_hrsold=(e_daysold-daysold)*24;\rhrsold=setzero(Math.floor(e_hrsold));\re_minsold=(e_hrsold-hrsold)*60;\rminsold=setzero(Math.floor((e_hrsold-hrsold)*60));\rseconds=setzero(Math.floor((e_minsold-minsold)*60));\rdocument.getElementById('days').innerHTML=\"本站已运行\"+daysold+\"天\"+hrsold+\"小时\"+minsold+\"分\"+seconds+\"秒\";\r}\rfunction setzero(i){\rif (i ","date":"2018-04-24","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["随笔"],"content":"随笔 就是随手写写的乱七八糟的玩意…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:0:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2020-10-04 一个月的交接结束，正式离开了毕业后的第一家公司。心情有点复杂，不知道怎么形容…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:1:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-07-01 哈哈，一发十连出了银老板和赫默，爽到！！！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:2:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-06-08 这周的JOJO简直爽到！尤其是最后的银镇登场bgm，真的炸裂！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:3:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-05-15 又要开打贸易战了……互联网的又一波失业寒潮。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:4:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-04-24 好久没更新博客了，这阵子确实忙了很多，人也颓唐了不少，是时候改变了，不能继续丧下去了…… 另外—— 建站一周年纪念！！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:5:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-04-23 已经连续三天在食堂拿到半价的绿盘子了，可能预示着这阵子会运势上升？晚上买了半个榴莲吃，花了68块大洋，一斤18.8，虽然贵了点，但美味程度确实不错，好吃！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:6:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-03-07 今天是个神奇的日子。 早上煮的鸡蛋是双黄蛋； 上午同事报喜生了龙凤胎； 中午食堂破天荒给了一对鸡翅； 怎么形容今天呢？简直是JOJO的奇妙冒险级别的日子~ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:7:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-02-19 猿宵节 猿宵节：通常指程序猿通宵写代码的节日 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:8:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-02-18 建站300天纪念！！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:9:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-02-17 下午看到附近的狗子躺在地上不停往空中踢腿，跟踩单车一样，百度了下也找不到类似的状况，emmm，这狗不会是在瘦腿吧…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:10:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-02-14 今天是情人节，公司刚好在这天进行开工拜神活动，收到个开工红包，顺带吃了波烤乳猪和烧鸡。这烤乳猪比去年的好吃不少！不沾酱料吃最好，咸咸的脆脆的，沾了白糖后反而很腻。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:11:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-01-27 时间过得真快，转眼就要回家过春节了，新的一年里也快过去头个月了。 发现自己是真的越发懒散怠惰了，想想去年的这个时候，还心怀高远，精神焕发，再看看如今，去年定下的目标是越发地遥不可及了。 应该怎么有效地调节情绪呢，总觉得自己是个有自知之明却没有自制之力的废材呀。。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:12:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2019-01-08 第一次吃牛奶草莓，闻起来确实很香，不过吃起来倒是和普通草莓差不多。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:13:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-12-19 不知道写点啥，最近一直状态不好，记录下之前写的几句诗歌吧~ 纵心猿，驰意马。 秋风秋雨织秋意，春花春水鉴春光。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:14:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-11-14 双十一买的戴尔和三只松鼠终于都到了，开心！！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:15:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-11-04 这个周末看了整整两天的《乌龙闯情关》，还是以前的电视剧好看。剧中的刘病已、霍水仙、许平君、大牛、鸠摩空都让人印象深刻，也知道了故剑情深的典故。 现在各种快餐文化，人心浮躁，还是以前的影视、小说作品让人回味无穷，我不是个怀旧的人，却对过去的一些回忆很有感怀。这些都是宝贵的精神食粮，可能是一首歌，也可能是荧幕中、笔墨下的一个人物，每每带给我鼓舞与勇气。 我也要努力，冲鸭！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:16:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-10-24 今天是程序员节，在这个日子里，我终于将自己定制的hexo主题正式起名为Beep了~ 1024节日快乐~ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:17:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-10-18 又看了一遍JOJO第四部的boss战，真是百看不厌，爱死JOJO了！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:18:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-10-14 每周都是等待JOJO新一集的煎熬和畅享JOJO新一集的舒爽…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:19:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-10-08 《逍遥游》完结了，又追完了一本小说，现在能看的书真的不多了。。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:20:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-10-07 好久没更新随笔了，这阵子人懒散了好多，肚子也多了几圈，国庆回到家里人人都说我胖了，确实，上班一年我竟然重了二十斤左右。要知道当初大一那会还不到一百斤，瘦的跟猴子似的，现在却已经一百二十多了。 马上就要新的一年了，距离三十大关又进了一步，我时间不多啦，得加把劲践行自己的目标，顺便把肥给减了。。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:21:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-09-18 今天竟然被老大叫进去开了波会，会议中对我上半年的表现和绩效表示肯定，加薪之余望我能再接再厉。哈哈，还是挺开心的，感觉自己一直以来的努力没有白费，果然单身能促进生产力啊_(:з」∠)_ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:22:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-09-12 今天早上看到唐家三少妻子去世的消息，有些震惊，心情不知道怎么形容，难受又复杂。高中最早接触的网络小说之一就是三少写的光之子，里边男主女主就是化用的他们夫妻两人的名字，到现在还记忆深刻。 曾经受到三少的影响，很想去写书，只是时间无情，人很脆弱。。只能说句，三少，节哀。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:23:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-09-01 妈蛋啊！！昨晚买的榴莲千层蛋糕，本来是作为第二天早餐的，结果起床一看整个蛋糕都化水了，还发出腐烂的臭味！！我的心在滴血，八块钱的蛋糕就这么没了…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:24:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-27 卧槽，下了一天一夜的雨，第二天下班收衣服时发现上衣有半边被雨水打湿而发霉了…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:25:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-27 加班到九点半下班，赶上下大雨，然后雨伞又开始漏雨，好气哦。 都买了三把雨伞了，怎么还是漏雨的货！ 伞外下大雨，伞内下小雨。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:26:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-17 今天是七夕，emmm 单身汪岁 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:27:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-13 自律真的很重要，我要培养自己的自律能力，毕竟已经是叔叔辈了…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:28:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-06 今晚一口气看了《刺客伍六七》这部国产动画，简直爽到！上一部让我看得这么酣畅淋漓的国产动画是《凸变英雄》，之前就经常瞥见刺客伍六七的消息，只是一直都听不起兴趣去看，直到今天无意间点开了第一集，之后就一发不可收拾了，还好没错过。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:29:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-08-02 建站100天！！！ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:30:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-07-29 趁着这个月还没结束，赶紧开始撸品优购，还是敲完整的一个项目爽快~ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:31:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-07-28 今天去看了《西虹市首富》，挺有趣的，沈腾还是那么好玩，开心麻花街的作品还是让人看得好开心。当初那个春晚小品《扶不扶》真的惊为天人，已经看过十几遍了，O(∩_∩)O哈哈~ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:32:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-07-15 最近发现吃了香蕉后就会胃酸过多，也就是俗称的烧心。百度了下： 香蕉性寒，脾胃虚寒、便溏腹泻者不能多食、生食，胃酸过的多者也不要吃香蕉，香蕉会增加胃酸分泌。所以最好不要空腹吃香蕉。 明明以前吃香蕉都没什么事情，而且还是特地在饭后吃的，看来身体是真的越来越差了，要多锻炼才行。 ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:33:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-06-13 喝了这么多年的牛奶才尴尬地发现，原来我的肠胃会对牛奶过敏，一喝牛奶就会拉肚子，以前一直以为是其他原因，没想到是对牛奶过敏，看来以后只能喝酸奶了…… ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:34:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["随笔"],"content":"2018-04-24 在CSDN也写了一年的博客了，现在终于有了专属的个人博客了，用来记录自己平日里的感悟和积累~ ","date":"2018-04-24","objectID":"/posts/d65a1577.html/:35:0","tags":["随笔","生活"],"title":"随笔","uri":"/posts/d65a1577.html/"},{"categories":["建站日志"],"content":"Siting Log o(*￣▽￣*)ブ 持续更新中 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:0:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2020-10-14 修复LoveIt主题的部分bug，更改了部分样式，主要包括： 添加背景图片轮播 归档、分类页面添加了数量统计 修改了h2的样式 缩小目录的字体 修改了引用块样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:1:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2020-10-09 开始将博客从Hexo迁移到Hugo，决定使用LoveIt主题，并正式将博客部署到了Pages上。 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:2:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-12-19 最近发现打开页面略慢略卡，发现是jquery-backstretch的cdn加载不了，原本官网使用的cdn是cloudflare的，现在改成了另一个cdn地址。 于是将jquery-backstretch的cdn修改了官网上最新的，总算变快了。 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:3:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-11-16 将鼠标点击产生的文字设为不可选定 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:4:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-11-10 解决在适配手机屏幕时，页面右上角的GitHub彩带被覆盖掉的问题。 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:5:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-09-18 添加了图片懒加载插件hexo-lazyload-image 出于强迫症，还是关闭了不蒜子的统计功能，目的是为了解决下边的问题二。 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:6:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-08-21 最近发现了两个问题： 如果文章不写小标题，是不会生成文章目录的，如果启用了leancloud的阅读计数功能，这时候这篇文章的阅读页面的侧边栏就会失去affix.js的固定定位效果；(该bug在火狐浏览器下偶尔会触发，在360浏览器下百分百触发) 如果启用了不蒜子计数，在360浏览器下如果滚动页面时，侧边栏的底部无法和正文模块的底部持平，侧边栏底部会比正文模块的短一些。该问题在火狐浏览器下不存在。 解决方案： 问题一需要给每篇文章都起至少一个小标题，这样就会自动生成文章目录，也就不存在这个问题了。 也可以选择关闭leancloud的阅读计数功能，重新生成静态页面就行了。 问题二对于强迫症来说很难受，要么关闭不蒜子计数，要么不使用360浏览器。 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:7:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-08-18 修改了hexo-neat的压缩选项，优化页面的加载 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:8:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-08-17 添加了新的b站头像挂件 添加头像挂件自动刷新功能 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:9:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-08-14 去掉了文本首行缩进，首行缩进有个问题：当一个段落内存在换行时，比如使用\u003cbr\u003e，会导致换行后无法缩进，不太好看；找了好久也没找到解决的方法，只能取消文本的首行缩进了。 如果需要首行缩进还是自己手动添加\u0026emsp;\u0026emsp;(全角空格，即对应两个中文空格)…… ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:10:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-30 修改categories page的样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:11:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-26 改善文章目录的换行问题 添加文章不在首页显示的功能：在文件头里添加not_show: true即可启用 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:12:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-21 添加了404页面 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:13:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-19 修改代码块diff样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:14:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-10 修改文本标题样式 文本首行缩进两个字符 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:15:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-07-07 添加网页标题监听事件 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:16:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-30 代码块添加复制按钮 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:17:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-25 修改about页面 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:18:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-20 使用 hexo-neat 压缩博文插件，优化博客静态资源 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:19:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-16 添加 Font Awesome 4.6.2的CDN，支持使用font awesome4或5 友情链接里添加恶搞页面 关于页面添加站点运行时间 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:20:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-16 修改阅读全文按钮样式 页脚爱心图形动画 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:21:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-16 修改站点标题样式 修改页脚样式 添加站点背景图片轮播 文章摘要添加标签 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:22:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-14 修改文章标签样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:23:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-12 使用 sitemap 和 baidusitemap ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:24:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-10 改用来必力作为评论系统 修改鼠标指针 修改引用块样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:25:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-07 添加友链并修改其样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:26:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-06 启用 Gitment ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:27:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-05 开启文章目录显示功能，替换掉显示错误的FontAwesome图标 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:28:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-04 CDN有时候加载比较慢，所以去掉原本引入的 Font Awesome 4 和 Font Awesome Free CDN，直接将下载好的 Font Awesome 5 解压复制到 lib 目录下 这里吐槽一下，由于 Font Awesome 从版本4升级到5修改了很多图标的名称，所以我花了一个多小时的时间去一个个替换这些改动的图标，累死… ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:29:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-03 添加头像旋转 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:30:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-06-01 去掉脚注超链的底部线条 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:31:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-31 添加 custom.js 文件 添加鼠标点击文字特效 添加头像挂件点击事件 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:32:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-30 设置文章摘要里的图片的最大宽度 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:33:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-27 缩小文章摘要里标题和正文的间距 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:34:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-25 修改预格式代码块(用tab键插入的代码块)的样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:35:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-17 重新修改了头像挂件样式 修改站点标题样式 修改菜单栏样式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:36:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-16 将头部彩带图片保存到本地，避免因无法通过访问该图片(被墙)而显示不出来 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:37:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-14 修改头像样式并添加了头像挂件(可耻地偷了波b站的头像挂件) ( ゜- ゜)つロ 重修修改了加密文章的js代码，并将文章超链的打开方式复原 (눈_눈) ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:38:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-13 修改文章超链的打开方式，添加文章置顶功能 修改字体大小，关闭文章目录显示序号功能 添加 by-nc-sa 许可协议，回到顶部按钮显示百分比 修改文章内的超链样式、行内代码块的样式、回到顶部按钮样式 启用搜索功能、顶部加载条 去掉图片边框 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:39:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-12 文章启用字数统计、阅读时长，修改其显示的样式 使用 Font Awesome Free CDN ( upgrade from version 4 to 5 ) 添加文章加密功能 指定 Markdown 的解析器 修改 Hexo 永久链接的默认格式 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:40:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-11 页面右上角添加 Fork me on GitHub ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:41:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-09 修改 scaffolds 目录下的 post/draft.md 模板，并添加自定义的模板文件 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:42:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-07 首页文章显示预览，添加字数统计和阅读时长 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:43:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-05-01 添加建站日志 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:44:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-04-30 启用 tags 和 categories 菜单 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:45:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["建站日志"],"content":"2018-04-24 使用 Hexo 搭建个人博客 ","date":"2018-04-24","objectID":"/posts/e62c38c45.html/:46:0","tags":["建站日志"],"title":"建站日志","uri":"/posts/e62c38c45.html/"},{"categories":["Eclipse"],"content":"情景 有时候我们想改变web项目的web module version，比如说原本是2.4版本，我们想改成3.0版本，通过右键项目名 -\u003e Properties -\u003e Project Facets，选中Dynamic Web Module后边的版本，将2.4改成3.0 这时候会报错误：Cannot change version of project facet Dynamic Web Module to 3.0. 而且这时候改动web.xml的文件头从2.4改成3.0版本的文件头也会报错。 ","date":"2018-04-03","objectID":"/posts/4e16194f.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 如何修改web项目的web module version","uri":"/posts/4e16194f.html/"},{"categories":["Eclipse"],"content":"解决办法 1、这时候我们需要找到该项目的目录，进入.setting文件夹，打开org.eclipse.wst.common.project.facet.core.xml 2、我们可以发现在这个xml文件中，有这样一个标签： \u003cinstalled facet=\"jst.web\" version=\"2.4\"/\u003e 3、将这里的version改成你想要的版本，比如改成3.0 4、保存该文件的改动，接着刷新Eclipse中的该项目(左键选中项目名，按F5刷新项目) 5、接着再去Properties -\u003e Project Facets ， 将Dynamic Web Module改为3.0；然后将web.xml的文件头改为对应3.0版本的文件头；此时会发现可以修改成功而不会报错。 ","date":"2018-04-03","objectID":"/posts/4e16194f.html/:2:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 如何修改web项目的web module version","uri":"/posts/4e16194f.html/"},{"categories":["影评"],"content":" ReadyPlayerOne \" ReadyPlayerOne 这部电影国内译名又叫头号玩家、玩家一号，讲述的是在未来人们为了躲避一团糟的现实而沉迷于一个名为绿洲的现实虚拟游戏。 虽然这部电影并没有直接传达什么正能量的道理之类的，但是这部3D电影所展现出来的绿洲的奇妙与各种彩蛋却是令人看得目不暇接、直呼过瘾。这绝对是一部值得去电影院大饱眼福的爽快作品！ ","date":"2018-03-31","objectID":"/posts/23475.html/:0:0","tags":["影评","生活"],"title":"《Ready Player One》观后感","uri":"/posts/23475.html/"},{"categories":["影评"],"content":" 小萝莉的猴神大叔 \" 小萝莉的猴神大叔 今天去看了这部评分高达9.6分的印度电影，确实是挺好看的。这是讲述一个印度摩罗神信徒在没有护照和签证的情况下，不惜越过边境也要坚持将一个异国走失的哑巴小女孩送回巴基斯坦的父母家里的故事。印巴两国之间的仇恨，迥异的宗教信仰、森严的种姓制度都令我印象深刻。 就算是宗教信仰不同，也不应当局限于各自的神明教义，神明传播于世间的是爱，而不是仇恨，不同的宗教信仰，也是有着共通的点。而上一代人的仇恨，也不应归结到下一代的孩子身上。仇恨的故事固然吸引眼球，但是爱的故事更应该被关注传颂。 对于印巴两国的大人来说，对方即是邪恶，但是战争本就如此，不存在绝对的正义与邪恶，只有恪守信仰、遵从心中那杆爱与公正的天秤的一方，才是真正无愧于心的正义者。 ","date":"2018-03-17","objectID":"/posts/73.html/:0:0","tags":["影评","生活"],"title":"《小萝莉的猴神大叔》观后感","uri":"/posts/73.html/"},{"categories":["Eclipse"],"content":"情景 Eclipse如果更换一个新的工作空间，需要重新设置视图、配置等一系列东西，算是想到麻烦的一件事情，其实我们完全可以将旧的工作空间里的配置拷贝到新的工作空间里，这样就可以省去重新配置的麻烦了~ 具体操作如下： 在${workspace(你电脑里原本的工作空间目录)}/.metadata/.plugins里有这样两个文件夹：org.eclipse.core.runtime和org.eclipse.ui.workbench，将新的工作空间里的同名文件夹删了，再将这两个文件夹复制到新的工作空间就行了！ org.eclipse.core.runtime：保存着Eclipse的用户配置，包括视图、编码、各种插件的配置(window下的preference里边的插件配置)等 org.eclipse.ui.workbench：保持着ui上的配置，包括上方的快捷工具栏和下方的view窗口等 如果不知道自己正在使用的工作空间在哪个目录下，请点击Eclipse左上角的File→switch workspace→other，显示的就是当前工作空间的目录。另外，在这里有个copy setting，可以选择转换到新的工作空间时拷贝原本的配置，但这里拷贝的其实只是org.eclipse.ui.workbench，缺少了org.eclipse.core.runtime，所以这种方法会丢失部分配置。 另外不要没事就随便转换工作空间，Eclipse容易崩溃_(:3」∠)_ ","date":"2017-09-15","objectID":"/posts/3084e42f.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 如何在新的工作空间使用原来的配置(编码、视图、快捷键、插件设置等)","uri":"/posts/3084e42f.html/"},{"categories":["Eclipse"],"content":"配置方式 一共需要设置三个地方： Window-\u003ePreferences-\u003eGeneral -\u003eContent Type-\u003eText-\u003eJSP，在 最下面设置为UTF-8 Window-\u003ePreferences-\u003eGeneral-\u003eWorkspace，将Text file encoding 设置UTF-8 Window-\u003ePreferences-\u003eWeb-\u003eJSP Files，设置为 ISO 10646/Unicode(UTF-8) ","date":"2017-09-15","objectID":"/posts/c23cad48.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 修改默认编码为utf-8","uri":"/posts/c23cad48.html/"},{"categories":["Eclipse"],"content":"配置方法 Eclipse的properties文件是默认ISO-8859-1编码的，如果在properties里输入中文会导致乱码，此时需要修改其编码为utf-8，具体步骤如下： Window→Preferences→General→Content Types→Text，然后单击Java Properties Files，选定下方的*.properties(locked)，接着将最下方的ISO-8859-1改为utf-8，然后点击旁边的 Update，最后点击OK。 ","date":"2017-07-17","objectID":"/posts/9cdb7e13.html/:1:0","tags":["IDE工具","Eclipse"],"title":"Eclipse - 修改properties文件的编码","uri":"/posts/9cdb7e13.html/"}]